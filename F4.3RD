1 SEARCH MCS808 ;THE UNIVERSAL FILE
2 SUBTTL COMMON FILE
3 SALL
4 LENGTH==1 ;0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
5 REALIO==1
6 CASSW==1 ;CASSETTE SWITCH (CSAVE, CLOAD)
7 LPTSW==0
8 DSKFUN==0 ;ON TO READ/WRITE
9 CONSSW==0
10
11 CONTRW==1 ;ALLOW ^0
12 IFE REALIO,<
13 LPTSW==0 ;SIMULATOR DEFAULTS
14 CASSW==0
15 CONSSW==0
16 DSKFUN==0
17 CONTRW==0>
18
19 IFE LENGTH,<
20 EXTFNC==0 ;ON MEANS EXTENDED FUNCTIONS
21 MULDIM==0 ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
22 STRING==0 ;ON MEANS STRINGS ALLOWED
23 CASSW==0
24 LPTSW==0
25 DSFFUN==0
26 CONSSW==0
27 CONTRW==0>
28
29 IFE LENGTH-1,<
30 EXTFNC==1
31 MULDIM==1
32 STRING==1>
33
34 IFE LENGTH-2,<
35 EXTFNC==1
36 MULDIM==1
37 STRING==1>
38
39 DEFINE SYNCHK(A),<RST 1
40 A>
41 DEFINE CHRGET,<RST 2>
42 DEFINE OUTCHR,<RST 3>
43 DEFINE COMPAR,<RST 4>
44 DEFINE FSIGN,<RST 5>
45 DEFINE PUSHM,<RST 6>
46 DEFINE PUSHEM,<PUSHM
47 PUSHM>
48 DEFINE ACRLF,<
49 ^D13
50 IFN STRING,<^D10>>
51 DEFINE PUSHR,<
52 PUSH D
53 PUSH B>
54 DEFINE POPR,<
55 POP B
56 POP D>
57 DEFINE MOVRI(B,C,D,E),<
58 XWD ^O1000,^O001 ;;"LXI B"
59 EXP C
60 EXP B
61 XWD ^O1000,^O021 ;;"LXI D"
62 EXP E
63 EXP D>
64
65 IF1,<
66 IFE LENGTH,<PRINTX /SMALL/>
67 IFE LENGTH-1,<PRINTX /MEDIUM/>
68 IFE LENGTH-2,<PRINTX /BIG/>
69 IFE REALIO,<PRINTX /SIMULATE/>
70 IFN REALIO,<PRINTX /ON MACHINE/>
71 IFN CASSW,<PRINTX /CASSETTE/>
72 IFN LPTSW,<PRINTX /LPT/>
73 IFN DSKFUN,<PRINTX /DISK/>
74 IFN CONSSW,<PRINTX /CONSOLE/>>
75 PAGE
76 SUBTTL FLOATING POINT MATH PACKAGE CONFIGURATION
77 TITLE
78
79 IFNDEF LENGTH,<
80 PRINTX !!! MUST HAVE COM !!!
81 END>
82
83 RADIX 8 ;!!! ALERT !!!
84 ;THROUGHOUT THE MATH PACKAGE!!
85
86 .P==0
87
88 INTERNAL ZERO,FLOAT,FLOATR,MOVE,FADD,FADDS,FSUB,FMULT,FDIV,FIN,FOUT
89 INTERNAL PUSHF,ABS,INT,QINT,SGN,SQR,RND,SIN,FCOMP,SIGNC,OVERR
90 INTERNAL INPRT,LINPRT,MOVFM,MOVMF,MOVFR,MOVRF,MOVRM,NEG,INRART,INXHRT
91 IFN EXTFNC,<
92 INTERNAL FPWR,EXP,LOG,COS,TAN,ATN,FONE>
93 IFN MULDIM&<LENGTH-2>,<
94 INTERNAL DMULT>
95 IFN STRING,<
96 INTERNAL SIGNS>
97 IFN LENGTH-2,<
98 INTERNAL PADDT,FSUBT,FMULTT,FDIVT>
99 IFE LENGTH-1,<
100 INTERNAL FPWRT>
101 IFE LENGTH-2,<
102 INTERNAL VMOVMF,VMOVFM,FRCINT,PRCSNG,FRCDBL,VNEG,PUFOUT,DCXBRT,IADD
103 INTERNAL ISUB,IMULT,IDIV,ICOMP,INEG,DADD,DSUB,DMULT,DDIV,DCOMP,INTFNC>
104
105
106 EXTERNAL MINUTK,PLUSTK,DV0ERR,ERROV,FCERR,SIGN
107 EXTERNAL $CODE
108 IFE LENGTH-2,<
109 EXTERNAL DFACLO,ARG,ARGLO,VALTYP,TMERR,TEMP2,TEMP3>
110
111
112 COMMENT %
113         EXTERNAL LOCATIONS USED BY THE MATH PACKAGE
114 ; THE FLOATING ACCUMULATOR
115 IFE     LENGTH-2,<
116 BLOCK 1            ;[TEMPORARY LEAST SIGNIFICANT BYTE]
117 DFACLO: BLOCK 4>   ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
118 FACLO:  BLOCK 3    ;[LOW ORDER OF MANTISSA (LO)]
119                    ;[MIDDLE ORDER OF MANTISSA (MO)]
120                    ;[HIGH ORDER OF MANTISSA (HO)]
121 FAC:    BLOCK 2    ;[EXPONENT]
122                    ;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
123 IFE     LENGTH-2,<
124 ARGLO:  BLOCK 7    ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
125 ARG:    BLOCK 1>   ; PRECISION]
126 FBUFFR: BLOCK ^D13 ;BUFFER FOR FOUT
127 IFE     LENGTH-2,<BLOCK ^D<30-13>>
128
129
130 THE FLOATING POINT FORMAT IS AS FOLLOWS:
131
132 THE SIGN IS THE FIRST BIT OF THE MANTISSA
133 THE MANTISSA IS 24 BITS LONG
134 THE BINARY POINT IS TO THE LEFT OF THE MSB
135 NUMBER = MANTISSA * 2 - EXPONENT
136 THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
137 THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
138 THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
139 SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
140 AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO, THE OTHER BYTES ARE IGNORED
141 TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
142     TO SHIFT RIGHT, EXP:=EXP+1
143     TO SHIFT LEFT, EXP:=EXP-1
144
145 SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
146     [BITS 17-24 OF THE MANTISSA]
147     [BITS 9-16 OF THE MANTISSA]
148     [THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0]
149     [THE EXPONENT AS A SIGNED NUMBER + 200]
150 (REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
151
152 ARITHMETIC ROUTINE CALLING CONVENTIONS:
153
154 FOR ONE ARGUMENT FUNCTIONS:
155     THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
156 FOR TWO ARGUMENT OPERATIONS:
157     THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
158     THE SECOND ARGUMENT IS IN THE FAC
159     THE RESULT IS LEFT IN THE FAC
160
161 THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
162 THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS,
163 MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
164 THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK,
165 POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
166 NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
167 BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER,
168
169 ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN,
170 THIS IS DONE SO IF A NUMBER IS STORED IN MEMORY, IT CAN BE PUSHED ON THE
171 STACK WITH TWO PUSHM'S. THE LOWER BYTE OF EACH PART IS IN THE LOWER
172 MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
173 ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
174 THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
175 %
176 PAGE
177 SUBTTL FLOATING POINT ADDITION AND SUBTRACTION
178 ;ENTRY TO FADD WITH POINTER TO ARG IN (HL)
179 FADDH: LXI H,FHALF ;ENTRY TO ADD 1/2
180
181
182 FADDS: CALL MOVRM ;GET ARGUMENT INTO THE REGISTERS
183
184
185 JMP FADD ;DO THE ADDITION
186
187
188
189
190 ;SUBTRACTION FAC:=ARG-FAC
191 IFN EXTFNC,<
192 FSUBS: CALL MOVRM> ;ENTRY IF POINTER TO ARG IS IN (HL)
193
194
195 IFE LENGTH-1,<
196 XWD 1000,041> ;"LXI H" AROUND NEXT 2 BYTES
197 IFN LENGTH-2,<
198 FSUBT: POPR> ;ENTRY IF ARGUMENT IS ON THE STACK
199
200 FSUB: CALL NEG ;NEGATE SECOND ARGUMENT
201
202
203 ;FALL INTO FADD
204
205
206 ;ADDITION FAC:=ARG+FAC
207 ;ALTERS A,B,C,D,E,H,L
208 IFN LENGTH-2,<
209 XWD 1000,041 ;"LXI H" AROUND NEXT 2 BYTES
210 FADDT: POPR> ;ENTRY IF ARGUMENT IS ON THE STACK
211
212 FADD: MOV A,B ;CHECK IF FIRST ARGUMENT IS ZERO
213 ORA A ;GET EXPONENT
214 RZ ;IT IS, RESULT IS NUMBER IN FAC
215 LDA FAC ;GET EXPONENT
216
217
218 ORA A ;SEE IF THE NUMBER IS ZERO
219 JZ MOVFR ;IT IS, ANSWER IS IN REGISTERS
220
221
222
223 ; WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
224 ; AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS. THEN WE CAN JUST ADD OR
225 ; SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE,
226 SUB B ;CHECK RELATIVE SIZES
227 JNC FADD1 ;IS FAC SMALLER?
228
229
230 CMA ;YES, NEGATE SHIFT COUNT
231 INR A
232 XCHG ;SWITCH FAC AND REGISTERS, SAVE (DE)
233 CALL PUSHF ;PUT FAC ON STACK
234
235
236 XCHG ;GET (DE) BACK WHERE IT BELONGS
237 CALL MOVFR ;PUT REGISTERS IN THE FAC
238
239
240 POPR ;GET THE OLD FAC IN THE REGISTERS
241
242 FADD1:
243 IFN LENGTH,<
244 CPI 31 ;ARE WE WITHIN 24 BITS?
245
246 RNC> ;NO, ALL DONE
247 PUSH PSW ;SAVE SHIFT COUNT
248 CALL UNPACK ;UNPACK THE NUMBERS
249
250
251 MOV H,A ;SAVE SUBTRACTION FLAG
252 POP PSW ;GET SHIFT COUNT BACK
253 CALL SHIFTR ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
254
255
256
257 ; IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM, IF THE SIGNS ARE
258 ; DIFFERENT, THEN WE HAVE TO SUBTRACT THEM. WE HAVE TO DO THIS BECAUSE THE
259 ; IMANTISSAS ARE POSITIVE. JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
260 ; THE FAC, SD IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
261 ; FAC: HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
262 ; COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
263 ; WAS NEGATIVE, IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
264 ; COMPLEMENT THE SIGN OF THE FAC. (HERE THE FAC IS UNPACKED)
265 ; IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
266 ; FAC. SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
267 ; WILL BE THE SIGN OF THE FAC,
268 ORA H ;GET SUBTRACTION FLAG
269 LXI H,FACLO ;SET POINTER TO LO'S
270
271
272 JP FADD3 ;SUBTRACT IF THE SIGNS WERE DIFFERENT
273
274
275 CALL FADDA ;ADD THE NUMBERS
276
277
278 JNC ROUND ;ROUND RESULT IF THERE WAS NO OVERFLOW
279
280
281 ;THE MOST IT CAN OVERFLOW IS ONE BIT
282 INX H ;THERE WAS OVERFLOW
283 INR M ;INCREMENT EXPONENT
284 JZ OVERR ;CHECK FOR OVERFLOW
285
286
287 IFE LENGTH,<
288 CALL SHFTRO> ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
289 IFN LENGTH,<
290 MVI L,1 ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
291
292 CALL SHRADD>
293
294
295 JMP ROUND ;ROUND RESULT AND WE ARE DONE
296
297
298 ; HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
299 FADD3: XRA A ;SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
300 SUB 8
301 MOV B,A ;SAVE IT
302 MOV A,M ;SUBTRACT LOW ORDERS
303 SBB E
304 MOV E,A
305 INX H ;UPDATE POINTER TO NEXT BYTE
306 MOV A,M ;SUBTRACT MIDDLE ORDERS
307 SBB D
308 MOV D,A
309 INX H ;UPDATE POINTER TO HIGH ORDERS
310 MOV A,M ;SUBTRACT HIGH ORDERS
311 SBB C
312 MOV C,A
313 ; BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE
314 ; NUMBER
315 FADFLT: CC NEGR ;ENTRY FROM FLOATR, INT: NEGATE NUMBER IF IT
316
317
318 ;WAS NEGATIVE, FALL INTO NORMALIZE
319
320
321 ; NORMALIZE B,C,D,E
322 ; ALTERS A,B,C,D,E,M,L
323 ; HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
324 ; EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
325 ; POSSIBLE.
326 NORMAL:
327 IFE LENGTH,<
328 MVI H,0 ;CLEAR SHIFT COUNT
329 MOV A,C ;IS THE NUMBER NORMALIZED?
330 ORA A
331 JM ROUND ;YES, WE ARE DONE
332 NORM2: CPI 340 ;IS THE RESULT ZERO?
333 JZ ZERO ;YES, ZERO THE FAC
334 OCR H ;NO, DECREMENT SHIFT COUNT
335 MOV A,B ;SHIFT THE LO LEFT
336 ADD A ;SHIFT IN A ZERO
337 MOV B,A
338 CALL SHFTLO ;SHIFT THE REST OF THE NUMBER LEFT ONE
339 MOV A,H ;GET THE SHIFT COUNT
340 JP NORM2> ;CONTINUE IF NUMBER IS NOT NORMALIZED
341 IFN LENGTH,<
342 MOV L,B ;PUT LOWEST 2 BYTES IN (HL)
343 MOV H,E
344 XRA A ;ZERO SHIFT COUNT
345 NORM1: MOV B,A ;SAVE SHIFT COUNT
346 MOV A,C ;DO WE HAVE 1 BYTE OF ZEROS
347 ORA A
348 JNZ NORM3 ;NO, SHIFT ONE PLACE AT A TIME
349
350
351 ; THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
352 MOV C,D ;YES, SHIFT OVER 1 BYTE
353 MOV D,H
354 MOV H,L
355 MOV L,A ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
356 MOV A,B ;UPDATE SHIFT COUNT
357 SUI 10
358
359 CPI 340 ;DID WE SHIFT IN 4 BYTES OF ZEROS?
360
361 JNZ NORM1 ;NO, TRY TO SHIFT OVER 8 MORE
362
363
364 ;YES, NUMBER WAS ZERO. FALL INTO ZERO
365
366
367 ; ZERO FAC
368 ; ALTERS A ONLY
369 ; EXITS WITH A=0
370 ; BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS
371 ; ZERO
372 ZERO: XRA A ;ZERO A
373 ZERO0: STA FAC ;ZERO THE FAC'S EXPONENT, ENTRY IF A=0
374
375
376 RET ;ALL DONE
377
378
379 NORM2: OCR B ;DECREMENT SHIFT COUNT
380 DAD H ;ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
381 MOV A,D ;ROTATE NEXT HIGHER ORDER LEFT ONE
382 RAL
383 MOV D,A
384 MOV A,C ;ROTATE HIGH ORDER LEFT ONE
385 ADC A ;SET CONDITION CODES
386 MOV C,A
387 NORM3: JP NORM2 ;WE HAVE MORE NORMALIZATION TO DO
388
389
390 MOV A,B ;ALL NORMALIZED, GET SHIFT COUNT
391 MOV E,H ;PUT LO'S BACK IN E,B
392 MOV B,L
393 ORA A ;CHECK IF WE DID NO SHIFTING
394 JZ ROUND>
395
396
397 LXI H,FAC ;LOOK AT FAC'S EXPONENT
398
399
400 ADD M ;UPDATE EXPONENT
401 MOV M,A
402 JNC ZERO ;CHECK FOR UNDERFLOW
403
404
405 RZ ;NUMBER IS ZERO, ALL DONE
406 ;FALL INTO ROUND AND WE ARE DONE
407
408
409 ; ROUND RESULT IN B,C,D,E AND PUT NUMBER IN THE FAC
410 ; ALTERS B,C,D,E,H,L
411 ; WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
412 ROUND: MOV A,B ;SEE IF WE SHOULD ROUND UP
413 ROUNDB: LXI H,FAC ;ENTRY FROM FDIV, GET POINTER TO EXPONENT
414
415
416 ORA A
417 CM ROUNDA ;DO IT IF NECESSARY
418
419
420 MOV B,M ;PUT EXPONENT IN B
421 ; THERE WE PACK THE HO AND SIGN
422 INX H ;POINT TO SIGN
423 MOV A,M ;GET SIGN
424 ANI 200 ;GET RID OF UNWANTED BITS
425
426 XRA C ;PACK SIGN AND HO
427 MOV C,A ;SAVE IT IN C
428 JMP MOVFR ;SAVE NUMBER IN FAC
429
430
431
432
433 IFE LENGTH,<
434 ; SHIFT C,D,E LEFT ONE
435 ; THIS IS USED BY NORMAL, FDIV
436 ; ALTERS A,C,D,E
437 SHFTLO: MOV A,E ;GET THE LO
438 RAL ;SHIFT IT
439 MOV E,A ;SAVE IT
440 MOV A,D ;SHIFT THE NEXT HIGHER ORDER
441 RAL
442 MOV D,A
443 MOV A,C ;SHIFT THE HIGHEST ORDER
444 ADC A ;ROTATE A LEFT AND SET CONDITION CODES
445 MOV C,A
446 RET> ;ALL DONE
447
448
449 ; SUBROUTNE FOR ROUND: ADD ONE TO C,D,E
450 ROUNDA: INR E ;ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
451 RNZ ;ALL DONE IF IT IS NOT ZERO
452 INR D ;ADD ONE TO NEXT HIGHER ORDER
453 RNZ ;ALL DONE IF NO OVERFLOW
454 INR C ;ADD ONE TO THE HIGHEST ORDER
455 RNZ ;RETURN IF NO OVEFLOW
456 MVI C,200 ;THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
457
458 INR M ;UPDATE EXPONENT
459 RNZ ;RETURN IF IT DID NOT OVERFLOW
460 ;IT DID, FALL INTO OVERR
461
462 ;OVERFLOW ERROR
463 OVERR: MVI E,ERROV ;SET OVERFLOW ERROR CODE
464
465 JMP ERROR ;GO TO IT!!
466
467
468
469
470 ; ADD (HL)+2,1,0 TO C,D,E
471 ; THIS CODE IS USED BY FADD, FOUT
472 FADDA: MOV A,M ;GET LOWEST ORDER
473 ADD E ;ADD IN OTHER LOWEST ORDER
474 MOV E,A ;SAVE IT
475 INX H ;UPDATE POINTER TO NEXT BYTE
476 MOV A,M ;ADD MIDDLE ORDERS
477 ADC D
478 MOV D,A
479 INX H ;UPDATE POINTER TO HIGH ORDER
480 MOV A,M ;ADD HIGH ORDERS
481 ADC C
482 MOV C,A
483 RET ;ALL DONE
484
485
486 ; NEGATE NUMBER IN B,C,D,E
487 ; THIS CODE IS USED BY FADD, QINT
488 ; ALTERS A,B,C,D,E,L
489 NEGR: LXI H,FAC+1 ;NEGATE FAC
490
491
492 MOV A,M ;GET SIGN
493 CMA ;COMPLEMENT IT
494 MOV M,A ;SAVE IT AGAIN
495 XRA ;ZERO A
496 MOV L,A ;SAVE ZERO IN L
497 SUB B ;NEGATE LOWEST ORDER
498 MOV B,A ;SAVE IT
499 MOV A,L ;GET A ZERO
500 SBB E ;NEGATE NEXT HIGHEST ORDER
501 MOV E,A ;SAVE IT
502 MOV A,L ;GET A ZERO
503 SBB D ;NEGATE NEXT HIGHEST ORDER
504 MOV D,A ;SAVE IT
505 MOV A,L ;GET ZERO BACK
506 SBB C ;NEGATE HIGHEST ORDER
507 MOV C,A ;SAVE IT
508 RET ;ALL DONE
509
510
511 ; SHIFT C,D,E RIGHT
512 ; A = SHIFT COUNT
513 ; ALTERS A,B,C,D,E,L
514 ; THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES AS MANY TIMES AS
515 ; POSSIBLE
516 SHIFTR: MVI B,0 ;ZERO OVERFLOW BYTE
517
518 IFE LENGTH,<
519 INR A> ;ADD ONE TO SHIFT COUNT
520 IFN LENGTH,<
521 SHFTR1: SUI 10 ;CAN WE SHIFT IT 8 RIGHT?
522
523 JC SHFTR2 ;NO, SHIFT IT ONE PLACE AT A TIME
524
525
526 ; THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
527 MOV B,E ;SHIFT NUMBER 1 BYTE RIGHT
528 MOV E,D
529 MOV D,C
530 MVI C,0 ;PUT 0 IN HO
531
532 JMP SHFTR1 ;TRY TO SHIFT 8 RIGHT AGAIN
533
534
535 SHFTR2: ADI 11> ;CORRECT SHIFT COUNT
536
537 MOV L,A ;SAVE SHIFT COUNT
538 SHFTR3: XRA A ;CLEAR CARRY
539 DCR L ;ARE WE DONE SHIFTING?
540 RZ ;RETURN IF WE ARE
541 IFE LENGTH,<
542 SHRADD: CALL SHFTRO> ;SHIFT THE NUMBER RIGHT ONE
543 IFN LENGTH,<
544 MOV A,C ;GET HO
545 SHRADD: RAR ;ENTRY FROM FADD, SHIFT IT RIGHT
546 MOV C,A ;SAVE IT
547 MOV A,D ;SHIFT NEXT BYTE RIGHT
548 RAR
549 MOV D,A
550 MOV A,E ;SHIFT LOW ORDER RIGHT
551 RAR
552 MOV E,A
553 MOV A,B ;SHIFT OVERFLOW BYTE RIGHT
554 RAR
555 MOV B,A>
556 JMP SHFTR3 ;SEE IF WE ARE DONE
557
558
559
560
561 IFE LENGTH,<
562 ; SHIFT B,C,D,E RIGHT ONE
563 ; THIS IS USED BY SHIFTR, FMULT, FADD
564 ; ALTERS A,B,C,D,E
565 SHFTRO: MOV A,C ;GET THE HO
566 SHFROA: RAR ;SHIFT IT RIGHT, ENTRY FROM FMULT
567 MOV C,A
568 MOV A,D ;SHIFT THE MO RIGHT
569 RAR
570 MOV D,A
571 MOV A,E ;SHIFT THE LO
572 RAR
573 MOV E,A
574 MOV A,B ;SHIFT THE EXTRA LO BYTE
575 RAR
576 MOV B,A
577 RET> ;ALL DONE
578 PAGE
579 SUBTTL NATURAL LOG FUNCTION
580 IFN EXTFNC,<
581 ; CALCULATION IS BY:
582 ;   LN(F*2*N)=(N+LOG2(F))*LN(2)
583 ; AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
584
585 ; CONSTANTS USED BY LOG
586 FONE: 000 ;1
587 000
588 000
589 201
590 LOGCN2: 3 ;DEGREE+1
591 252 ;0.598978650
592 126
593 031
594 200
595 361 ;0.961470632
596 042
597 166
598 200
599 105 ;2,88539129
600 252 ;NOTE: THE REFERENCE FOR THIS CONSTANT HAS 100 NOT 105
601 070 ;IN THE LOW ORDER BYTE.
602 202
603
604 LOG: FSIGN ;CHECK FOR A NEGATIVE OR ZERO ARGUMENT
605 JPE FCERR ;FAC .LE. 0, BLOW HIM OUT OF THE WATER
606
607
608 ;FSIGN ONLY RETURNS 0,1 OR 377 IN A
609 ;THE PARITY WILL BE EVEN IF A HAS 0 OR 377
610 LXI H,FAC ;GET POINTER TO EXPONENT
611
612
613 MOV A,M ;GET EXPONENT IN A
614 MOVRI 200,065,004,363 ;GET SQR(.5)
615
616
617
618
619
620 SUB B ;REMOVE EXCESS 200
621 PUSH PSW ;SAVE EXPONENT FOR LATER
622 MOV M,B ;SET EXP TO 200, RESULT IS NUM IN (.5,1)
623 PUSHR ;SAVE SQR(.5)
624
625 CALL FADD ;CALCULATE (F-SQR(.5))/(F+SQR(.5))
626
627
628 POPR ;GET SQR(.5) BACK
629
630 INR 8 ;GET SQR(2)
631 CALL FDIV ;WHERE F=NUMBER LEFT IN FAC
632
633
634 LXI H,FONE ;THE CALCULATION IS EQUIVALENT TO THE ABOVE,
635
636
637 CALL FSUBS ;BUT DONE IN A DIFFERENT ORDER
638
639
640 LXI H,LOGCN2 ;EVALUATE APPROXIMATION POLYNOMIAL
641
642
643 CALL POLYX
644
645
646 MOVRI 200,200,000,000 ;GET -1/2
647
648
649
650
651
652 CALL FADD ;ADD IN LAST CONSTANT
653
654
655 POP PSW ;RETRIEVE ORIGINAL EXPONENT
656 CALL FINLOG ;ADD IT TO ORIGINAL NUMBER
657
658
659 MULLN2: MOVRI 260,061,162,030> ;GET LN(2)
660
661
662
663
664
665 ; JMP FMULT ;MULTIPLY BY LN(2)
666 PAGE
667 SUBTTL FLOATING MULTIPLICATION AND DIVISION
668 ;MULTIPLICATION FAC:=ARG*FAC
669 ;ALTERS A,B,C,D,E,H,L
670 IFE EXTFNC,<
671 FMULTS: CALL MOVRM> ;ENTRY WITH POINTER TO ARG IN (HL)
672 IFN LENGTH-2,<
673 XWD 1000,041 ;"LXI H" AROUND NEXT 2 BYTES
674 FMULTT: POPR> ;ENTRY IF ARGUMENT IS ON THE STACK
675
676 FMULT: FSIGN ;CHECK IF FAC IS ZERO
677 RZ ;IF IT IS, RESULT IS ZERO
678 MVI L,0 ;ADD THE TWO EXPONENTS, L IS A FLAG
679
680 CALL MULDIV ;FIX UP THE EXPONENTS
681
682
683 ;SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
684 MOV A,C ;GET HO
685 STA FMULTA+1 ;STORE HO OF REGISTERS
686
687
688 XCHG ;STORE THE TWO LO'S OF THE REGISTERS
689 SHLD FMULTB+1
690
691
692 LXI B,$CODE ;ZERO THE PRODUCT REGISTERS
693
694
695 MOV D,B
696 MOV E,B
697 LXI H,NORMAL ;PUT ADDRESS OF NORMAL, WERE WE FINISH UP,
698
699
700 PUSH H ;ON THE STACK
701 LXI H,FMULT2 ;PUT FMULT2 ON THE STACK TWICE, SO AFTER
702
703
704 PUSH H ;WE MULTIPLY BY THE LO BYTE, WE WILL
705 PUSH H ;MULTIPLY BY THE MO AND HO
706 LXI H,FACLO ;GET ADDRESS OF LO OF FAC
707
708
709 FMULT2: MOV A,M ;GET BYTE TO MULTIPLY BY
710 INX H ;MOVE POINTER TO NEXT BYTE
711 IFN LENGTH,<
712 ORA A
713 JZ FMULT3> ;ARE WE MULTIPLYING BY ZERO?
714
715
716 PUSH H ;SAVE POINTER
717 IFE LENGTH,<
718 MVI L,10> ;SET UP A COUNT
719 IFN LENGTH,<
720 XCHG ;GET LO'S IN (HL)
721 MVI E,10> ;SET UP A COUNT
722
723
724 ; THE PRODUCT WILL BE FORMED IN C,D,E,B, THIS WILL BE IN C,H,L,B PART OF THE
725 ; TIME IN ORDER TO USE THE "DAD" INSTRUCTION, AT FMULT2, WE GET THE NEXT
726 ; BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY, ((HL) POINTS TO IT)
727 ; (THE FMULT2 SUBROUTINE PRESERVES (HL)) IN 8K, IF THE BYTE IS ZERO, WE JUST
728 ; SHIFT THE PRODUCT 8 RIGHT. THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
729 ; CH IN 4K), THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
730 ; IF WE DO, WE ADD IT TO C,H,L. B IS ONLY USED TO DETERMINE WHICH WAY WE
731 ; ROUND. WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
732 ; NEXT TIME THROUGH THE LOOP. NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
733 ; C. E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
734 ; OF D (H IN 4K).
735 FMULT4: RAR ;ROTATE BYTE RIGHT
736 IFE LENGTH,<
737 MOV H,A> ;SAVE THE COUNT
738 IFN LENGTH,<
739 MOV D,A> ;SAVE IT
740 MOV A,C ;GET HO
741 JNC FMULT5 ;DON'T ADD IN NUMBER IF BIT WAS ZERO
742
743
744 IFE LENGTH,<
745 XCHG> ;PUT THE LO'S IN (HL)
746 PUSH D ;SAVE COUNTERS
747 FMULTB: LXI D,$CODE ;GET LO'S OF NUMBER TO ADD, THIS IS SET ABOVE
748
749
750 DAD D ;ADD THEM IN
751 POP D ;GET COUNTERS BACK
752 FMULTA: ACI 0 ;ADD IN HO, THIS IS SET UP ABOVE
753
754 IFE LENGTH,<
755 XCHG ;PUT THE LO'S BACK IN (DE)
756 FMULT5: CALL SHFROA ;SHIFT THE RESULT RIGHT ONE
757 OCR L ;ARE WE DONE?
758 MOV A,H> ;GET NUMBER WE ARE MULTIPLYING BY
759 IFN LENGTH,<
760 FMULT5: RAR ;ROTATE RESULT RIGHT ONE
761 MOV C,A
762 MOV A,H ;ROTATE NEXT BYTE
763 RAR
764 MOV H,A
765 MOV A,L ;ROTATE NEXT LOWER ORDER
766 RAR
767 MOV L,A
768 MOV A,B ;ROTATE LO
769 RAR
770 MOV B,A
771 DCR E ;ARE WE DONE?
772 MOV A,D> ;GET NUMBER WE ARE MULTIPLYING BY
773 JNZ FMULT4 ;MULTIPLY AGAIN IF WE ARE NOT DONE
774
775
776 IFN LENGTH,<
777 XCHG> ;GET LO'S IN (HL)
778 POPHRT: POP H ;GET POINTER TO NUMBER TO MULTIPLY BY
779 RET ;ALL DONE
780 IFN LENGTH,<
781 FMULT3: MOV B,E ;MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
782 MOV E,D
783 MOV D,C
784 MOV C,A ;SHIFT IN 8 ZEROS ON THE LEFT
785 RET> ;ALL DONE
786
787
788 ; DIVIDE FAC BY 10
789 ; ALTERS A,B,C,D,E,M,L
790 DIV10: CALL PUSHF ;SAVE NUMBER
791
792
793 IFN LENGTH-2,<
794 MOVRI 204,040,000,000 ;LOAD CONSTANT '10' INTO REGISTERS
795
796
797
798
799
800 CALL MOVFR> ;MOVE THE CONSTANT TO THE FAC
801
802
803 IFE LENGTH-2,<
804 LXI H,FTEN ;GET POINTER TO THE CONSTANT '10'
805 CALL MOVFM> ;MOVE TEN INTO THE FAC
806 FDIVT: POPR ;GET NUMBER BACK IN REGISTERS
807
808 ;FALL INTO DIVIDE AND WE ARE DONE
809
810
811 ;DIVISION FAC:=ARG/FAC
812 ;ALTERS A,B,C,D,E,M,L
813 FDIV: FSIGN ;CHECK FOR DIVISION BY ZERO
814 JZ DV0ERR ;HE IS TRYING TO GET AWAY WITH IT
815
816
817 MVI L,377 ;SUBTRACT THE TWO EXPONENTS, L IS A FLAG
818
819 CALL MULDIV ;FIX UP THE EXPONENTS AND THINGS
820
821
822 INR M ;ADD 2 TO EXPONENT TO CORRECT SCALING
823 INR M
824 ;HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
825 ;IN THE REGISTERS QUICKLY.
826 DCX H ;POINT TO HO
827 MOV A,M ;GET HO
828 STA FDIVA+1 ;SAVE IT
829
830
831 DCX H ;SAVE MIDDLE ORDER
832 MOV A,M
833 STA FDIVB+1 ;PUT IT WHERE NOTHING WILL HURT IT
834
835
836 DCX H ;SAVE LO
837 MOV A,M
838 STA FDIVC+1
839
840
841
842 ; THE NUMERATOR WILL BE KEPT IN B,H,L. THE QUOTIENT WILL BE FORMED IN C,D,E.
843 ; TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
844 ; SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY. THE CARRY INDICATES
845 ; WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR. IF B,H,L WAS BIGGER,
846 ; THE NEXT BIT OF THE QUOTIENT IS A ONE. TO GET THE OLD B,H,L OFF THE STACK,
847 ; WE POP THEM INTO THE PSW, IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
848 ; THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
849 ; STACK. WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
850 ; DENOMINATOR WAS BIGGER, THEN B,H,L WILL GET SHIFTED LEFT. IF THE MSB OF
851 ; B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1, THEN
852 ; THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
853 ; EXTRA HO BIT IN FOIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
854 ; THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT. WHEN WE JUMP
855 ; TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
856 ; IT IS IN THE MSB OF A. IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
857 ; NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO, THIS MEANS WE
858 ; WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
859 ; AFTER THE FIRST NON-ZERO BIT OF THE EXPONENT. SO, THIS QUOTIENT WILL LOOK
860 ; SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
861 ; BIGGER, THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
862 ; ARE ALL ZERO. SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
863 ; MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
864 MOV B,C ;GET NUMBER IN B,H,L
865 XCHG
866 XRA A ;ZERO C,D,E AND HIGHEST ORDER
867 MOV C,A
868 MOV D,A
869 MOV E,A
870 STA FDIVG+1
871
872
873 FDIV1: PUSH H ;SAVE LO'S OF NUMBER
874 PUSH B ;SAVE HO OF NUMBER
875 MOV A,L ;SUBTRACT NUMBER THAT WAS IN FAC
876 FDIVC: SUI 0 ;SUBTRACT LO
877
878 MOV L,A ;SAVE IT
879 MOV A,H ;SUBTRACT MIDDLE ORDER
880 FDIVB: SBI 0
881
882 MOV H,A
883 MOV A,B ;SUBTRACT HO
884 FDIVA: SBI 0
885
886 MOV B,A
887 FDIVG: MVI A,0 ;GET HIGHEST ORDER
888
889 SBI 0 ;SUBTRACT THE CARRY FROM IT
890
891 CMC ;SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
892 JNC FDIV2 ;GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
893
894
895 STA FDIVG+1 ;UPDATE HIGHEST ORDER
896
897
898 POP PSW ;THE SUBTRACTION WAS GOOD
899 POP PSW ;GET PREVIOUS NUMBER OFF STACK
900 STC ;NEXT BIT IN QUOTIENT IS A ONE
901 XWD 1000,322 ;"JNC" AROUND NEXT 2 BYTES
902 FDIV2: POP B ;WE SUBTRACTED TOO MUCH
903 POP H ;GET OLD NUMBER BACK
904 MOV A,C ;ARE WE DONE?
905 INR A ;SET SIGN FLAG WITHOUT AFFECTING CARRY
906 DCR A
907 RAR ;PUT CARRY IN MSB
908 JM ROUNDB ;WE ARE DONE
909
910
911 RAL ;WE AREN'T, GET OLD CARRY BACK
912 IFE LENGTH,<
913 CALL SHFTLO> ;ROTATE EVERYTHING LEFT ONE
914 IFN LENGTH,<
915 MOV A,E ;ROTATE EVERYTHING LEFT ONE
916 RAL ;ROTATE NEXT BIT OF QUOTIENT IN
917 MOV E,A
918 MQV A,D
919 RAL
920 MOV D,A
921 MOV A,C
922 RAL
923 MOV C,A>
924 DAD H ;ROTATE A ZERO INTO RIGHT END OF NUMBER
925 MOV A,B ;THE HO BYTE, FINALLY!
926 RAL
927 MOV B,A
928 LDA FDIVG+1 ;ROTATE THE HIGHEST ORDER
929
930
931 RAL
932 STA FDIVG+1
933
934
935 MOV A,C ;ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
936 ORA D ;DID NOT WORK
937 ORA E
938 JNZ FDIV1 ;THIS ISN'T THE CASE
939
940
941 PUSH H ;SAVE PART OF NUMBER
942 LXI H,FAC ;GET POINTER TO FAC
943
944
945 DCR M ;DECREMENT EXPONENT
946 POP H ;GET NUMBER BACK
947 JNZ FDIV1 ;DIVIDE MORE IF NO OVERFLOW OCCURED
948
949
950 JMP OVERR ;OVERFLOW!!
951
952
953
954
955 ; CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
956 ; ALTERS A,B,H,L
957 IFE LENGTH-2,<
958 MULDVS: MVI A,377 ;ENTRY FROM DDIV, SUBTRACT EXPONENTS
959 XWD 1000,056 ;"MVI L" AROUND NEXT BYTE
960 MULDVA: XRA A ;ENTRY FROM DMULT, ADD EXPONENTS
961 LXI H,ARG-1 ;GET POINTER TO SIGN AND HO OF ARG
962 MOV C,M ;GET HO AND SIGN FOR UNPACKING
963 INX H ;INCREMENT POINTER TO EXPONENT
964 MOV B,M ;GET EXPONENT FOR BELOW
965 MOV L,A> ;SAVE ADD OR SUBTRACT FLAG
966 MULDIV: MOV A,B ;IS NUMBER IN REGISTERS ZERO?
967 ORA A
968 JZ MULDV2 ;IT IS, ZERO FAC AND WE ARE DONE
969
970
971 MOV A,L ;GET ADD OR SUBTRACT FLAG
972 LXI H,FAC ;GET POINTER TO EXPONENT
973
974
975 XRA M ;GET EXPONENT
976 ADD 8 ;ADD IN REGISTER EXPONENT
977 MOV B,A ;SAVE IT
978 RAR ;CHECK FOR OVERFLOW
979 XRA B ;OVERFLOW IF SIGN IS THE SAME AS CARRY
980 MOV A,B ;GET SUM
981 JP MULDV1 ;WE HAVE OVERFLOW!!
982
983
984 ADI 200 ;PUT EXPONENT IN EXCESS 200
985
986 MOV M,A ;SAVE IT IN THE FAC
987 JZ POPHRT ;WE HAVE UNDEFLOW!! RETURN,
988
989
990 CALL UNPACK ;UNPACK THE ARGUMENTS
991
992
993 MOV M,A ;SAVE THE NEW SIGN
994 DCX H ;POINT TO EXPONENT
995 RET ;ALL DONE, LEAVE HO IN A
996 IFN EXTFNC,<
997 MLDVEX: FSIGN ;ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
998 CMA ;PICK OVERFLOW IF POSITIVE
999 POP H> ;DON'T SCREW UP STACK
1000 MULDV1: ORA A ;IS ERROR OVERFLOW OR UNDEFLOW?
1001 MULDV2: POP H ;GET OLD RETURN ADDRESS OFF STACK
1002 IFE LENGTH,<
1003 JM OVERR ;OVERFLOW
1004 ;UNDERFLOW -- FALL INTO ZERO
1005
1006
1007 ; ZERO FAC
1008 ; ALTERS A ONLY
1009 ; EXITS WITH A=0
1010 ZERO: XRA A ;ZERO A
1011 STA FAC ;ZERO FAC
1012 RET> ;ALL DONE
1013
1014
1015 IFN LENGTH,<
1016 JP ZERO ;UNDERFLOW
1017
1018
1019 JMP OVERR> ;OVERFLOW
1020
1021
1022
1023
1024 ; MULTIPLY FAC BY 10
1025 ; ALTERS A,B,C,D,E,M,L
1026 MUL10: CALL MOVRF ;GET NUMBER IN REGISTERS
1027
1028
1029 MOV A,B ;GET EXPONENT
1030 ORA A ;RESULT IS ZERO IF ARG IS ZERO
1031 RZ ;IT IS
1032 ADI 2 ;MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
1033
1034 JC OVERR ;OVERFLOW!!
1035
1036
1037 MOV B,A ;RESTORE EXPONENT
1038 CALL FADD ;ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
1039
1040
1041 LXI H,FAC ;ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
1042
1043
1044 INR M ;2 TO GET 10 TIMES ORIGINAL NUMBER
1045 RNZ ;ALL DONE IF NO OVERFLOW
1046 JMP OVERR ;OVERFLOW!!
1047
1048
1049 PAGE
1050 SUBTTL SIGN, SGN, FLOAT, NEG AND ABS
1051 ; PUT SIGN OF FAC IN A
1052 ; ALTERS A ONLY
1053 ; LEAVES FAC ALONE
1054 ; NOTE: TO TAKE ADVANTAGE OF THE RST INSTRUCTIONS TO SAVE BYTES,
1055 ; FSIGN IS DEFINED TO BE AN RST. "FSIGN" IS EQUIVALENT TO "CALL SIGN"
1056 ; THE FIRST FEW INSTRUCTIONS OF SIGN (THE ONES BEFORE SIGNC) ARE DONE
1057 ; IN THE 8 BYTES AT THE RST LOCATION.
1058 REPEAT 0,< ;FSIGN IS ALWAYS AN RST
1059 SIGN: LDA FAC ;CHECK IF THE NUMBER IS ZERO
1060 ORA A
1061 RZ> ;IT IS, A IS ZERO
1062 SIGNC: LDA FAC-1 ;GET SIGN OF FAC, IT IS NON-ZERO
1063
1064
1065 XWD 1000,376 ;"CPI" AROUND NEXT BYTE
1066 FCOMPS: CMA ;ENTRY FROM FCOMP, COMPLEMENT SIGN
1067 ICOMPS: RAL ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
1068 SIGNS: SBB A ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
1069 RNZ ;RETURN IF NUMBER WAS NEGATIVE
1070 INRART: INR A ;PUT ONE IN A IF NUMBER WAS POSITIVE
1071 RET ;ALL DONE
1072
1073
1074 ; SGN FUNCTION
1075 ; ALTERS A,B,C,D,E,H,L
1076 IFN LENGTH-2,<
1077 SGN: FSIGN> ;GET SIGN OF FAC IN A
1078 ;FALL INTO FLOAT
1079
1080
1081 ; FLOAT THE SIGNED INTEGER IN A
1082 ; ALTERS A,B,C,D,E,H,L
1083 FLOAT: MVI B,210 ;SET EXPONENT CORRECTLY
1084
1085 LXI D,$CODE ;ZERO D,E
1086
1087
1088 ;FALL INTO FLOATR
1089
1090
1091 ; FLOAT THE SIGNED NUMBER IN A,B,D,E
1092 ; ALTERS A,B,C,D,E,H,L
1093 FLOATR: LXI H,FAC ;GET POINTER TO FAC
1094
1095
1096 MOV C,A ;PUT HO IN C
1097 MOV M,B ;PUT EXPONENT IN THE FAC
1098 MVI B,0 ;ZERO OVERFLOW BYTE
1099
1100 INX H ;POINT TO SIGN
1101 MVI M,200 ;ASSUME A POSITIVE NUMBER
1102
1103 RAL ;PUT SIGN IN CARRY
1104 JMP FADFLT ;GO AND FLOAT THE NUMBER
1105
1106
1107
1108
1109 ; ABSOLUTE VALUE OF FAC
1110 ; ALTERS A,H,L
1111 ABS:
1112 IFE LENGTH-2,<
1113 CPI 2 ;IS THE ARGUMENT AN INTEGER?
1114 JZ IABS> ;YES, USE THE INTEGER ABSOLUTE VALUE
1115 FSIGN ;GET THE SIGN OF FAC
1116 RP ;ALL DONE IF IT IS POSITIVE
1117 ;FALL INTO NEG
1118
1119
1120 ; NEGATE NUMBER IN THE FAC
1121 ; ALTERS A,H,L
1122 ; NOTE: THE NUMBER MUST BE PACKED
1123 NEG: LXI H,FAC-1 ;GET POINTER TO SIGN
1124
1125
1126 MOV A,M ;GET SIGN
1127 XRI 200 ;COMPLEMENT SIGN BIT
1128
1129 MOV M,A ;SAVE IT
1130 RET ;ALL DONE
1131
1132
1133 IFE LENGTH-2,<
1134 ; NEGATE ANY TYPE VALUE IN THE FAC
1135 ; ALTERS A,B,C,D,E,H,L
1136 VNEG: LDA VALTYP ;SEE WHAT KIND OF NUMBER WE HAVE
1137 CPI 2
1138 JZ INEG ;WE HAVE AN INTEGER, NEGATE IT THAT WAY
1139 JM TMERR ;BLOW UP ON STRINGS
1140 JMP NEG ;NEGATE SNG AND DBL THE SAME
1141
1142
1143 ; SGN FUNCTION
1144 ; ALTERS A,H,L
1145 SGN: CALL VSIGN ;GET THE SIGN OF THE FAC IN A
1146 MOV L,A ;PUT IT IN THE LO POSITION
1147 RAL ;EXTEND THE SIGN TO THE HO
1148 SBB A
1149 MOV H,A
1150 JMP CONISS ;RETURN THE RESULT AND SET VALTYP
1151
1152
1153 ; GET THE SIGN OF THE VALUE IN THE FAC IN A
1154 ; ASSUMES A HAS THE VALTYP WHEN CALLED
1155 ; ALTERS A,H,L
1156 VSIGN: CPI 2 ;IS THE ARGUMENT AN INTEGER?
1157 JNZ SIGN ;NO, SINGLE AND DOUBLE PREC. WORK THE SAME
1158 LHLD FACLO ;GET THE INTEGER ARGUMENT
1159 MOV A,H ;GET ITS SIGN
1160 ORA L ;CHECK IF THE NUMBER IS ZERO
1161 RZ ;IT IS, WE ARE DONE
1162 MOV A,H ;IT ISN'T, SIGN IS THE SIGN OF H
1163 JMP ICOMPS> ;GO SET A CORRECTLY
1164 PAGE
1165 SUBTTL FLOATING POINT MOVEMENT ROUTINES
1166 ; PUT FAC ON STACK
1167 ; ALTERS D,E
1168 PUSHF: XCHG ;SAVE (HL)
1169 LHLD FACLO ;GET LO'S
1170
1171
1172 XTHL ;SWITCH LO'S AND RET ADDR
1173 PUSH H ;PUT RET ADDR BACK ON STACK
1174 LHLD FAC-1 ;GET HO'S
1175
1176
1177 XTHL ;SWITCH HO'S AND RET ADDR
1178 PUSH H ;PUT RET ADDR BACK ON STACK
1179 XCHG ;GET OLD (HL) BACK
1180 RET ;ALL DONE
1181
1182
1183 ; MOVE NUMBER FROM MEMORY (CHL)) TO FAC
1184 ; ALTERS B,C,D,E,H,L
1185 ; AT EXIT NUMBER IS IN B,C,D,E
1186 ; AT EXIT (HL):=(HL)+4
1187 MOVFM: CALL MOVRM ;GET NUMBER IN REGISTERS
1188
1189
1190 ;FALL INTO MOVFR AND PUT IT IN FAC
1191
1192
1193 ; MOVE REGISTERS (B,C,D,E) TO FAC
1194 ; ALTERS D,E
1195 MOVFR: XCHG ;GET LO'S IN (HL)
1196 SHLD FACLO ;PUT THEM WHERE THEY BELONG
1197
1198
1199 MOV H,B ;GET HO'S IN (HL)
1200 MOV L,C
1201 SHLO FAC-1 ;PUT HO'S WHERE THEY BELONG
1202
1203
1204 XCHG ;GET OLD (HL) BACK
1205 RET ;ALL DONE
1206
1207
1208 ; MOVE FAC TO REGISTERS (B,C,D,E)
1209 ; ALTERS B,C,D,E,H,L
1210 MOVRF: LXI H,FACLO ;GET POINTER TO FAC
1211
1212
1213 ;FALL INTO MOVRM
1214
1215
1216 ; GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
1217 ; ALTERS B,C,D,E,H,L
1218 ; AT EXIT (HL):=(HL)+4
1219 MOVRM: MOV E,M ;GET LO
1220 INX H ;POINT TO MO
1221 MOV D,M ;GET MO
1222 INX H ;POINT TO HO
1223 MOV C,M ;GET HO
1224 INX H ;POINT TO EXPONENT
1225 MOV B,M ;GET EXPONENT
1226 INXHRT: INX H ;INC POINTER TO BEGINNING OF NEXT NUMBER
1227 RET ;ALL DONE
1228
1229
1230 ; MOVE NUMBER FROM FAC TO MEMORY [(HL)]
1231 ; ALTERS A,B,D,E,H,L
1232 MOVMF: LXI D,FACLO ;GET POINTER TO FAC
1233
1234
1235 ;FALL INTO MOVE
1236
1237
1238 ; MOVE NUMBER FROM (DE) TO (HL)
1239 ; ALTERS A,B,D,E,H,L
1240 ; EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
1241 MOVE: MVI B,4 ;SET COUNTER
1242
1243 IFE LENGTH-2,<
1244 XWD 1000,076 ;"MVI A" OVER NEXT BYTE
1245 MOVVFM: XCHG> ;MOVE NUMBERS INTO THE FAC
1246 MOVE1: LOAX D ;GET WORD, ENTRY FROM VMOVMF
1247 MOV M,A ;PUT IT WHERE IT BELONGS
1248 INX D ;INCREMENT POINTERS TO NEXT WORD
1249 INX H
1250 DCR B ;SEE IF DONE
1251 JNZ MOVE1
1252
1253
1254 RET
1255
1256
1257 ; UNPACK THE FAC AND THE REGISTERS
1258 ; ALTERS A,C,H,L
1259 ; WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
1260 ; MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
1261 ; IN FAC+1
1262 UNPACK: LXI H,FAC-1 ;POINT TO HD AND SIGN
1263
1264
1265 MOV A,M ;GET HO AND SIGN
1266 PUSH PSW ;SAVE SIGN
1267 ORI 200 ;RESTORE THE HIDDEN ONE
1268
1269 MOV M,A ;SAVE HO
1270 POP PSW ;GET SIGN
1271 XRA M ;GET COMPLEMENT OF SIGN IN MSB
1272 INX H ;POINT TO TEMPORARY SIGN BYTE
1273 INX H
1274 MOV M,A ;SAVE COMPLEMENT OF SIGN
1275 MOV A,C ;GET HO AND SIGN OF THE REGISTERS
1276 PUSH PSW ;SAVE SIGN
1277 ORI 200 ;RESTORE THE HIDDEN ONE
1278
1279 MOV C,A ;SAVE THE HO
1280 POP PSW ;GET THE SIGN BACK
1281 XRA M ;COMPARE SIGN OF FAC AND SIGN OF REGISTERS
1282 RET ;ALL DONE
1283
1284
1285 IFE LENGTH-2,<
1286 REPEAT 0,< ;VPUSHF WILL BE IN-LINE IN F3
1287 ; PUT ANY TYPE VALUE ON THE STACK FROM THE FAC
1288 ; STRINGS ARE TREATED AS INTEGERS
1289 ; ALTERS A,B,C,H,L
1290 VPUSHF: LDA VALTYP ;GET THE VALUE TYPE
1291 CPI 4 ;SET FLAGS ACCORDING TO VALTYP
1292 LXI H,FACLO ;GET POINTER TO LO IN FAC
1293 PUSHM ;PUSH FACLO+0,1 ON THE STACK
1294 JM VPUSHD ;RETURN IF THE DATA WAS AN INTEGER OR A STRING
1295 PUSHM ;PUSH FAC-1,0 ON THE STACK
1296 JZ VPUSHD ;RETURN IF WE HAD A SINGLE PRECISION NUMBER
1297 LXI D,FACLO ;WE HAVE A DOUBLE PRECISON NUMBER
1298 PUSHM ;PUSH ITS 4 LO BYTES ON THE STACK
1299 PUSHM
1300 VPUSHD:> ;ALL DONE
1301
1302
1303 ; MOVE ANY TYPE VALUE FROM MEMORY [(HL)] TO FAC
1304 ; ALTERS A,B,D,E,H,L
1305 VMOVFA: LXI H,ARGLO ;ENTRY FROM DADD, MOVE ARG TO FAC
1306 VMOVFM: LXI D,MOVVFM ;GET ADDRESS OF LOCATION THAT DOES
1307 JMP VMVVFM ;AN "XCHG" AND FALLS INTO MOVE1
1308
1309
1310 ; MOVE ANY TYPE VALUE FROM FAC TO MEMORY [(HL))
1311 ; ALTERS A,B,D,E,H,L
1312 VMOVAF: LXI H,ARGLO ;ENTRY FROM FIN, DMUL10, DDIV10
1313 ;MOVE FAC TO ARG
1314 VMOVMF: LXI D,MOVE1 ;GET ADDRESS OF MOVE SUBROUTINE
1315 VMVVFM: PUSH D ;SHOVE IT ON THE STACK
1316 LXI D,FACLO ;GET FIRST ADDRESS FOR INT, SNG
1317 LOA VALTYP ;GET THE VALUE TYPE
1318 ANI 177 ;STRINGS LOOK LIKE REALS
1319 MOV B,A ;SET UP THE COUNT
1320 CPI 10 ;DO WE HAVE DBL?
1321 RNZ ;WE DO NOT, GO DO THE MOVE
1322 LXI D,DFACLO ;WE DO, GET LO ADDR OF THE DBL NUMBER
1323 RET> ;GO DO THE MOVE
1324 PAGE
1325 SUBTTL COMPARE TWO NUMBERS
1326 ; COMPARE TWO SINGLE PRECISION NUMBERS
1327 ; A=1 IF ARG .LT. FAC
1328 ; A=0 IF ARG=FAC
1329 ; A==1 IF ARG .GT. FAC
1330 ; DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS WITH CARRY ON
1331 ; IFF A HAS 377
1332 ; ALTERS A,H,L
1333 FCOMP: MOV A,B ;CHECK IF ARG IS ZERO
1334 ORA A
1335 JZ SIGN
1336
1337
1338 LXI H,FCOMPS ;WE JUMP TO FCOMPS WHEN WE ARE DONE
1339
1340
1341 PUSH H ;PUT THE ADDRESS ON THE STACK
1342 FSIGN ;CHECK IF FAC IS ZERO
1343 MOV A,C ;IF IT IS, RESULT IS MINUS THE SIGN OF ARG
1344 RZ ;IT IS
1345 LXI H,FAC-1 ;POINT TO SIGN OF FAC
1346
1347
1348 XRA M ;SEE IF THE SIGNS ARE THE SAME
1349 MOV A,C ;IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
1350 RM ;THEY ARE DIFFERENT
1351 CALL FCOMP2 ;CHECK THE REST OF THE NUMBER
1352
1353
1354 FCOMPD: RAR ;NUMBERS ARE DIFFERENT, CHANGE SIGN IF
1355 XRA C ;BOTH NUMBERS ARE NEGATIVE
1356 RET ;GO SET UP A
1357
1358 FCOMP2: INX H ;POINT TO EXPONENT
1359 MOV A,B ;GET EXPONENT OF ARG
1360 CMP M ;COMPARE THE TWO
1361 RNZ ;NUMBERS ARE DIFFERENT
1362 DCX H ;POINT TO HO
1363 MOV A,C ;GET HO OF ARG
1364 CMP M ;COMPARE WITH HO OF FAC
1365 RNZ ;THEY ARE DIFFERENT
1366 DCX M ;POINT TO MO OF FAC
1367 MOV A,D ;GET MO OF ARG
1368 CMP M ;COMPARE WITH MO OF FAC
1369 RNZ ;THE NUMBERS ARE DIFFERENT
1370 DCX H ;POINT TO LO OF FAC
1371 MOV A,E ;GET LO OF ARG
1372 SUB M ;SUBTRACT LO OF FAC
1373 RNZ ;NUMBERS ARE DIFFERENT
1374 POP H ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
1375 POP H
1376 RET ;ALL DONE
1377
1378
1379 IFE LENGTH-2,<
1380 ; COMPARE TWO INTEGERS
1381 ; A=1 IF (DE) .LT. (HL)
1382 ; A=0 IF (DE)=(HL)
1383 ; A=-1 IF (DE) .GT. (HL)
1384 ; ALTERS A ONLY
1385 ICOMP: MOV A,D ;ARE THE SIGNS THE SAME?
1386 XRA H
1387 MOV A,H ;IF NOT, ANSWER IS THE SIGN OF (HL)
1388 JM ICOMPS ;THEY ARE DIFFERENT
1389 CMP D ;THEY ARE THE SAME, COMPARE THE HO'S
1390 JNZ SIGNS ;GO SET UP A
1391 MOV A,L ;COMPARE THE LO'S
1392 SUB E
1393 JNZ SIGNS ;GO SET UP A
1394 RET ;ALL DONE, THEY ARE THE SAME
1395
1396
1397 ; COMPARE TWO DOUBLE PRECISION NUMBERS
1398 ; A=1 IF ARG .LT. FAC
1399 ; A=0 IF ARG=FAC
1400 ; A=-1 IF ARG .GT. FAC
1401 ; ALTERS A,B,C,D,E,H,I
1402 DCOMPD: LXI H,ARGLO ;ENTRY WITH POINTER TO ARG IN (DE)
1403 MVI B,10 ;SET UP COUNT TO MOVE DBL NUMBERS
1404 CALL MOVE1 ;MOVE THE ARGUMENT INTO ARG
1405 DCOMP: LXI D,ARG ;GET POINTER TO ARG
1406 LOAX D ;SEE IF ARG=0
1407 ORA A
1408 JZ SIGN ;ARG=0, GO SET UP A
1409 LXI H,FCOMPS ;PUSH FCOMPS ON STACK SO WE WILL RETURN TO
1410 PUSH H ;TO IT AND SET UP A
1411 FSIGN ;SEE IF FAC=0
1412 DCX D ;POINT TO SIGN OF ARG
1413 LDAX D ;GET SIGN OF ARG
1414 MOV C,A ;SAVE IT FOR LATER
1415 RZ ;FAC=0, SIGN OF RESULT IS SIGN OF ARG
1416 LXI H,FAC-1 ;POINT TO SIGN OF FAC
1417 XRA M ;SEE IF THE SIGNS ARE THE SAME
1418 MOV A,C ;IF THEY ARE, GET THE SIGN OF THE NUMBERS
1419 RM ;THE SIGNS ARE DIFFERENT, GO SET A
1420 INX D ;POINT BACK TO EXPONENT OF ARG
1421 INX H ;POINT TO EXPONENT OF FAC
1422 MVI B,10 ;SET UP A COUNT
1423 DCOMP1: LOAX D ;GET A BYTE FROM ARG
1424 SUB M ;COMPARE IT WITH THE FAC
1425 JNZ FCOMPD ;THEY ARE DIFFERENT, GO SET UP A
1426 DCX D ;THEY ARE THE SAME, EXAMINE THE NEXT LOWER
1427 DCX H ;ORDER BYTES
1428 DCR B ;ARE WE DONE?
1429 JNZ DCOMP1 ;NO, COMPARE THE NEXT BYTES
1430 POP B ;THEY ARE THE SAME, GET FCOMPS OFF STACK
1431 RET> ;ALL DONE
1432 PAGE
1433 SUBTTL CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PRECISION
1434 IFE LENGTH-2,<
1435 ; FORCE THE FAC TO BE AN INTEGER
1436 ; ALTERS A,B,C,D,E,H,L
1437 FRCINT: LDA VALTYP ;SEE WHAT WE HAVE
1438 CPI 4
1439 LHLD FACLO ;GET FACLO+0,1 IN CASE WE HAVE AN INTEGER
1440 RC ;WE HAVE AN INTEGER, ALL DONE
1441 JM TMERR ;WE HAVE A STRING, THAT IS A "NO-NO"
1442 CNZ CONSD ;IF WE HAVE A DBL, CONVERT IT TO A SNG
1443 LXI H,OVERR ;PUT OVERR ON THE STACK SO WE WILL GET ERROR
1444 PUSH H ;IF NUMBER IS TOO BIG
1445 ;FALL INTO CONIS
1446
1447
1448 ; CONVERT SINGLE PRECISION NUMBER TO INTEGER
1449 ; ALTERS A,B,C,D,E,H,L
1450 CONIS: LDA FAC ;GET THE EXPONENT
1451 CPI 220 ;SEE IF IT IS TOO BIG
1452 JNC CONIS2 ;IT IS, BUT IT MIGHT BE -32768
1453 CALL QINT ;IT ISN'T, CONVERT IT TO AN INTEGER
1454 XCHG ;PUT IT IN (HL)
1455 CONIS1: POP D ;GET ERROR ADDRESS OFF STACK
1456 ;ENTRY FROM SGN, FIN, LINPRT
1457 CONISS: SHLD FACLO ;STORE THE NUMBER IN FACLO
1458 MVI A,2 ;SET VALTYP TO "INTEGER"
1459 CONISD: STA VALTYP ;ENTRY FROM CONDS
1460 RET ;ALL DONE
1461 CONIS2: MOVRI 220,200,000,000 ;CHECK IF NUMBER IS -32768, ENTRY FROM FIN
1462 CALL FCOMP
1463 RNZ ;ERROR: IT CAN'T BE CONVERTED TO AN INTEGER
1464 MOV H,C ;IT IS -32768, PUT IT IN (HL)
1465 MOV L,D
1466 JMP CONIS ;STORE IT IN THE FAC AND SET VALTYP
1467
1468
1469 ; FORCE THE FAC TO BE A SINGLE PRECISION NUMBER
1470 ; ALTERS A,B,C,D,E,H,L
1471 FRCSNG: LDA VALTYP ;SEE WHAT KIND OF NUMBER WE HAVE
1472 CPI 4
1473 RZ ;WE ALREADY HAVE AN INTEGER, ALL DONE
1474 JC CONSI ;WE HAVE AN INTEGER, CONVERT IT
1475 JM TMERR ;STRINGS!! -- ERROR!!
1476 ;DBL PREC -- FALL INTO CONSD
1477
1478
1479 ; CONVERT DOUBLE PRECISION NUMBER TO A SINGLE PRECISON ONE
1480 ; ALTERS A,B,C,D,E,H,L
1481 CONSD: CALL MOVRF ;GET THE HO'S IN THE REGISTERS
1482 MVI A,4 ;SET VALTYP TO "SINGLE PRECISON"
1483 STA VALTYP
1484 MOV A,B ;CHECK IF THE NUMBER IS ZERO
1485 ORA A
1486 RZ ;IF IT IS, WE ARE DONE
1487 CALL UNPACK ;UNPACK THE NUMBER
1488 LXI H,FACLO-1 ;GET FIRST BYTE BELOW A SNG NUMBER
1489 MOV B,M ;PUT IT IN B FOR ROUND
1490 JMP ROUND ;ROUND THE DBL NUMBER UP AND WE ARE DONE
1491
1492
1493 ; CONVERT AN INTEGER TO A SINGLE PRECISION NUMBER
1494 ; ALTERS A,B,C,D,E,M,L
1495 CONSI: LHLD FACLO ;GET THE INTEGER
1496 CONSIH: MVI A,4 ;SET VALTYP TO "SINGLE PRECISION"
1497 STA VALTYP
1498 MOV A,H ;SET UP REGISTERS FOR FLOATR
1499 MOV D,L
1500 MVI E,0
1501 MVI B,220
1502 JMP FLOATR ;GO FLOAT THE NUMBER
1503
1504
1505 ; FORCE THE FAC TO BE A DOUBLE PRECISION NUMBER
1506 ; ALTERS A,B,C,D,E,M,L
1507 FRCOBL: LDA VALTYP ;SEE WHAT KIND OF NUMBER WE HAVE
1508 CPI 10
1509 RZ ;WE ALREADY HAVE A DBL, WE ARE DONE
1510 JNC TMERR ;GIVE AN ERROR IF WE HAVE A STRING
1511 CPI 2 ;SEE IF WE HAVE A SNG OR INT
1512 CZ CONSI ;CONVERT TO SNG IF WE HAVE AN INT
1513 ;FALL INTO CONDS AND CONVERT TO DBL
1514
1515
1516 ; CONVERT A SINGLE PRECISION NUMBER TO A DOUBLE PRECISION ONE
1517 ; ALTERS A,H,L
1518 CONDS: LXI H,$CODE ;ZERO H,L
1519 SHLD DFACLO ;CLEAR THE FOUR LOWER BYTES IN THE DOUBLE
1520 SHLD DFACLO+2 ;PRECISION NUMBER
1521 MVI A,10 ;SET VALTYP TO "DOUBLE PRECISION"
1522 JMP CONISD> ;GO TO IT
1523 PAGE
1524 SUBTTL GREATEST INTEGER FUNCTION
1525 ; QUICK GREATEST INTEGER FUNCTION
1526 ; LEAVES (FAC) IN C,D,E (SIGNED)
1527 ; ASSUMES FAC .LT. 2^23 = 8388608
1528 ; ASSUMES THE EXPONENT OF FAC IS IN A
1529 ; ALTERS A,B,C,D,E
1530 QINT: MOV B,A ;ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
1531 MOV C,A
1532 MOV D,A
1533 MOV E,A
1534 ORA A ;SET CONDITION CODES
1535 RZ ;IT IS ZERO, WE ARE DONE
1536
1537 ; THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS. TO HANDLE THIS, IF THE
1538 ; NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
1539 ; SUBTARCT ONE. THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
1540 ; MANTISSA RIGHT. THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE, SO, IF WE
1541 ; HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
1542 ; ZERO. SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E. IF THE
1543 ; NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
1544 ; RIGHT OF THE BINARY POINT. SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
1545 ; VALUE OF (FAC) IN C,D,E. C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
1546 ; NEGATIVE SO THE RESULT WILL BE SIGNED.
1547 PUSH H ;SAVE (HL)
1548 CALL MOVRF ;GET NUMBER IN THE REGISTERS
1549
1550
1551 CALL UNPACK ;UNPACK THE NUMBER
1552
1553
1554 XRA M ;GET SIGN OF NUMBER
1555 MOV H,A ;DON'T LOSE IT
1556 CM QINTA ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1557
1558
1559 MVI A,230 ;SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
1560
1561 SUB B ;NUMBER TO AN INTEGER
1562 CALL SHIFTR ;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
1563
1564
1565 MOV A,H ;GET SIGN
1566 RAL ;PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
1567 CC ROUNDA ;IF NUMBER WAS NEGATIVE, ADD ONE
1568
1569
1570 MVI B,0 ;FORGET THE BITS WE SHIFTED OUT
1571
1572 CC NEGR ;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
1573
1574
1575 ;WANT A SIGNED MANTISSA
1576 POP H ;GET OLD (HL) BACK
1577 RET ;ALL DONE
1578
1579 QINTA: DCX D ;SUBTRACT ONE FROM C,D,E
1580 MOV A,D ;WE HAVE TO SUBTRACT ONE FROM C IF
1581 ANA E ;D AND E ARE BOTH ALL ONES
1582 INR A ;SEE IF BOTH WERE -1
1583 RNZ ;THEY WERE NOT, WE ARE DONE
1584 IFN LENGTH-2,<
1585 DCR C> ;THEY WERE, SUBTRACT ONE FROM C
1586 IFE LENGTH-2,<
1587 DCXBRT: DCX B> ;THIS IS FOR BILL. C WILL NEVER BE ZERO
1588 ;(THE MSB WILL ALWAYS BE ONE) SO "DCX B"
1589 ;AND "DCR C" ARE FUNCTIONALLY EQUIVALENT
1590 RET ;ALL DONE
1591
1592
1593 ; GREATEST INTEGER FUNCTION
1594 ; ALTERS A,B,C,D,E,H,L
1595 IFE LENGTH-2,<
1596 INTFNC: CPI 4 ;SEE WHAT KIND OF NUMBER WE HAVE
1597 RC ;IT IS AN INTEGER, ALL DONE
1598 JNZ DINT ;CONVERT THE DOUBLE PRECISION NUMBER
1599 CALL CONIS> ;TRY TO CONVERT THE NUMBER TO AN INTEGER
1600 ;IF WE CAN'T, WE WILL RETURN HERE TO GIVE A
1601 ;SINGLE PRECISION RESULT
1602 INT: LXI H,FAC ;GET EXPONENT
1603
1604
1605 MOV A,M
1606 CPI 230 ;SEE IF NUMBER HAS ANY FRACTIONAL BITS
1607
1608 IFN EXTFNC,< ;THE ONLY GUY WHO NEEDS THIS DOESN'T CARE
1609 LDA FACLO> ;ABOUT THE SIGN
1610
1611
1612 RNC ;IT DOES NOT
1613 IFN EXTFNC,<
1614 MOV A,M> ;GET EXPONENT BACK
1615 CALL QINT ;IT DOES, SHIFT THEM OUT
1616
1617
1618 MVI M,230 ;CHANGE EXPONENT SO IT WILL BE CORRECT
1619
1620 ;AFTER NORMALIZATION
1621 IFN EXTFNC,<
1622 MOV A,E ;GET LO
1623 PUSH PSW> ;SAVE IT
1624 MOV A,C ;NEGATE NUMBER IF IT IS NEGATIVE
1625 RAL ;PUT SIGN IN CARRY
1626 IFE EXTFNC,<
1627 JMP FADFLT> ;REFLOAT NUMBER
1628 IFN EXTFNC,<
1629 CALL FADFLT ;REFLOAT NUMBER
1630
1631
1632 POPPRT: POP PSW ;GET LO BACK
1633 RET> ;ALL DONE
1634
1635
1636 IFE LENGTH-2,<
1637 ; GREATEST INTEGER FUNCTION FOR DOUBLE PRECISION NUMBERS
1638 ; ALTERS A,B,C,D,E,H,L
1639 DINT: LXI H,FAC ;GET POINTER TO FAC
1640 MOV A,M ;GET EXPONENT
1641 CPI 220 ;CAN WE CONVERT IT TO AN INTEGER?
1642 JC FRCINT ;THEN DO SO
1643 JNZ DINT2 ;CHECK FOR -32768
1644 MOV C,A ;SAVE EXPONENT IN C
1645 DCX H ;GET POINTER TO SIGN AND HO
1646 MOV A,M ;GET SIGN AND HO
1647 XRI 200 ;CHECK IF IT IS 200
1648 MVI B,6 ;SET UP A COUNT TO CHECK IF THE REST OF
1649 DINTI: DCX H ;THE NUMBER IS ZERO, POINT TO NEXT BYTE
1650 ORA M ;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
1651 OCR 8 ;ARE WE DONE?
1652 JNZ DINTI ;NO, CHECK THE NEXT LOWER ORDER BYTE
1653 ORA A ;IS A NOW ZERO?
1654 LXI H,200*400+$CODE ;GET -32768 JUST IN CASE
1655 JZ CONISS ;A IS ZERO SO WE HAVE -32768
1656 MOV A,C ;GET EXPONENT
1657 DINT2: CPI 270 ;ARE THERE ANY FRACTIONAL BITS?
1658 RNC ;NO, THE NUMBER IS ALREADY AN INTEGER
1659 DINTFO: PUSH PSW ;ENTRY FROM FOUT, CARRY IS ZERO IF WE COME
1660 ;HERE FROM FOUT
1661 CALL MOVRF ;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
1662 CALL UNPACK ;UNPACK IT
1663 XRA M ;GET ITS SIGN BACK
1664 DCX H ;SET THE EXPONENT TO NORMALIZE CORRECTLY
1665 MVI M,270
1666 PUSH PSW ;SAVE THE SIGN
1667 CM DINTA ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1668 MVI A,270 ;GET HOW MANY BITS WE HAVE TO SHIFT OUT
1669 SUB 8
1670 CALL DSHFTR ;SHIFT THEM OUT!!
1671 POP PSW ;GET THE SIGN BACK
1672 CM DROUNA ;IF NUMBER WAS NEGATIVE, ADD ONE
1673 XRA A ;PUT A ZERO IN THE EXTRA LO BYTE SO WHEN
1674 STA DFACLO-1 ;WE NORMALIZE, WE WILL SHIFT IN ZEROS
1675 POP PSW ;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE,
1676 RNC ;JUST RETURN
1677 JMP DNORML ;RE-FLOAT THE INTEGER
1678
1679 DINTA: LXI H,DFACLO ;SUBTRACT ONE FROM FAC, GET POINTER TO LO
1680 DINTAI: MOV A,M ;GET A BYTE OF FAC
1681 DCR M ;SUBTRACT ONE FROM IT
1682 ORA A ;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
1683 INX H ;INCREMENT POINTER TO NEXT BYTE
1684 JZ DINTAI ;CONTINUE IF NECESSARY
1685 RET> ;ALL DONE
1686 PAGE
1687 SUBTTL INTEGER ARITHMETIC ROUTINES
1688 IFN MULDIM&<LENGTH-2>,<
1689 ; TWO BYTE UNSIGNED INTEGER MULTIPLY
1690 ;   (HL):=(BC)*(D)
1691 ; A,D,E,H,L ARE CHANGED
1692 DMULT: LXI H,$CODE ;ZERO PRODUCT REGISTERS
1693
1694
1695 MOV A,B ;CHECK IF (BC) IS ZERO
1696 ORA C ;IF SO, JUST RETURN, (HL) IS ALREADY ZERO
1697 RZ ;THIS IS DONE FOR SPEED
1698 MVI A,20 ;SET UP A COUNT
1699
1700 DMULT1: DAD H ;ROTATE (HL) LEFT ONE
1701 JC BSERR## ;CHECK FOR OVERFLOW, IF SO,
1702
1703
1704 XCHG ;BAD SUBSCRIPT (BS) ERROR
1705 DAD H ;ROTATE (DE) LEFT ONE
1706 XCHG
1707 JNC DMULT2 ;ADD IN (BC) IF HO WAS 1
1708
1709
1710 DAD B
1711 JC BSERR ;CHECK FOR OVERFLOW
1712
1713
1714 DMULT2: DCR A ;SEE IF DONE
1715 JNZ DMULT1
1716
1717
1718 RET> ;ALL DONE
1719
1720
1721 IFE LENGTH-2,<
1722 COMMENT %
1723         INTEGER ARITHMETIC CONVENTIONS
1724
1725 INTEGER VARIABLES ARE 2 BYTE, SIGNED NUMBERS
1726     THE LO BYTE COMES FIRST IN MEMORY
1727
1728 CALLING CONVENTIONS:
1729 FOR ONE ARGUMENT FUNCTIONS:
1730     THE ARGUMENT IS IN (HL), THE RESULT IS LEFT IN (HL)
1731 FOR TWO ARGUMENT OPERATIONS:
1732     THE FIRST ARGUMENT IS IN (DE)
1733     THE SECOND ARGUMENT IS IN (HL)
1734     THE RESULT IS LEFT IN (HL)
1735 IF OVERFLOW OCCURS, THE ARGUMENTS ARE CONVERTED TO SINGLE PRECISION
1736 WHEN INTEGERS ARE STORED IN THE FAC, THEY ARE STORED AT FACLO+0,1
1737 VALTYP(INTEGER)=2
1738 %
1739
1740
1741 ; INTEGER SUBTRTACTION (HL):=(DE)=(HL)
1742 ; ALTERS A,B,C,D,E,H,L
1743 ISUB: MOV A,H ;EXTEND THE SIGN OF (HL) TO B
1744 RAL ;GET SIGN IN CARRY
1745 SBB A
1746 MOV B,A
1747 CALL INEGHL ;NEGATE (HL)
1748 MOV A,C ;GET A ZERO
1749 SBB B ;NEGATE SIGN
1750 JMP IADDS ;GO ADD THE NUMBERS
1751
1752
1753 ; INTEGER ADDITION (HL):=(DE)+(HL)
1754 ; ALTERS A,B,C,D,E,M,L
1755 ADD: MOV A,H ;EXTEND THE SIGN OF (HL) TO B
1756 RAL ;GET SIGN IN CARRY
1757 SBB A
1758 IADDS: MOV B,A ;SAVE THE SIGN
1759 PUSH H ;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
1760 MOV A,D ;EXTEND THE SIGN OF (DE) TO A
1761 RAL ;GET SIGN IN CARRY
1762 SBB A
1763 DAD D ;ADD THE TWO LO'S
1764 ADC B ;ADD THE EXTRA HO
1765 RRC ;IF THE LSB OF A IS DIFFERENT FROM THE MSB OF
1766 XRA H ;H, THEN OVERFLOW OCCURED
1767 JP POPPRT ;NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
1768 ;ARE DONE
1769 PUSH B ;OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
1770 XCHG ;GET (DE) IN (HL)
1771 CALL CONSIH ;FLOAT IT
1772 POP PSW ;GET SIGN OF (HL) IN A
1773 POP H ;GET OLD (HL) BACK
1774 CALL PUSHF ;PUT FIRST ARGUMENT ON STACK
1775 XCHG ;PUT SECOND ARGUMENT IN (DE) FOR FLOATR
1776 CALL INEGAD ;FLOAT IT
1777 POPR ;GET FIRST ARGUMENT OFF STACK
1778 JMP FADD ;ADD THE TWO NUMBERS USING SINGLE PRECISION
1779
1780
1781 ; INTEGER MULTIPLICATION (HL):=(DE)*(HL)
1782 ; ALTERS A,B,C,D,E,H,L
1783 IMULT: PUSH H ;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
1784 PUSH D ;SAVE FIRST ARGUMENT
1785 CALL IMULDV ;FIX UP THE SIGNS
1786 PUSH B ;SAVE THE SIGN OF THE RESULT
1787 MOV B,H ;COPY SECOND ARGUMENT INTO (BC)
1788 MOV C,L
1789 LXI H,$CODE ;ZERO (HL), THAT IS WHERE THE PRODUCT GOES
1790 MVI A,20 ;SET UP A COUNT
1791 IMULT1: DAD H ;ROTATE PRODUCT LEFT ONE
1792 JC IMULTS ;CHECK FOR OVERLFOW
1793 XCHG ;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
1794 DAD H ;WE ADD IN (BC) OR NOT
1795 XCHG
1796 JNC IMULT2 ;DON'T ADD IN ANYTHING
1797 DAD B ;ADD IN (BC)
1798 JC IMULTS ;CHECK FOR OVERLFOW
1799 IMULT2: DCR A ;ARE WE DONE?
1800 JNZ IMULT1 ;NO, DO IT AGAIN
1801 POP B ;WE ARE DONE, GET SIGN OF RESULT
1802 POP D ;GET ORIGINAL FIRST ARGUMENT
1803 IMLDIV: MOV A,H ;ENTRY FROM IDIV, IS RESULT ,GE, 32768?
1804 ORA A
1805 JM IMULT3 ;IT IS, CHECK FOR SPECIAL CASE OF -32768
1806 POP D ;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
1807 MOV A,B ;GET THE SIGN OF RESULT IN A
1808 JMP INEGA ;NEGATE THE RESULT IF NECESSARY
1809 IMULT3: XRI 200 ;IS RESULT 32768?
1810 ORA ;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
1811 JZ IMULT4 ;MUST BE 32768, IT CANNOT BE GREATER
1812 XCHG ;IT IS .GT. 32768, WE HAVE OVERFLOW
1813 XWD 1000,001 ;"LXI B" OVER NEXT 2 BYTES
1814 IMULTS: POP B ;GET SIGN OF RESULT OFF STACK
1815 POP H ;GET THE ORIGINAL FIRST ARGUMENT
1816 CALL CONSIH ;FLOAT IT
1817 POP H ;GET THE ORIGINAL SECOND ARGUMENT
1818 CALL PUSHF ;SAVE FLOATED FIRST ARUMENT
1819 CALL CONSIH ;FLOAT SECOND ARGUMENT
1820 FMULTT: POPR ;GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
1821
1822 JMP FMULT ;MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
1823 IMULT4: MOV A,B ;IS RESULT +32768 OR -32768?
1824 ORA A ;GET ITS SIGN
1825 POP B ;DISCARD ORIGINAL SECOND ARGUMENT
1826 RM ;THE RESULT SHOULD BE NEGATIVE, IT IS OK
1827 PUSH D ;IT IS POSITIVE, SAVE REMAINDER FOR MOD
1828 CALL CONSIH ;FLOAT -32768
1829 POP D ;GET MOD'S REMAINDER BACK
1830 JMP NEG ;NEGATE -32768 TO GET 32768, WE ARE DONE
1831
1832
1833 ; INTEGER DIVISION (HL):=(DE)/(HL)
1834 ; REMAINDER IS IN (DE), QUOTIENT IN (HL)
1835 ; ALTERS A,B,C,D,E,H,L
1836 IDIV: MOV A,H ;CHECK FOR DIVISION BY ZERO
1837 ORA L
1838 JZ DV0ERR ;WE HAVE DIVISION BY ZERO11
1839 CALL IMULDV ;FIX UP THE SIGNS
1840 PUSH B ;SAVE THE SIGN OF THE RESULT
1841 XCHG ;GET DENOMINATOR IN (HL)
1842 CALL INEGHL ;NEGATE IT
1843 MOV B,H ;SAVE NEGATED DENOMINATOR IN (BC)
1844 MOV C,L
1845 LXI H,$CODE ;ZERO WHERE WE DO THE SUBTRACTION
1846 MVI A,21 ;SET UP A COUNT
1847 PUSH PSW ;SAVE IT
1848 ORA A ;CLEAR CARRY
1849 JMP IDIV3 ;GO DIVIDE
1850 IDIVI: PUSH PSW ;SAVE COUNT
1851 PUSH H ;SAVE (HL) I.E. CURRENT NUMERATOR
1852 DAD B ;SUBTRACT DENOMINATOR
1853 JNC IDIV2 ;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
1854 POP PSW ;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
1855 STC ;NEXT BIT IN QUOTIENT IS A ONE
1856 XWD 1000,076 ;"MVI A" OVER NEXT BYTE
1857 IDIV2: POP H ;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
1858 IDIV3: MOV A,E ;SHIFT IN THE NEXT QUOTIENT BIT
1859 RAL
1860 MOV E,A
1861 MOV A,D ;SHIFT THE HO
1862 RAL
1863 MOV D,A
1864 MOV A,L ;SHIFT IN THE NEXT BIT OF THE NUMERATOR
1865 RAL
1866 MOV L,A
1867 MOV A,H ;DO THE HO
1868 RAL
1869 MOV H,A ;SAVE THE HD
1870 POP PSW ;GET COUNT BACK
1871 DCR A ;ARE WE DONE?
1872 JNZ IDIVI ;NO, DIVIDE AGAIN
1873 XCHG ;GET QUOTIENT IN (HL), REMAINDER IN (DE)
1874 POP B ;GET SIGN OF RESULT
1875 PUSH D ;SAVE REMAINDER SO STACK WILL BE ALRIGHT
1876 JMP IMLDIV ;CHECK FOR SPECIAL CASE OF 32768
1877
1878
1879 ; GET READY TO MULTIPLY OR DIVIDE
1880 ; ALTERS A,B,C,D,E,H,L
1881 IMULDV: MOV A,H ;GET SIGN OF RESULT
1882 XRA D
1883 MOV B,A ;SAVE IT IN B
1884 CALL INEGH ;NEGATE SECOND ARGUMENT IF NECESARY
1885 XCHG ;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
1886 ;ARGUMENT IF NECESSARY
1887
1888
1889 ; NEGATE H,L
1890 ; ALTERS A,C,H,L
1891 INEGH: MOV A,H ;GET SIGN OF (HL)
1892 INEGA: ORA A ;SET CONDITION CODES
1893 RP ;WE DON'T HAVE TO NEGATE, IT IS POSITIVE
1894 INEGHL: XRA ;CLEAR A
1895 MOV C,A ;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
1896 SUB ;NEGATE LO
1897 MOV L,A ;SAVE IT
1898 MOV A,C ;GET A ZERO BACK
1899 SBB H ;NEGATE HO
1900 MOV H,A ;SAVE IT
1901 RET ;ALL DONE
1902
1903
1904 ; INTEGER ABSOLUTE VALUE
1905 ; ALTERS A,B,C,D,E,H,L
1906 IABS: LDA FACLO+1 ;GET SIGN OF INTEGER IN FAC
1907 ORA A ;CHECK ITS SIGN
1908 RP ;IT IS POSITIVE, LEAVE IT ALONE
1909 ;FALL INTO INEG AND NEGATE IT
1910
1911
1912 ; INTEGER NEGATION
1913 ; ALTERS A,B,C,D,E,H,L
1914 INEG: LHLD FACLO ;GET THE INTEGER
1915 CALL INEGHL ;NEGATE IT
1916 SHLD FACLO ;STORE IT BACK IN THE FAC
1917 XRI 200 ;CHECK FOR SPECIAL CASE OF 32768
1918 ORA
1919 RNZ ;IT DID NOT OCCUR, EVERYTHING IS FINE
1920 XCHG ;WE HAVE IT, FLOAT 32768
1921 MVI A,4 ;CHANGE VALTYP 10 "SINGLE PRECISION"
1922 STA VALTYP
1923 INEGAD: MVI B,230 ;ENTRY FROM ;ADD, SET EXPONENT
1924 JMP FLOATR ;GO FLOAT THE NUMBER
1925
1926
1927 ; MOD OPERATOR
1928 ; (HL):=(DE)-(DE)/(HL)*(HL) (DE)=QUOTIENT
1929 ; ALTERS A,B,C,D,E,M,L
1930 MOD: PUSH D ;SAVE (DE) FOR ITS SIGN
1931 CALL IDIV ;DIVIDE AND GET THE REMAINDER
1932 XCHG ;PUT REMAINDER IN (DE)
1933 MVI A,2 ;SET VALTYP TO "INTEGER" IN CASE RESULT OF
1934 STA VALTYP ;THE DIVISION WAS 32768
1935 POP PSW ;GET THE SIGN OF (DE) BACK
1936 JMP INEGA> ;NEGATE THE REMAINDER IF NECESSARY
1937 PAGE
1938 SUBTTL DOUBLE PRECISION ARITHMETIC ROUTINES
1939 IFE LENGTH-2,<
1940 COMMENT %
1941         DOUBLE PRECISION ARITHMETIC CONVENTIONS
1942
1943 DOUBLE PRECISION NUMBERS ARE 8 BYTE QUANTITIES
1944 THE LAST 4 BYTES IN MEMORY ARE IN THE SAME FORMAT AS SINGLE PRECISION NUMBERS
1945 THE FIRST 4 BYTES ARE 32 MORE LOW ORDER BITS OF PRECISION
1946 THE LOWEST ORDER BYTE COMES FIRST IN MEMORY
1947
1948 CALLING CONVENTIONS:
1949 FOR ONE ARGUMENT FUNCTIONS:
1950     THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
1951 FOR TWO ARGUMENT OPERATIONS:
1952     THE FIRST ARGUMENT IS IN ARG-7,6,5,4,3,2,1,0 (NOTE: ARGLO=ARG-7)
1953     THE SECOND ARGUMENT IS IN THE FAC
1954     THE RESULT IS LEFT IN THE FAC
1955 VALTYP(COUBLE PRECISION)=10 OCTAL
1956 %
1957
1958
1959 ; DOUBLE PRECISION SUBTRACTION FAC:=ARG-FAC
1960 ; ALTERS ALL REGISTERS
1961 DSUB: CALL NEG ;NEGATE THE SECOND ARGUMENT
1962 ;FALL INTO DADD
1963
1964
1965 ; DOUBLE PRECISION ADDITION FAC:=ARG+FAC
1966 ; ALTERS ALL REGISTERS
1967 DADD: LXI H,ARG ;GET POINTER TO EXPONENT OF FIRST ARGUMENT
1968 MOV A,M ;CHECK IF IT IS ZERO
1969 ORA A
1970 RZ ;IT IS, RESULT IS ALREADY IN FAC
1971 MOV B,A ;SAVE EXPONENT FOR UNPACKING
1972 DCX H ;POINT TO HO AND SIGN
1973 MOV C,M ;GET HO AND SIGN FOR UNPACKING
1974 LXI D,FAC ;GET POINTER TO EXPONENT OF SECOND ARGUMENT
1975 LDAX D ;GET EXPONENT
1976 ORA A ;SEE IF IT IS ZERO
1977 JZ VMOVFA ;IT IS, MOVE ARG TO FAC AND WE ARE DONE
1978 SUB B ;SUBTRACT EXPONENTS TO GET SHIFT COUNT
1979 JNC DADD2 ;PUT THE SMALLER NUMBER IN FAC
1980 CMA ;NEGATE SHIFT COUNT
1981 INR A
1982 PUSH PSW ;SAVE SHIFT COUNT
1983 PUSH B ;SAVE HO TO UNPACK LATER
1984 MVI C,10 ;SWITCH FAC AND ARG, SET UP A COUNT
1985 INX H ;POINT TO ARG
1986 DADD1: LDAX 0 ;GET A BYTE OF THE FAC
1987 MOV B,M ;GET A BYTE OF ARG
1988 MOV M,A ;PUT THE FAC BYTE IN ARG
1989 MOV A,B ;PUT THE ARG BYTE IN A
1990 STAX D ;PUT THE ARG BYTE IN FAC
1991 DCX D ;POINT TO THE NEXT LO BYTE OF FAC
1992 DCX H ;POINT TO THE NEXT LO BYTE OF ARG
1993 DCR C ;ARE WE DONE?
1994 JNZ DADD1 ;NO, DO THE NEXT LO BYTE
1995 POP B ;GET THE HO BACK
1996 POP PSW ;GET THE SHIFT COUNT BACK
1997 DADD2: CPI 71 ;ARE WE WITHIN 56 BITS?
1998 RNC ;NO, ALL DONE
1999 PUSH PSW ;SAVE SHIFT COUNT
2000 CALL UNPACK ;UNPACK THE NUMBERS
2001 MOV B,A ;SAVE SUBTRACTION FLAG
2002 MOV A,C ;SAVE THE UNPACKED HO
2003 STA ARG-1
2004 POP PSW ;GET SHIFT COUNT
2005 CALL DSHFTR ;SHIFT FAC RIGHT THE RIGHT NUMBER OF TIMES
2006 ORA B ;GET SUBTRACTION FLAG, HERE A=0
2007 JP DADD3 ;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
2008 CALL DADDAA ;SIGNS ARE THE SAME, ADD THE NUMBERS
2009 JNC DROUND ;ROUND THE RESULT IF NO CARRY
2010 INR M ;WE HAVE OVERFLOW, ADD ONE TO THE EXPONENT
2011 JZ OVERR ;CHECK FOR OVERFLOW
2012 MVI D,1 ;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
2013 CALL DSHFRA
2014 JMP DROUND ;ROUND THE RESULT
2015 DADD3: XWD 1000,076 ;"MVI A", SUBTRACT THE NUMBERS
2016 SBB M ;GET THE SUBTRACT INSTRUCTION IN A
2017 CALL DADDA ;SUBTRACT THE NUMBERS
2018 INX H ;POINT TO THE UNPACKED SIGN
2019 MOV A,M ;COMPLEMENT IT, SINCE THE FAC WAS SMALLER
2020 CMA
2021 MOV M,A
2022 CC DNEGR ;NEGATE THE RESULT IF IT WAS NEATIVE
2023 ;FALL INTO DNORML
2024
2025
2026 ; NORMALIZE FAC
2027 ; ALTERS A,B,C,D,H,L
2028 DNORML: XRA A ;CLEAR SHIFT COUNT
2029 DNORM1: MOV B,A ;SAVE SHIFT COUNT
2030 LDA FAC-1 ;GET HO
2031 ORA A ;SEE IF WE CAN SHIFT 8 LEFT
2032 JNZ DNORMS ;WE CAN'T, SEE IF NUMBER IS NORMALIZED
2033 LXI H,DFACLO-1 ;WE CAN, GET POINTER TO LO
2034 MVI C,10 ;SET UP A COUNT
2035 DNORM2: MOV D,M ;GET A BYTE OF FAC
2036 MOV M,A ;PUT IN BYTE FROM LAST LOCATION, THE FIRST
2037 ;TIME THROUGH A IS ZERO
2038 MOV A,D ;PUT THE CURRENT BYTE IN A FOR NEXT TIME
2039 INX H ;INCREMENT POINTER TO NEXT HIGHER ORDER
2040 DCR C ;ARE WE DONE?
2041 JNZ DNORM2 ;NO, DO THE NEXT BYTE
2042 MOV A,B ;SUBTRACT 8 FROM SHIFT COUNT
2043 SUI 10
2044 CPI 300 ;HAVE WE SHIFTED ALL BYTES TO ZERO?
2045 JNZ DNORM1 ;NO, TRY TO SHIFT 8 MORE
2046 JMP ZERO ;YES, THE NUMBER IS ZERO
2047 DNORM3: DCR B ;DECREMENT SHIFT COUNT
2048 LXI H,DFACLO-1 ;GET POINTER TO LO
2049 CALL DSHFLC ;SHIFT THE FAC LEFT
2050 ORA A ;SEE IF NUMBER IS NORMALIZED
2051 DNORMS: JP DNORM3 ;SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
2052 MOV A,B ;GET THE SHIFT COUNT
2053 ORA A ;SEE IF NO SHIFTING WAS DONE
2054 JZ DROUND ;NONE WAS, PROCEED TO ROUND THE NUMBER
2055 LXI H,FAC ;GET POINTER TO EXPONENT
2056 ADD M ;UPDATE IT
2057 MOV M,A ;SAVE UPDATED EXPONENT
2058 JNC ZERO ;UNDERFLOW, THE RESULT IS ZERO
2059 RZ ;RESULT IS ALREADY ZERO, WE ARE DONE
2060 ;FALL INTO DROUND AND ROUND THE RESULT
2061
2062
2063 ; ROUND FAC
2064 ; ALTERS A,B,H,L
2065 DROUND: LDA DFACLO-1 ;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
2066 DROUNB: ORA A ;ENTRY FROM DDIV
2067 CM DROUNA ;ROUND UP IF NECESSARY
2068 LXI H,FAC+1 ;GET POINTER TO UNPACKED SIGN
2069 MOV A,M ;GET SIGN
2070 ANI 200 ;ISOLATE SIGN BIT
2071 DCX H ;POINT TO HD
2072 DCX H
2073 XRA M ;PACK SIGN AND HO
2074 MOV M,A ;PUT PACKED SIGN AND HO IN FAC
2075 RET ;WE ARE DONE
2076
2077
2078 ; SUBROUTINE FOR ROUND: ADD ONE TO FAC
2079 DROUNA: LXI H,DFACLO ;GET POINTER TO LO, ENTRY FROM DINT
2080 MVI B,7 ;SET UP A COUNT
2081 DRONA1: INR M ;INCREMENT A BYTE
2082 RNZ ;RETURN IF THERE WAS NO CARRY
2083 INX H ;INCREMENT POINTER TO NEXT HIGHER ORDER
2084 DCR B ;HAVE WE INCREMENTED ALL BYTES
2085 JNZ DRONA1 ;NO, TRY THE NEXT ONE
2086 INR M ;YES, INCREMENT THE EXPONENT
2087 JZ OVERR ;CHECK FOR OVERFLOW
2088 DCX H ;THE NUMBER OVERFLOWED ITS EXPONENT
2089 MVI M,200 ;PUT 200 IN HO
2090 RET ;ALL DONE
2091
2092
2093 ; ADD OR SUBTRACT 2 DBL QUANTITIES
2094 ; ALTERS A,C,D,E,H,L
2095 DADDD: LXI H,FBUFFR+^D17 ;ENTRY FROM DDIV
2096 LXI D,ARGLO ;ADD OR SUBTRACT FBUFFR+17 AND ARG
2097 JMP DADDS ;DO THE OPERATION
2098
2099 DADDAA: XWD 1000,076 ;"MVI A", ENTRY FROM DADD, DMULT
2100 ADC M ;SETUP ADD INSTRUCTION FOR LOOP
2101 DADDA: LXI H,ARGLO ;GET POINTER TO ARG, ENTRY FROM DADO
2102 DADDFO: LXI D,DFACLO ;GET POINTER TO FAC, ENTRY FROM FOUT
2103 DADDS: MVI C,7 ;SET UP A COUNT
2104 STA DADDDP ;STORE THE ADD OR SUBTRACT INSTRUCTION
2105 XRA A ;CLEAR CARRY
2106 DADDL: LOAX D ;GET A BYTE FROM RESULT NUMBER
2107 DADDDP: NOP ;THIS IS EITHER "ADC M" OR "SBB M"
2108 STAX D ;SAVE THE CHANGED BYTE
2109 INX D ;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
2110 INX H
2111 DCR C ;ARE WE DONE?
2112 JNZ DADDL ;NO, DO THE NEXT HIGHER ORDER BYTE
2113 RET ;ALL DONE
2114
2115
2116 ; NEGATE SIGNED NUMBER IN FAC
2117 ; THIS IS USED BY DADD, DINT
2118 ; ALTERS A,B,C,H,L
2119 DNEGR: MOV A,M ;COMPLEMENT SIGN OF FAC
2120 CMA ;USE THE UNPACKED SIGN BYTE
2121 MOV M,A ;SAVE THE NEW SIGN
2122 LXI H,DFACLO-1 ;GET POINTER TO LO
2123 MVI B,10 ;SET UP A COUNT
2124 XRA A ;CLEAR CARRY AND GET A ZERO
2125 MOV C,A ;SAVE ZERO IN C
2126 DNEGR1: MOV A,C ;GET A ZERO
2127 S88 M ;NEGATE THE BYTE OF FAC
2128 MOV M,A ;UPDATE FAC
2129 INX H ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2130 DCR B ;ARE WE DONE?
2131 JNZ DNEGR1 ;NO, NEGATE THE NEXT BYTE
2132 RET ;ALL DONE
2133
2134
2135 ; SHIFT DBL FAC RIGHT ONE
2136 ; A = SHIFT COUNT
2137 ; ALTERS A,C,D,E,H,L
2138 DSHFTR: LXI H,DFACLO-1 ;GET POINTER TO LO
2139 MVI M,0 ;PUT ZERO IN EXTRA LO ORDER BYTE
2140 DSHFR1: SUI 10 ;SEE IF WE CAN SHIFT 8 RIGHT
2141 JC DSHFR3 ;WE CAN'T, CHECK IF WE ARE DONE
2142 DSHFRM: LXI H,FAC-1 ;ENTRY FROM DMULT, GET POINTER TO HO
2143 MVI E,0 ;SHIFT A ZERO INTO THE HO
2144 MVI D,10 ;SET UP A COUNT
2145 DSHFR2: MOV C,M ;SAVE A BYTE OF FAC
2146 MOV M,E ;PUT THE LAST BYTE IN ITS PLACE
2147 MOV E,C ;SET UP E FOR NEXT TIME THROUGH THE LOOP
2148 DCX H ;POINT TO NEXT LOWER ORDER BYTE
2149 DCR D ;ARE WE DONE?
2150 JNZ DSHFR2 ;NO, DO THE NEXT BYTE
2151 JMP DSHFR1 ;YES, SEE IF WE CAN SHIFT OVER 8 MORE
2152 DSHFR3: ADI 11 ;CORRECT SHIFT COUNT
2153 MOV D,A ;SAVE SHIFT COUNT IN D
2154 DSHFR4: XRA A ;CLEAR CARRY
2155 DCR D ;ARE WE DONE?
2156 R2 ;YES
2157 DSHFRA: LXI H,FAC-1 ;NO, GET POINTER TO LO, ENTRY FROM DADD, DMULT
2158 MVI E,10 ;SET UP A COUNT, ROTATE FAC ONE LEFT
2159 DSHFR5: MOV A,M ;GET A BYTE OF THE FAC
2160 RAR ;ROTATE IT LEFT
2161 MOV M,A ;PUT THE UPDATED BYTE BACK
2162 DCX H ;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
2163 DCR E ;ARE WE DONE?
2164 JNZ DSHFR5 ;NO, ROTATE THE NEXT LOWER ORDER BYTE
2165 JMP DSHFR4 ;YES, SEE IF WE ARE DONE SHIFTING
2166
2167
2168 ; ROTATE FAC LEFT ONE
2169 ; ALTERS A,C,H,L
2170 DSHFLC: MVI C,10 ;SET UP A COUNT
2171 DSHFTL: MOV A,M ;GET A BYTE OF FAC
2172 RAL ;ROTATE IT LEFT ONE
2173 MOV M,A ;UPDATE BYTE IN FAC
2174 INX H ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2175 DCR C ;ARE WE DONE?
2176 JNZ DSHFTL ;NO, ROTATE THE NEXT BYTE
2177 RET ;ALL DONE
2178
2179
2180 ; DOUBLE PRECISION MULTIPLICATION FAC:=ARG*FAC
2181 ; ALTERS ALL REGISTERS
2182 DMULT: FSIGN ;CHECK IF WE ARE MULTIPLYING BY ZERO
2183 RZ ;YES, ALL DONE, THE FAC IS ZERO
2184 CALL MULDVA ;ADD EXPONENTS AND TAKE CARE OF SIGNS
2185 CALL DMULDV ;ZERO FAC AND PUT FAC IN FBUFFR
2186 MOV M,C ;PUT UNPACKED HO IN ARG
2187 LXI D,ARGLO ;GET POINTER TO LO OF ARG
2188 MVI B,7 ;SET UP A COUNT
2189 DMULT2: LDAX D ;GET THE BYTE OF ARG TO MULTIPLY BY
2190 INX D ;INCREMENT POINTER TO NEXT HIGHER BYTE
2191 ORA A ;CHECK IF WE ARE MULTIPLYING BY ZERO
2192 PUSH D ;SAVE POINTER TO ARG
2193 JZ DMULT5 ;WE ARE
2194 MVI C,10 ;SET UP A COUNT
2195 DMULT3: PUSH B ;SAVE COUNTERS
2196 RAR ;ROTATE MULTIPLIER RIGHT
2197 MOV B,A ;SAVE IT
2198 CC DADDAA ;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
2199 MVI 0,1 ;ROTATE PRODUCT RIGHT ONE
2200 CALL DSHFRA
2201 MOV A,B ;GET MULTIPLIER IN A
2202 POP B ;GET COUNTERS BACK
2203 DCR C ;ARE WE DONE WITH THIS BYTE OF ARG?
2204 JNZ DMULT3 ;NO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
2205
2206 DMULT4: POP D ;YES, GET POINTER INTO ARG BACK
2207 DCR B ;ARE WE DONE?
2208 JNZ DMULT2 ;NO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
2209 JMP NORMAL ;ALL DONE, NORMALIZE AND ROUND RESULT
2210 DMULT5: CALL DSHFRM ;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
2211 JMP DMULT4 ;MULTIPLYIING BY ZERO
2212
2213
2214 ; CONSTANT FOR DIVIO, DDIV10
2215 DTEN: 000 ;10D0
2216 000
2217 000
2218 000
2219 FTEN: 000 ;10.0
2220 000
2221 040
2222 204
2223
2224 ; DOUBLE PRECISION DIVIDE FAC BY 10
2225 ; ALTERS ALL REGISTERS
2226 DDIV10: CALL VMOVAF ;SAVE THE FAC IN ARG
2227 LXI H,DTEN ;GET POINTER TO A DOUBLE PRECISION 10
2228 CALL VMOVFM ;MOVE TEN INTO THE FAC
2229 ;FALL INTO DDIV AND DIVIDE BY TEN
2230
2231
2232 ; DOUBLE PRECISION DIVISION FAC:=ARG/FAC
2233 ; ALTERS ALL REGISTERS
2234 DDIV: FSIGN ;CHECK FOR DIVISION BY ZERO
2235 JZ DV0ERR ;DON'T LET HIM DO IT
2236 CALL MULDVS ;SUBTRACT EXPONENTS AND CHECK SIGNS
2237 INR M ;ADD TWO TO EXPONENT TO CORRECT SCALING
2238 INR M
2239 CALL DMULDV ;ZERO FAC AND PUT FAC IN FBUFFR
2240 LXI H,ARG ;GET POINTER TO THE EXTRA HO BYTE WE WILL USE
2241 MOV M,C ;ZERO IT
2242 MVI B,0 ;ZERO FLAG TO SEE WHEN WE START DIVIDING
2243 DDIVI: XWD 1000,076 ;"MVI A", SUBTRACT FBUFFR FROM ARG
2244 SBB M ;GET SUBTRACT INSTRUCTION
2245 CALL DADDD ;DO THE SUBTRACTION
2246 LDAX D ;SUBTRACT FROM EXTRA HO BYTE
2247 SBB C ;HERE C=0
2248 CMC ;CARRY=1 IF SUBTRACTION WAS GOOD
2249 JC DDIV2 ;WAS IT OK?
2250 XWD 1000,076 ;"MVI A" NO, ADD FBUFFR BACK IN
2251 ADC M ;GET ADD INSTRUCTION
2252 CALL DADDD ;DO THE ADDITION
2253 XRA A ;CLEAR CARRY
2254 XWD 1000,332 ;"JC" OVER NEXT TWO BYTES
2255 DDIV2: STAX D ;STORE THE NEW HIGHEST ORDER BYTE
2256 INR B ;INCREMENT FLAG TO SHOW WE COULD DIVIDE
2257 LDA FAC-1 ;CHECK IF WE ARE DONE DIVIDING
2258 INR A ;SET SIGN FLAG WITHOUT AFFECTING CARRY
2259 DCR A
2260 RAR ;PUT CARRY IN MSB FOR DROUND
2261 JM DROUND ;WE ARE DONE, WE HAVE 57 BITS OF ACCURACY
2262 RAL ;GET OLD CARRY BACK WHERE IT BELONGS
2263 LXI H,DFACLO ;GET POINTER TO LO OF FAC
2264 MVI C,7 ;SET UP A COUNT, SHIFT FAC LEFT ONE
2265 CALL DSHFTL ;SHIFT IN THE NEXT BIT IN THE QUOTIENT
2266 LXI H,ARGLO ;GET POINTER TO LO IN ARG
2267 CALL DSHFLC ;SHIFT DIVIDEND ONE LEFT
2268 MOV A,B ;IS THIS THE FIRST TIME AND WAS THE
2269 ORA A ;SUBTRACTION NOT GOOD? (B WILL GET
2270 JNZ DDIVI ;CHANGED ON THE FIRST OR SECOND SUBTRACTION)
2271 LXI H,FAC ;YES, SUBTRACT ONE FROM EXPONENT TO CORRECT
2272 DCR M ;SCALING
2273 JNZ DDIVI ;CONTINUE DIVIDING IF NO OVERFLOW
2274 JMP OVERR ;WE HAVE OVERFLOW11
2275
2276
2277 ; TRANSFER FAC TO FBUFFR FOR DMULT AND DDIV
2278 ; ALTERS A,B,C,D,E,H,L
2279 DMULDV: MOV A,C ;PUT UNPACKED HO BACK IN ARG
2280 STA ARG-1
2281 DCX H ;POINT TO HO OF FAC
2282 LXI D,FBUFFR+^D23 ;POINT TO END OF FBUFFR
2283 MVI B,7 ;SET UP A COUNT
2284 MVI C,0 ;GET A ZERO TO FILL FAC WITH
2285 DMLDV1: MOV A,M ;GET A BYTE FROM FAC
2286 STAX D ;PUT IT IN FBUFFR
2287 MOV M,C ;PUT A ZERO IN FAC
2288 DCX D ;POINT TO NEXT BYTE IN FBUFFR
2289 DCX H ;POINT TO NEXT LOWER ORDER BYTE IN FAC
2290 DCR B ;ARE WE DONE?
2291 JNZ DMLDV1 ;NO, TRANSFER THE NEXT BYTE
2292 RET ;ALL DONE
2293
2294
2295 ; DOUBLE PRECISION MULTIPLY THE FAC BY 10
2296 ; ALTERS ALL REGISTERS
2297 DMUL10: CALL VMOVAF ;SAVE THE FAC IN ARG
2298 ;VMOVAF EXITS WITH (DE)=FAC+1
2299 XCHG ;GET THE POINTER INTO THE FAC IN (HL)
2300 DCX H ;POINT TO THE EXPONENT
2301 MOV A,M ;GET THE EXPONENT
2302 ADI 2 ;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
2303 JC OVERR ;CHECK FOR OVERFLOW
2304 MOV M,A ;SAVE THE NEW EXPONENT
2305 PUSH H ;SAVE POINTER TO FAC
2306 CALL DADD ;ADD IN THE ORIGINAL FAC TO GET 5 TIMES FAC
2307 POP H ;GET THE POINTER TO FAC BACK
2308 INR M ;ADD ONE TO EXPONENT TO GET 10 TIMES FAC
2309 RNZ ;ALL DONE IF OVERFLOW DID NOT OCCUR
2310 JMP OVERR> ;IT DID, GIVE THE APPROPRIATE MESSAGE
2311 PAGE
2312 SUBTTL FLOATING POINT INPUT ROUTINE
2313 ; ALTERS ALL REGISTERS
2314 ; THE NUMBER IS LEFT IN FAC
2315 ; AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
2316 ; THE FIRST CHARACTER IS ALSO IN A. WE PACK THE DIGITS INTO THE FAC
2317 ; AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
2318 ; C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE,
2319 ; B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
2320 ; AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
2321 ; TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
2322 FIN:
2323 IFN STRING,<
2324 ; IF WE ARE CALLED BY VAL, THE SIGNS MAY NOT BE CRUNCHED
2325 CPI "-" ;SEE IF NUMBER IS NEGATIVE
2326
2327 PUSH PSW ;SAVE SIGN
2328 JZ FIN1 ;IGNORE MINUS SIGN
2329
2330
2331 CPI "+" ;IGNORE A LEADING SIGN
2332
2333 JZ FIN1>
2334
2335
2336 DCX H ;SET CHARACTER POINTER BACK ONE
2337 FIN1:
2338 IFN LENGTH-2,<
2339 CALL ZERO ;CLEAR FAC
2340
2341
2342 MOV B,A ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
2343 MOV D,A ;D=SIGN OF EXPONENT
2344 MOV E,A ;E=EXPONENT
2345 CMA
2346 MOV C,A ;C="." FLAG
2347 ; HERE TO GET THE NEXT DIGIT OF THE NUMBER, A DECIMAL POINT OR AN "E"
2348 FINC: CHRGET ;GET A CHARACTER
2349 JC FINDIG ;DO WE HAVE A DIGIT?
2350
2351
2352 CPI "," ;TEST FOR DECIMAL POINT
2353
2354 JZ FINDP
2355
2356
2357 CPI "E" ;CHECK FOR BEGINNING OF EXPONENT
2358
2359 JNZ FINE ;"NONE OF THE ABOVE" SO END OF NUMBER
2360
2361
2362 ; HERE TO CHECK FOR THE SIGN OF THE EXPONENT
2363 CHRGET ;CHECK FOR ITS SIGN
2364 IFN STRING,<
2365 PUSH H ;SAVE TEXT POINTER
2366 LXI H,FINEC ;PUT FINEC ON STACK SO WE CAN JUMP
2367
2368
2369 XTHL> ;TO IT IN LESS BYTES
2370 DCR D ;SET SIGN OF EXPONENT FLAG
2371 CPI MINUTK ;NEGATIVE EXPONENT?
2372
2373 IFE STRING,<
2374 JZ FINEC>
2375 IFN STRING,<
2376 RZ
2377 CPI "-"
2378
2379 RZ>
2380 INR D ;NO, RESET FLAG
2381 IFN STRING,<
2382 CPI "+"
2383
2384 RZ>
2385 CPI PLUSTK ;IGNORE "+"
2386
2387 IFE STRING,<
2388 JZ FINEC>
2389 IFN STRING,<
2390 RZ
2391 POP PSW> ;GET FINEC OFF STACK
2392 DCX H ;CHECK IF LAST CHARACTER WAS A DIGIT
2393 ; HERE TO GET THE NEXT DIGIT OF THE EXPONENT
2394 FINEC: CHRGET ;GET NEXT CHARACTER
2395 JC FINEDG ;IS IT A DIGIT?
2396
2397
2398 INR D ;NO, EXPONENT ALL IN
2399 JNZ FINE ;SET ITS SIGN
2400
2401
2402 XRA A
2403 SUB E
2404 MOV E,A
2405 INR C ;MAKE SURE C IS NOT 377
2406 ; HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL POINTS AND SET THE DECIMAL
2407 ; POINT FLAG
2408 FINDP: INR C ;DECIMAL POINTS -- SET FLAG
2409 JZ FINC ;CONTINUE SCANNING CHARACTERS
2410
2411
2412 ;WE DON'T WANT TWO SO END OF NUMBER
2413 ; HERE TO MULTIPLY OR DIVIDE BY 10 THE CORRECT NUMBER OF TIMES.
2414 ; WE HAVE ALREADY READ IN ALL THE DIGITS.
2415 FINE: PUSH H ;SAVE POINTER FOR LATER
2416 MOV A,E ;EXPONENT=EXPONENT-# OF DECIMAL PLACES
2417 SUB B
2418 FINE2: CP FINMUL ;MULTIPLY BY TEN IF EXPONENT IS POSITIVE
2419
2420
2421 JP FINE3 ;DIVIDE BY TEN IF EXPONENT IS NEGATIVE
2422
2423
2424 PUSH PSW ;SAVE EXPONENT
2425 CALL DIV10 ;DIVIDE NUMBER BY TEN
2426
2427
2428 POP PSW ;GET EXPONENT
2429 INR A ;INCREMENT IT
2430 FINE3: JNZ FINE2 ;DO AGAIN IF WE ARE NOT DONE
2431
2432
2433 IFE STRING,<
2434 POP H> ;GET CHARACTER POINTER
2435 IFN STRING,<
2436 POP D ;GET CHARACTER POINTER
2437 POP PSW ;GET SIGN
2438 CZ NEG ;NEGATE IF NECESSARY
2439
2440
2441 XCHG> ;GET CHARACTER POINTER IN (HL)
2442 RET> ;ALL DONE
2443 IFE LENGTH-2,<
2444 XCHG ;SAVE THE TEXT POINTER IN (DE)
2445 LXI B,377+$CODE ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
2446 ;C="." FLAG
2447 MOV H,C ;ZERO (HL)
2448 MOV L,C
2449 CALL CONISS ;ZERO FAC, SET VALTYP TO "INTEGER"
2450 XCHG ;GET THE TEXT POINTER BACK IN (HL)
2451 ; HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
2452 FINC: CHRGET ;GET THE NEXT CHARACTER OF THE NUMBER
2453 JC FINDIG ;WE HAVE A DIGIT
2454 CPI "." ;CHECK FOR A DECIMAL POINT
2455 JZ FINDP ;WE HAVE ONE, I GUESS
2456 CPI "E" ;CHECK FOR A SINGLE PRECISION EXPONENT
2457 JZ FINEX ;WE HAVE A SINGLE PRECISION NUMBER
2458 CPI "D" ;CHECK FOR A DOUBLE PRECISION EXPONENT
2459 JNZ FINE ;WE DON'T HAVE ONE, THE NUMBER IS FINISHED
2460 OKA A ;DOUBLE PRECISION NUMBER -- TURN OFF ZERO FLAG
2461 FINEX: CALL INFRC ;FORCE THE FAC TO BE SNG OR DBL
2462 PUSH H ;SAVE THE TEXT POINTER
2463 LXI H,FINEC ;GET ADDRESS TO JUMP TO, THIS IS TO SAVE BYTES
2464 XTHL ;PUT IT ON STACK AND GET TEXT POINTER
2465 ; HERE TO CHECK FOR THE SIGN OF THE EXPONENT
2466 CHRGET ;GET THE FIRST CHARACTER OF THE EXPONENT
2467 DCR D ;SET SIGN OF EXPONENT TO MINUS
2468 CPI MINUTK ;CHECK IF THE EXPONENT IS NEGATIVE
2469 RZ ;IT IS
2470 CPI ;THIS IS IN CASE WE ARE CALLED BY VAL
2471 RZ
2472 INR D ;EXPONENT IS STILL POSITIVE, RESET FLAG
2473 CPI PLUSTK ;IGNORE A LEADING PLUS SIGN
2474 RZ
2475 CPI "+"
2476 RZ
2477 DCX H ;THE FIRST CHARACTER WAS NOT A SIGN, GO BACK
2478 ;AND CHECK FOR A DIGIT
2479 POP PSW ;POP FINEC OFF THE STACK, WE NO LONGER NEED IT
2480 ; HERE TO GET THE NEXT DIGIT OF THE EXPONENT
2481 FINEC: CHRGET ;GET THE NEXT CHARATER
2482 JC FINEDG ;PACK THE NEXT DIGIT INTO THE EXPONENT
2483 INR D ;IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
2484 JNZ FINE ;THE EXPONENT, IT IS POSITIVE
2485 XRA A ;THE EXPONENT IS NEGATIVE
2486 SUB E ;NEGATE IT
2487 MOV E,A ;SAVE IT AGAIN
2488 ; HERE TO FINISH UP THE NUMBER
2489 FINE: LDA VALTYP ;FINISH UP -- WHAT KIND OF A NUMBER IS IT?
2490 CPI 2
2491 JNZ FINEF ;IT IS A FLOATING POINT ONE
2492 ; HERE TO FINISH UP AN INTEGER
2493 POP PSW ;IT IS AN INTEGER, GET ITS SIGN
2494 XCHG ;SAVE THE TEXT POINTER IN (DE)
2495 C2 INEG ;NEGATE IT IF NECESSARY
2496 XCHG ;GET THE TEXT POINTER BACK IN (HL)
2497 RET ;ALL DONE
2498 ; HERE TO FINISH UP A FLOATING POINT NUMBER
2499 FINEF: PUSH H ;SAVE THE TEXT POINTER
2500 MOV A,E ;FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
2501 SUB B ;OR DIVIDE BY TEN
2502 ; HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES
2503 FINEF2: CP FINMUL ;MULTIPLY IF WE HAVE TO
2504 CM FINDIV ;DIVIDE IF WE HAVE TO
2505 JNZ FINEF2 ;MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
2506 ; HERE TO PUT THE CORRECT SIGN ON THE NUMBER
2507 POP D ;GET THE TEXT POINTER
2508 POP PSW ;GET THE SIGN
2509 CZ NEG ;NEGATE IF NECESSARY
2510 XCHG ;GET THE TEXT POINTER IN (HL)
2511 LDA VALTYP ;WE WANT -32768 TO BE AN INT, BUT UNTIL NOW
2512 CPI 4 ;IT WOULD BE A SNG
2513 RNZ ;IT IS NOT SNG, SO IT IS NOT -32768
2514 PUSH H ;WE HAVE A SNG, SAVE TEXT POINTER
2515 LXI H,POPHRT ;GET ADDRESS THAT POP'S H OFF STACK BECAUSE
2516 PUSH H ;CONIS2 DOES FUNNY THINGS WITH THE STACK
2517 CALL CONIS2 ;CHECK IF WE HAVE -32768
2518 RET ;WE DON'T, POPHRT IS STILL ON THE STACK SO
2519 ;WE CAN JUST RETURN
2520
2521 ; HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL POINTS AND SET THE DECIMAL
2522 ; POINT FLAG
2523 FINDP: INR C ;SET THE FLAG
2524 JNZ FINEF ;WE HAD 2 DECIMAL POINTS, NOW WE ARE DONE
2525 CALL FINFRC ;THIS IS THE FIRST ONE, CONVERT FAC TO SNG
2526 JMP FINC ;CONTINUE LOOKING FOR DIGITS
2527
2528 ; FORCE THE FAC TO BE SNG OR DBL
2529 ; IF THE ZERO FLAG IS ON, THEN FORCE THE FAC TO BE SNG
2530 ; IF THE ZERO FLAG IS OFF, FORCE THE FAC TO BE DBL
2531 FINFRC: PUSH H ;SAVE TEXT POINTER
2532 PUSH D ;SAVE EXPONENT INFORMATION
2533 PUSH B ;SAVE DECIMAL POINT INFORMATION
2534 PUSH PSW ;SAVE WHAT WE WANT THE FAC TO BE
2535 CZ FRCSNG ;CONVERT TO SNG IF WE HAVE TO
2536 POP PSW ;GET TYPE FLAG BACK
2537 CNZ FRCOBL ;CONVERT TO DBL IF WE HAVE TO
2538 POP B ;GET DECIMAL POINT INFORMATION BACK
2539 POP D ;GET EXPONENT INFORMATION BACK
2540 POP H ;GET TEXT POINTER BACK
2541 RET> ;ALL DONE
2542
2543 ; THIS SUBROUTINE MULIPLIES BY TEN ONCE.
2544 ; IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
2545 FINMUL: RZ ;RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
2546 FINMLT: PUSH PSW ;SAVE EXPONENT, ENTRY FROM FOUT
2547 IFN LENGTH-2,<
2548 CALL MUL10> ;MULTIPLY BY TEN
2549
2550
2551 IFE LENGTH-2,<
2552 LDA VALTYP ;SEE WHAT KIND OF NUMBER WE HAVE
2553 CPI 4
2554 PUSH PSW ;SAVE THE TYPE
2555 CZ MUL10 ;WE HAVE A SNG, MULTIPLY BY 10.0
2556 POP PSW ;GET THE TYPE BACK
2557 CNZ DMUL10> ;WE HAVE A DBL, MULTIPLY BY 1000
2558 POP PSW ;GET EXPONENT
2559 DCRART: DCR A ;DECREASE IT
2560 RET ;ALL DONE
2561
2562 IFE LENGTH-2,<
2563 FINDIV: PUSH PSW ;WE HAVE TO DIVIDE -- SAVE COUNT
2564 LDA VALTYP ;SEE WHAT KIND OF NUMBER WE HAVE
2565 CPI 4
2566 PUSH PSW ;SAVE THE TYPE
2567 CZ DIV10 ;WE HAVE A SNG NUMBER
2568 POP PSW ;GET THE TYPE BACK
2569 CNZ DDIV10 ;WE HAVE A DBL NUMBER
2570 POP PSW ;GET COUNT BACK
2571 INR A ;UPDATE IT
2572 RET>
2573
2574 ; HERE TO PACK THE NEXT DIGIT OF THE NUMBER INTO THE FAC
2575 ; WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
2576 FINDIG:
2577 IFN LENGTH-2,<
2578 PUSH D ;DIGITS: SAVE EXPONENT INFORMATION
2579 MOV D,A ;PROTECT DIGIT FROM BELOW
2580 MOV A,B ;INCREMENT DECIMAL PLACE COUNT
2581 ADC C ;IF PAST THE DECIMAL POINT
2582 MOV B,A
2583 PUSH B ;SAVE NECESSARY DATA
2584 PUSH H
2585 PUSH D ;SAVE DIGIT
2586 CALL MUL10 ;MULTIPLY OLD NUMBER BY 10
2587
2588
2589 POP PSW ;GET NEXT DIGIT
2590 SUI "0" ;SUBTRACT OFF ASCII CODE
2591
2592 IFE EXTFNC,<
2593 CALL PUSHF ;PUT NUMBER ON STACK
2594 CALL FLOAT ;CONVERT TO FLOATING POINT NUMBER
2595 POPR
2596 CALL FADD> ;ADD IN NEXT DIGIT
2597 IFN EXTFNC,<
2598 CALL FINLOG>
2599
2600
2601 POP H ;RECALL DATA
2602 POP B
2603 POP D
2604 JMP FINC> ;GET NEXT CHARACTER
2605
2606
2607 IFE LENGTH-2,<
2608 PUSH D ;SAVE EXPONENT INFORMATION
2609 MOV A,B ;INCREMENT DECIMAL PLACE COUNT IF WE ARE
2610 ADC C ;PAST THE DECIMAL POINT
2611 MOV B,A
2612 PUSH B ;SAVE DECIMAL POINT INFORMATION
2613 PUSH H ;SAVE TEXT POINTER
2614 MOV A,M ;GET THE DIGIT
2615 SUI "0" ;CONVERT IT TO ASCII
2616 PUSH PSW ;SAVE THE DIGIT
2617 LDA VALTYP ;SEE WHAT KIND OF A NUMBER WE HAVE
2618 CPI 4
2619 JNC FINDGV ;WE DO NOT HAVE AN INTEGER
2620 ; HERE TO PACK THE NEXT DIGIT OF AN INTEGER
2621 LALD FACLO ;WE HAVE AN INTEGER, GET IT IN (HL)
2622 LXI D,^D3277+$CODE ;SEE IF WE WILL OVERFLOW
2623 COMPAR ;COMPAR RETURNS WITH CARRY ON IF
2624 JNC FINDG2 ;(HL) .LT. (DE), SO THE NUMBER IS TOO BIG
2625 MOV D,H ;COPY (HL) INTO (DE)
2626 MOV E,L
2627 DAD H ;MULTIPLY (HL) BY 2
2628 DAD H ;MULTIPLY (HL) BY 2, (HL) NOW IS 4*(DE)
2629 DAD D ;ADD IN OLD (HL) TO GET 5* (DE)
2630 DAD H ;MULTIPLY BY 2 TO GET TEN TIMES THE OLD (HL)
2631 POP PSW ;GET THE DIGIT
2632 MOV C,A ;SAVE IT SO WE CAN USE DAD, B IS ALREADY ZERO
2633 DAD B ;ADD IN THE NEXT DIGIT
2634 MOV A,H ;CHECK FOR OVERFLOW
2635 ORA A ;OVERFLOW OCCURED IF THE MSB IS ON
2636 JM FINDGI ;WE HAVE OVERFLOW!!
2637 SHLD FACLO ;EVERYTHING IS FINE, STORE THE NEW NUMBER
2638 FINDGE: POP H ;ALL DONE, GET TEXT POINTER BACK
2639 PDP B ;GET DECIMAL POINT INFORMATION BACK
2640 POP D ;GET EXPONENT INFORMATION BACK
2641 JMP FINC ;GET THE NEXT CHARACTER
2642 ; HERE TO HANDLE 32768, 32769
2643 FINDGI: MOV A,C ;GET THE DIGIT
2644 PUSH PSW ;PUT IT BACK ON THE STACK
2645 ; HERE TO CONVERT THE INTEGER DIGITS TO SINGLE PRECISION DIGITS
2646 FINDG2: CALL CONSI ;CONVERT THE INTEGER TO SINGLE PRECISION
2647 XRA A ;DO NOT TAKE THE FOLLOWING JUMP
2648 ; HERE TO DECIDE IF WE HAVE A SINGLE OR DOUBLE PRECISION NUMBER
2649 FINDGV: JNZ FINDGO ;FALL THROUGH IF VALTYP WAS 4 I.E. SNG PREC
2650 MOVRI 24,164,044,000 ;GET 1000000, DO WE HAVE 7 DIGITS ALREADY?
2651 CALL FCOMP ;IF SO, FAC .GE. 1000000
2652 JP FINDG3 ;WE DO, CONVERT TO DOUBLE PRECISION
2653 POP PSW ;GET THE NEXT DIGIT
2654 CALL FINLOG ;PACK IT INTO THE FAC
2655 JMP FINDGE ;GET FLAGS OFF STACK AND WE ARE DONE
2656 ; HERE TO CONVERT A 7 DIGIT SINGLE PRECISION NUMBER TO DOUBLE PRECISION
2657 FINDG3: CALL CONDS ;CONVERT SINGLE TO DOUBLE PRECISION
2658 ; HERE TO PACK IN THE NEXT DIGIT OF A DOUBLE PRECISION NUMBER
2659 FINDGO: CALL DMUL10 ;MULTIPLY THE FAC BY 10
2660 CALL VMOVAF ;SAVE THE FAC IN ARG
2661 POP PSW ;GET THE NEXT DIGIT
2662 CALL FLOAT ;CONVERT THE DIGIT TO SINGLE PRECISION
2663 CALL CONDS ;NOW, CONVERT THE DIGIT TO DOUBLE PRECISION
2664 CALL DADD ;ADD IN THE DIGIT
2665 JMP FINDGE ;GET THE FLAGS OFF THE STACK AND WE ARE DONE
2666
2667 IFN EXTFNC,<
2668 ; SUBROUTINE FOR FIN, LOG
2669 FINLOG: CALL PUSHF ;SAVE FAC ON STACK
2670
2671
2672 CALL FLOAT ;CONVERT A TO A FLOATING POINT NUMBER
2673
2674
2675 IFN LENGTH-2,<
2676 JMP FADDT> ;ADD IT IN
2677
2678
2679 IFE LENGTH-2,<
2680 POPR ;GET PREVIOUS NUMBER OFF STACK
2681 JMP FADD>> ;ADD IT IN
2682
2683 ; HERE WE PACK IN THE NEXT DIGIT OF THE EXPONENT
2684 ; WE MUTIPLY THE OLD EXPONENT BY TEN AND ADD IN THE NEXT DIGIT
2685 ; NOTE: EXPONENT OVERFLOW IS NOT CHECKED FOR
2686 FINEDG: MOV A,E ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
2687 RLC ;FIRST BY 4
2688 RLC
2689 ADD E ;ADD 1 TO MAKE 5
2690 RLC ;NOW DOUBLE TO GET 10
2691 ADD M ;ADD IT IN
2692 SUI "0" ;SUBTRACT OFF ASCII CODE
2693
2694 MOV E,A ;STORE EXPONENT
2695 JMP FINEC ;CONTINUE
2696
2697
2698 PAGE
2699 SUBTTL FLOATING POINT OUTPUT ROUTINE
2700 ; ENTRY TO LINPRT
2701 INPRT: PUSH H ;SAVE LINE NUMBER
2702 LXI H,INTXT## ;PRINT MESSAGE
2703
2704
2705 CALL STROUT
2706
2707
2708 POP H ;FALL INTO LINPRT
2709
2710
2711 ; PRINT THE 2 BYTE NUMBER IN H,L
2712 ; ALTERS ALL REGISTERS
2713 LINPRT:
2714 IFN LENGTH-2,<
2715 XCHG ;SET UP REGISTERS FOR FLOATR
2716 XRA A
2717 MVI B,230
2718
2719 CALL FLOATR ;CONVERT TO FLOATING POINT
2720
2721
2722 IFE LENGTH-2,<
2723 CALL CONISS ;PUT THE LINE NUMBER IN THE FAC AS AN INTEGER
2724 XRA A ;SET FORMAT TO FREE FORMAT
2725 CALL FOUINI ;SET UP THE SIGN
2726 LXI H,STROUI## ;PUT PRINT STRING ADDRESS ON STACK SO WE WILL
2727
2728
2729 PUSH ;RETURN TO IT AND DO AN "INX H"
2730 ;THIS GETS RID OF THE SPACE FOR THE SIGN AT
2731 ;THE BEGINNING OF A LINE NUMBER
2732 ;FALL INTO FOUT
2733 IFE LENGTH-2,<
2734 PUSH B ;PUT DUMMY FIELD LENGTHS ON STACK
2735 JMP STROUI## ;PRINT THE NUMBER
2736
2737
2738 ; FLOATING OUTPUT OF FAC
2739 ; ALTERS ALL REGISTERS
2740 ; THE ORIGINAL CONTENTS OF THE FAC IS LOST
2741 IFN LENGTH-2,<
2742 FOUT: LXI H,FBUFFR ;GET BEGINING OF CHARACTER BUFFER
2743
2744
2745 PUSH H ;SAVE IT FOR WHEN WE RETURN
2746 ;PUT THE SIGN OF THE NUMBER IN THE BUFFER AND MAKE IT POSITIVE
2747 FSIGN ;GET SIGN OF NUMBER
2748 MVI M," " ;PRINT SPACE IF POSITIVE
2749
2750 JP FOUT1
2751
2752
2753 MVI M,"-" ;PRINT A MINUS SIGN IF NEGATIVE
2754
2755 FOUT1: INX H ;INCREMENT POINTER 10 NEXT CHRACTER POSITION
2756 MVI M,"0" ;PUT A ZERO IN BUFFER IN CASE NUMBER=0
2757
2758 JZ FOUT19 ;DO IT IF THE NUMBER IS ZERO
2759
2760
2761 PUSH H ;SAVE BUFFER POINTER
2762 CM NEG ;NEGATE NUMBER IF NEGATIVE
2763
2764
2765
2766 ; THERE WE GET THE FAC IN THE RANGE 100000 .LE. FAC .LE. 999999 AND ROUND IT TO
2767 ; AN INTEGER. WE KEEP A COUNT OF HOW MANY TIMES WE MULTIPLY OR DIVIDE BY TEN
2768 ; SO WE KNOW WHAT THE EXPONENT WILL BE. THE FAC IS THEN CONVERTED TO AN .
2769 ; INTEGER IN C,D,E, WE USE A TABLE OF POWERS OF TEN TO CALCULATE EACH DIGIT.
2770 ; THIS ALGORITHM IS USED FOR SPEED.
2771 XRA A ;PUT TEN'S EXPONENT COUNT ON STACK
2772 PUSH PSW
2773 CALL FOUTCB ;SEE IF NUMBER IS TOO BIG OR TOO SMALL
2774
2775
2776 FOUT3: MOVRI 221,103,117,370 ;IS NUMBER .LE. 99999.94997 IT IS TOO SMALL
2777
2778
2779
2780
2781
2782 CALL FCOMP ;FCOMP RETURNS 377, 0 OR 1 IN A, SO THE
2783
2784
2785 ;PARITY WILL BE ODD IFF 1 IS RETURNED
2786 JPO FOUTS ;NO, NUMBER IS IN RANGE
2787
2788
2789 POP PSW
2790 CALL FINMLT ;YES, MULTIPLY IT BY TEN TO GET
2791
2792
2793 PUSH PSW ;IT IN RANGE
2794 JMP FOUT3 ;SEE IF NUMBER IS NOW IN RANGE
2795
2796
2797 FOUT9: CALL DIV10 ;NO, DIVIDE NUMBER BY TEN, IT IS TOO BIG
2798
2799
2800 POP PSW ;ADD ONE TO EXPONENT
2801 INR A
2802 PUSH PSW
2803 CALL FOUTCB ;IS NUMBER .LE. 999999.499?
2804
2805
2806 ;YES, NUMBER IS IN PRINTING RANGE, I.E.
2807 ;ALL DIGITS TO BE PRINTED ARE THE INTEGER PART
2808
2809 FOUTS: CALL FADDH ;ROUND NUMBER TO NEAREST INTEGER
2810
2811
2812 INR A ;MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE
2813 ;AND NON-ZERO, ROUND WILL EXIT WITH THE HO
2814 ;IN A, SO THE MSB WILL ALWAYS BE ZERO AND
2815 ;ADDING ONE WILL NEVER CAUSE A TO BE ZERO
2816 CALL QINT ;GET INTEGER PART IN C,D,E
2817
2818
2819 CALL MOVFR ;SAVE NUMBER IN FAC
2820
2821
2822 ; DECIDE IF THE NUMBER SHOULD BE PRINTED IN FIXED OR FLOATING NOTATION
2823 LXI B,2*400+6+$CODE ;SET DECIMAL POINT COUNT FOR E NOTATION
2824
2825
2826 ;C = DIGIT COUNT
2827 POP PSW ;GET EXPONENT
2828 ADD C ;NUMBER PRINTED IN E NOTATION?
2829
2830 JM FOUT6 ;YES, IT IS .LT. .1
2831
2832
2833 CPI 7
2834
2835 JNC FOUT6 ;YES, IT IS .GT. 999999
2836
2837
2838 INR A
2839 MOV B,A ;B = DECIMAL POINT COUNT
2840 MVI A,1 ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
2841
2842 ;IF WE ARE USING FIXED POINT NOTATION
2843 FOUT6: DCR A ;E NOTATION: ADD 5 10 ORIGINAL EXPONENT
2844 POP H ;GET BUFFER POINTER FROM STACK
2845 PUSH PSW ;SAVE EXPONENT FOR LATER
2846 ;CALCULATE THE DIGITS OF THE NUMBER
2847 LXI D,FOUTBL ;STORE LOC OF LARGEST POWER OF TEN
2848
2849
2850 FOUT8: DCR B ;SEE IF IT IS TIME TO PRINT A DECIMAL POINT
2851 MVI M,"." ;PUT A DECIMAL POINT IN THE BUFFER
2852
2853 CZ INXHRT ;INCREMENT THE BUFFER POINTER IF IT IS TIME
2854
2855
2856 PUSH B ;SAVE FLAGS
2857 PUSH H ;SAVE CHARACTER POINTER
2858 PUSH D ;SAVE POWER OF TEN POINTER
2859 CALL MOVRF ;GET NUMBER IN C,D,E
2860
2861
2862 POP H ;GET POWER OF TEN POINTER .
2863 MVI B,"0"-1 ;B = NEXT DIGIT TO BE PRINTED
2864
2865 FOUT10: INR B ;ADD ONE TO DIGIT
2866 MOV A,E ;SUBTRACT LO
2867 SUB M
2868 MOV E,A
2869 INX H ;POINT TO NEXT BYTE OF POWER OF TEN
2870 MOV A,D ;SUBTRACT MO
2871 SBB M
2872 MOV D,A
2873 INX H
2874 MOV A,C ;SUBTRACT HO
2875 SBB M
2876 MOV C,A
2877 DCX H ;POINT TO BEGINNING OF POWER OF TEN
2878 DCX H
2879 JNC FOUT10 ;SUBTRACT AGAIN IF RESULT WAS POSITIVE
2880
2881
2882 CALL FADDA ;IT WASN'T, ADD POWER OF TEN BACK IN
2883
2884
2885 INX H ;INCREMENT POINTER TO NEXT POWER OF TEN
2886 CALL MOVFR ;SAVE C,D,E IN FAC
2887
2888
2889 XCHG ;GET POWER OF TEN POINTER IN (DE)
2890 POP H ;GET BUFFER POINTER
2891 MOV M,B ;PUT CHARACTER IN BUFFER
2892 INX H ;INCREMENT BUFFER POINTER
2893 POP B ;GET COUNTERS OFF STACK
2894 OCR C ;WAS THAT THE LAST DIGIT?
2895 JNZ FOUT8 ;DO MORE IF NOT
2896
2897
2898 DCR B ;SEE IF DECIMAL POINT GOES AFTER LAST DIGIT
2899 JZ FOUT12 ;IT DOES, WE HAVE NO ZEROS TO SUPPRESS
2900
2901
2902 ;SUPPRESS THE TRAILING ZEROS
2903 FOUT11: DCX H ;GO BACK TO LAST CHARACTER
2904 MOV A,M ;GET IT
2905 CPI "0" ;IGNORE TRAILING ZEROS
2906
2907 JZ FOUT11
2908
2909
2910 ; SUPPRESS DECIMAL POINT IF WE HAVE AN INTEGER
2911 CPI "," ;IGNORE DECIMAL POINT BEFORE TRAILING ZEROS
2912
2913 CNZ INXHRT ;IF NO DP, MOVE POINTER TO NEXT POSITION
2914
2915
2916 FOUT12: POP PSW ;GET DECIMAL EXPONENT
2917 JZ FOUT17 ;RETURN IF NUMBER WAS IN FIXED POINT FORMAT
2918
2919
2920 ; FLOATING POINT NOTATION -- PUT AN "E" IN THE BUFFER
2921 MVI M,"E" ;PUT AN "E" IN THE BUFFER
2922
2923 INX H ;PUT SIGN OF EXPONENT IN BUFFER
2924 ; PUT IN THE SIGN OF THE EXPONENT
2925 MVI M,"+" ;A PLUS IF POSITIVE
2926
2927 JP FOUT14
2928
2929
2930 MVI M,"-" ;A MINUS IF NEGATIVE
2931
2932 CMA ;NEGATE EXPONENT
2933 INR A
2934 ; CALCULATE THE TWO DIGIT EXPONENT
2935 FOUT14: MVI B,"0"-1 ;INITIALIZE TEN'S DIGIT COUNT
2936
2937 FOUT15: INR B ;INCREMENT DIGIT
2938 SUI 12 ;SUBTRACT TEN
2939
2940 JNC FOUT15 ;DO IT AGAIN IF RESULT WAS POSITIVE
2941
2942
2943 ADI "0"+12 ;ADD BACK IN TEN AND CONVERT TO ASCII
2944
2945 ; PUT THE EXPONENT IN THE BUFFER
2946 INX H
2947 MOV M,B ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
2948 FOUT19: INX H ;WHEN WE JUMP TO HERE, A IS ZERO
2949 MOV M,A ;PUT ONE'S DIGIT IN BUFFER
2950 INX H ;INCREMENT POINTER
2951 FOUT17: MOV M,C ;PUT ZERO AT END OF BUFFER
2952 POP H ;EXIT WITH (HL) POINTING TO STRING
2953 RET ;ALL DONE
2954
2955 ; SEE IF FAC .LE. 999999.499
2956 FOUTCB: MOVRI 224,164,043,367 ;COMPARE NUMBER WITH CONSTANT
2957
2958
2959
2960
2961
2962 CALL FCOMP
2963
2964
2965 POP H ;GET RETURN ADDRESS OFF STACK
2966 JPO FOUT9 ;NUMBER TOO BIG, DIVIDE BY TEN
2967
2968
2969 PCHL ;NUMBER OK, RETURN
2970
2971 ;CONSTANTS FOR FOUT
2972 FHALF: 000 ;1/2
2973 000 ;THIS CONSTANT IS ALSO USED BY SQR, SIN, COS
2974 000
2975 200
2976 ;POWER OF TEN TABLE
2977 FOUTBL: 240 ;100000
2978 206
2979 001
2980 020 ;10000
2981 047
2982 000
2983 350 ;1000
2984 003
2985 000
2986 144 ;100
2987 000
2988 000
2989 012 ;10
2990 000
2991 000
2992 001
2993 000
2994 000>
2995 IFE LENGTH-2,<
2996 ; OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
2997 ; IN A,B,C
2998 ; ALL REGISTERS ARE ALTERED
2999 ; THE ORIGINAL CONTENTS OF THE FAC IS LOST
3000
3001 ; THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
3002 ; THE BITS OF A MEAN THE FOLLOWING:
3003 ; BIT 7 0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
3004 ;       TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
3005
3006 ;       POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
3007 ;       JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
3008 ;       1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
3009 ;       FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
3010 ;       TRAILING ZEROS ARE NOT SUPPRESSED. THIS IS USED FOR PRINT USING.
3011 ; BIT 6 1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
3012 ;       OF THREE AND SEPARATE THE GROUPS BY COMMAS
3013 ;       0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
3014 ; BIT 5 1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
3015 ; BIT 4 1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
3016 ; BIT 3 1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
3017 ;       INSTEAD OF A SPACE
3018 ; BIT 2 1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
3019 ; BIT 1 UNUSED
3020 ; BIT 0 1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
3021 ;       IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
3022 ;       0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION. NUMBER .GE. 1E16
3023 ;       CANNOT BE PRINTED IN FIXED POINT NOTATION.
3024
3025 ; B AND C TELL HOW BIG THE FIELD IS:
3026 ; B = THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
3027 ;     (B DOES NOT INCLUDE THE DECIMAL POINT)
3028 ; C = THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
3029 ;     (C INCLUDES THE DECIMAL POINT)
3030 ; B AND C DONOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
3031 ; FOUT ASSUMES B+C .LE. 24 (DECIMAL)
3032
3033 ; ENTRY TO PRINT THE FAC IN FREE FORMAT
3034 FOUT: XRA A ;SET FORMAT FLAGS TO FREE FORMATED OUTPUT
3035 ;ENTRY TO PRINT THE FAC USING THE FORMAT SPECIFICATIONS IN A, B AND C
3036 PUFOUT: CALL FOUINI ;SAVE THE FORMAT SPECIFICATION IN A AND PUT
3037 ;A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
3038 PUSH B ;SAVE THE FIELD LENGTH SPECIFICATIONS
3039 ANI 10 ;CHECK IF POSITIVE NUMBERS GET A PLUS SIGN
3040 JZ FOUT1 ;THEY DON'T
3041 MVI M,"+" ;THEY DO, PUT IN A PLUS SIGN
3042 FOUT1: LOA VALTYP ;SEE WHAT KIND OF A VALUE WE HAVE
3043 MOV B,A ;SAVE IT
3044 XCHG ;SAVE BUFFER POINTER
3045 CALL VSIGN ;GET THE SIGN OF THE FAC
3046 XCHG ;PUT THE BUFFER POINTER BACK IN (HL)
3047 MOV A,B ;GET THE VALTYP BACK
3048 JP FOUT2 ;IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
3049 MVI M,"-" ;AND PUT A MINUS SIGN IN THE BUFFER
3050 PUSH H ;SAVE THE BUFFER POINTER
3051 CALL VNEG ;NEGATE THE NUMBER
3052 POP H ;GET THE BUFFER POINTER BACK
3053 FOUT2: INX H ;POINT TO WHERE THE NEXT CHARACTER GOES
3054 LDA TEMP3 ;GET THE FORMAT SPECIFICATION
3055 MOV D,A ;SAVE IT FOR LATER
3056 RAL ;PUT THE FREE FORMAT OR NOT BIT IN THE CARRY
3057 LDA VALTYP ;GET THE VALTYP, VNEG COULD HAVE CHANGED THIS
3058 ;SINCE -32768 IS INT AND 32768 IS SNG,
3059 ;SO B IS NOT ACCURATE
3060 JC FOUTFX ;THE MAN WANTS FIXED FORMATED OUTPUT
3061 ;HERE TO PRINT NUMBERS IN FREE FORMAT
3062 POP B ;WE CAN IGNORE THE OLD B AND C
3063 MVI M,"0" ;PUT A ZERO IN THE BUFFER IN CASE THE NUMBER
3064 JZ FOUTZR ;IS ZERO. IT IS, FINISH IT UP
3065 CPI 4 ;DECIDE WHAT KIND OF A VALUE WE HAVE
3066 JNC FOUFRV ;WE HAVE A SNG OR DBL
3067 ;HERE TO PRINT AN INTEGER IN FREE FORMAT
3068 LXI B,$CODE ;SET THE DECIMAL POINT COUNT AND COMMA COUNT
3069 TO ZERO
3070 CALL FOUTCI ;CONVERT THE INTEGER TO DECIMAL
3071 ;FALL INTO FOUTZS AND ZERO SUPPRESS THE THING
3072
3073 ; ZERO SUPPRESS THE DIGITS IN FBUFFR
3074 ; ASTERISK FILL AND ZERO SUPPRESS IF NECESSARY
3075 ; SET UP B AND CONDITION CODES IF WE HAVE A TRAILING SIGN
3076 FOUTZS: LXI H,FBUFFR+1 ;GET POINTER TO THE SIGN
3077 MOV B,M ;SAVE THE SIGN IN B
3078 MVI C," " ;DEFAULT FILL CHARACTER TO A SPACE
3079 LDA TEMP3 ;GET FORMAT SPECS TO SEE IF WE HAVE TO
3080 MQV E,A ;ASTERISK FILL, SAVE IT
3081 ANI 40
3082 JZ FOTZS1 ;WE DON'T
3083 MOV A,B ;WE DO, SEE IF THE SIGN WAS A SPACE
3084 CMP C ;ZERO FLAG IS SET IF IT WAS
3085 MVI C,"*" ;SET FILL CHARACTER TO AN ASTERISK
3086 JNZ FOTZS1 ;SET THE SIGN TO AN ASTERISK IF IT WAS A SPACE
3087 MOV B,C ;B HAS THE SIGN, C THE FILL CHARACTER
3088 FOTZS1: MOV M,C ;FILL IN THE ZERO OR THE SIGN
3089 CHRGET ;GET THE NEXT CHARACTER IN THE BUFFER
3090 ;SINCE THERE ARE NO SPACES, "CHRGET" IS
3091 ;EQUIVALENT TO "INX H"/"MOV A,M"
3092 CPI "0" ;DO WE HAVE A ZERO?
3093 JZ FOTZS1 ;YES, SUPPRESS IT
3094 CPI 54 ;54="," DO WE HAVE A COMMA?
3095 JZ FOTZS1 ;YES, SUPPRESS IT
3096 CPI "." ;ARE WE AT THE DECIMAL POINT?
3097 JNZ FOTZS2 ;NO, I GUESS NOT
3098 DCX H ;YES, BACK UP AND PUT A ZERO BEFORE IT
3099 MVI M,"0"
3100 FOTZS2: MOV A,E ;GET THE FORMAT SPECS TO CHECK FOR A FLOATING
3101 ANI 20 ;DOLLAR SIGN
3102 JZ FOTZS3 ;WE DON'T HAVE ONE
3103 DCX H ;WE HAVE ONE, BACK UP AND PUT IN THE DOLLAR
3104 MVI M,"$" ;SIGN
3105 FOTZS3: MOV A,E ;DO WE HAVE A TRAILING SIGN?
3106 ANI 4
3107 RNZ ;YES, RETURN NOTE THE NON-ZERO FLAG IS SET
3108 FOFXIS: DCX H ;NO, BACK UP ONE AND PUT THE SIGN BACK IN
3109 ;PEOPLE JUMP HERE WHO WANT A "DCX H" AND
3110 ;DON'T CARE ABOUT M
3111 MOV M,B ;PUT IN THE SIGN
3112 RET ;ALL DONE
3113
3114 ; HERE TO INITIALLY SET UP THE FORMAT SPECS AND PUT IN A SPACE FOR THE
3115 ; SIGN OF A POSITIVE NUMBER
3116 FOUINI: STA TEMP3 ;SAVE THE FORMAT SPECIFICATION
3117 LXI H,FBUFFR+1 ;GET A POINTER INTO FBUFFR
3118 MVI M," " ;PUT IN A SPACE
3119 RET ;ALL DONE
3120
3121 ; HERE TO PRINT A SNG OR DBL IN FREE FORMAT
3122 FOUFRV: PUSH H ;SAVE THE BUFFER POINTER
3123 JZ FOUFRS ;WE HAVE A SNG
3124 ;HERE TO SET UP THE FLAG TO PRINT A DBL IN FREE FORMAT
3125 MVI D,20 ;WE HAVE A DBL, SET THE DIGIT COUNT
3126 XWD 1000,001 ;"LXI B" OVER THE NEXT TWO BYTES
3127 ; HERE TO SET UP THE FLAG TO PRINT A SNG IN FREE FORMAT
3128 FOUFRS: MVI D,6 ;SET THE DIGIT COUNT
3129 CALL FOUTNV ;NORMALIZE THE FAC SO ALL SIGNIFICANT DIGITS
3130 ;ARE IN THE INTEGER PART
3131 LXI B,2*400+$CODE ;B = DECIMAL POINT COUNT
3132 ;C = COMMA COUNT
3133 ;SET COMMA COUNT TO ZERO AND DECIMAL POINT
3134 ;COUNT FOR E NOTATION
3135 ADD D ;SEE IF NUMBER SHOULD BE PRINTED IN E NOTATION
3136 JM FOFRS1 ;IT SHOULD, IT IS .LT. .1
3137 INR D ;CHECK IF IT IS TOO BG
3138 CMP D
3139 JNC FOFRS1 ;IT IS TOO BIG, IT IS .GT. 10^D-1
3140 INR A ;IT IS OK FOR FIXED POINT NOTATION
3141 MOV B,A ;SET DECIMAL POINT COUNT
3142 MVI A,1 ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
3143 ;IF WE ARE USING FIXED POINT NOTATION
3144 FOFRS1: DCR A ;E NOTATION: ADD D-1 TO ORIGINAL EXPONENT
3145 POP H ;GET THE BUFFER POINTER BACK
3146 PUSH PSW ;SAVE THE EXPONENT FOR LATER
3147 CALL FOUTCV ;CONVERT THE NUMBER TO DECIMAL DIGITS
3148 ; HERE TO SUPPRESS THE TRAILING ZEROS
3149 FOFRS2: DCX H ;MOVE BACK TO THE LAST CHARACTER
3150 MOV A,M ;GET IT AND SEE IF IT WAS ZERO
3151 CPI "0"
3152 JZ FOFRS2 ;IT WAS, CONTINUE SUPPRESSING
3153 CPI "." ;HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
3154 CNZ INXHRT ;YES, IGNORE THE DECIMAL POINT ALSO
3155 POP PSW ;GET THE EXPONENT BACK
3156 JZ FOUTON ;WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
3157 ;FALL IN AND PUT THE EXPONENT IN THE BUFFER
3158
3159 ; HERE TO PUT THE EXPONENT AND "E" OR "D" IN THE BUFFER
3160 ; THE EXPONENT IS IN A
3161 FOFLDN: MOV B,A ;SAVE THE EXPONENT
3162 LDA VALTYP ;GET THE VALTYP TO DEIDE IF WE PRINT AN "E"
3163 CPI 4 ;OR A "D"
3164 MOV A,B ;GET THE EXPONENT BACK
3165 JZ FOUCEE ;WE HAVE TO PRINT AN "E"
3166 MVI M,"D" ;GET THE "D"
3167 XWD 1000,001 ;"LXI B" OVER THE NEXT TWO BYTES
3168 FOUCEE: MVI M,"E" ;GET AN "E"
3169 INX H ;PUT SIGN OF EXPONENT IN BUFFER
3170 ;PUT IN THE SIGN OF THE EXPONENT
3171 MVI M,"+" ;A PLUS IF POSITIVE
3172 JP FOUCE1
3173 MVI M,"-" ;A MINUS IF NEGATIVE
3174 CMA ;NEGATE EXPONENT
3175 INR
3176 ; CALCULATE THE TWO DIGIT EXPONENT
3177 FOUCE1: MVI B,"0"-1 ;INITIALIZE TEN'S DIGIT COUNT
3178 FOUCE2: INR B ;INCREMENT DIGIT
3179 SUI 12 ;SUBTRACT TEN
3180 JNC FOUCE2 ;DO IT AGAIN IF RESULT WAS POSITIVE
3181 ADI "0"+12 ;ADD BACK IN TEN AND CONVERT TO ASCII
3182 ;PUT THE EXPONENT IN THE BUFFER
3183 INX H
3184 MOV M,B ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
3185 INX H ;WHEN WE JUMP TO HERE, A IS ZERO
3186 MOV M,A ;PUT ONE'S DIGIT IN BUFFER
3187 FOUTZR: INX M ;INCREMENT POINTER, HERE TO FINISH UP PRINTING
3188 ;A FREE FORMAT ZERO
3189 FOUTON: MVI M,0 ;PUT A ZERO AT THE END OF THE NUMBER
3190 XCHG ;SAVE THE POINTER TO THE END OF THE NUMBER
3191 ;IN (DE) FOR FFXFLV
3192 LXI H,FBUFFR+1 ;GET A POINTER TO THE BEGINNING
3193 RET ;ALL DONE
3194
3195 ; HERE TO PUT A POSSIBLE COMMA COUNT IN C, AND ZERO C IF WE ARE NOT
3196 ; USING THE COMMA SPECIFICATION
3197 FOUTCC: MOV C,A ;SAVE A POSSIBLE COMMA COUNT
3198 FOUICC: LDA TEMP3 ;GET THE FORMAT SPECS
3199 ANI 100 ;LOOK AT THE COMMA BIT
3200 RNZ ;WE ARE USING COMMAS, JUST RETURN
3201 MOV C,A ;WE AREN'T, ZERO THE COMMA COUNT .
3202 RET ;ALL DONE
3203
3204 ; HERE TO PRINT A NUMBER IN FIXED FORMAT
3205 FOUTFX: CPI 4 ;CHECK WHAT KIND OF VALUE WE HAVE
3206 MOV A,D ;GET THE FORMAT SPECS
3207 JNC FOUFXV ;WE HAVE A SNG OR A DBL
3208 ; HERE TO PRINT AN INTEGER IN FIXED FORMAT
3209 RAR ;CHECK IF WE HAVE TO PRINT IT IN FLOATING
3210 JC FFXIFL ;POINT NOTATION
3211 ; HERE TO PRINT AN INTEGER IN FIXED FORMAT-FIXED POINT NOTATION
3212 LXI B,6*400+3+$CODE ;SET DECIMAL POINT COUNT TO 6 AND
3213 ;COMMA COUNT TO 3
3214 CALL FOICC ;CHECK IF WE DON'T HAVE TO USE THE COMMAS
3215 POP D ;GET THE FIELD LENGTHS
3216 MOV A,D ;SEE IF WE HAVE TO PRINT EXTRA SPACES BECAUSE
3217 SUI 5 ;THE FIELD IS TOO BIG
3218 CP FOTZER ;WE DO, PUT IN ZEROS, THEY WILL LATER BE
3219 ;CONVERTED TO SPACES OR ASTERISKS BY FOUTZS
3220 PUSH D ;SAVE THE FIELD LENGTHS AGAIN
3221 CALL FOUTCI ;CONVERT THE NUMBER TO DECIMAL DIGITS
3222 POP D ;GET THE FIELD LENGTHS BACK
3223 ORA E ;DO WE NEED A DECIMAL POINT? HERE A=0
3224 CZ FOFXIS ;WE DON'T, BACKSPACE OVER IT. AT FOFXIS,
3225 ;WE DON'T CARE ABOUT B, WE ONLY WANT THE
3226 ;"DCX H". LATER ON WE WILL DO A "MVI M,0"
3227 ;AND COVER UP WHAT WAS IN B.
3228 CNZ FOTZER ;FOFXIS PRESERVES THE CONDITION CODES
3229 ;IF WE DO HAVE DECIMAL PLACES, FILL THEM UP
3230 ;WITH ZEROS
3231 ;FALL IN AND FINISH UP THE NUMBER
3232
3233 ; HERE TO FINISH UP A FIXED FORMAT NUMBER
3234 FOUTTS: PUSH H ;SAVE BUFFER POINTER
3235 CALL FOUTZS ;ZERO SUPPRESS THE NUMBER
3236 POP H ;GET THE BUFFER POINTER BACK
3237 JZ FFXIX1 ;CHECK IF WE HAVE A TRAILING SIGN
3238 MOV M,B ;WE DO, PUT THE SIGN IN THE BUFFER
3239 INX H ;INCREMENT THE BUFFER POINTER
3240 FFXIX1: MVI M,0 ;PUT A ZERO AT THE END OF THE NUMBER
3241
3242 ; HERE TO CHECK IF A FIXED FORMAT-FIXED POINT NUMBER OVERFLOWED ITS
3243 ; FIELD LENGTH
3244 ; D = THE B IN THE FORMAT SPECIFICATION
3245 ; THIS ASSUMES THE LOCATION OF THE DECIMAL POINT IS IN TEMP2
3246 LXI H,FBUFFR ;GET A POINTER TO THE BEGINNING
3247 FOUBE1: INX H ;INCREMENT POINTER TO THE NEXT CHARACTER
3248 FOUBE5: LDA TEMP2 ;GET THE LOCATION OF THE DECIMAL POINT
3249 SUB L ;FIGURE OUT HOW MUCH SPACE WE ARE TAKING
3250 SUB 0 ;IS THIS THE RIGHT AMOUNT OF SPACE TO TAKE?
3251 RZ ;YES, WE ARE DONE, RETURN FROM FOUT
3252 MOV A,M ;NO, WE MUST HAVE TOO MUCH SINCE WE STARTED
3253 ;CHECKING FROM THE BEGINNING OF THE BUFFER
3254 ;AND THE FIELD MUST BE SMALL ENOUGH TO FIT IN
3255 ;THE BUFFER. GET THE NEXT CHARACTER IN
3256 ;THE BUFFER
3257 CPI " " ;IF IT IS A SPACE OR AN ASTERISK, WE CAN
3258 JZ FOUBE1 ;IGNORE IT AND MAKE THE FIELD SHORTER WITH
3259 CPI "*" ;NO ILL EFFECTS
3260 JZ FOUBE1
3261 DCX H ;MOVE THE POINTER BACK ONE TO READ THE
3262 ;CHARACTER WITH CHRGET
3263 PUSH H ;SAVE THE POINTER
3264
3265 ; HERE WE SEE IF WE CAN IGNORE THE LEADING ZERO BEFORE A DECIMAL POINT.
3266 ; THIS OCCURS IF WE SEE THE FOLLOWING: (IN ORDER)
3267 ;        A SIGN (EITHER "." OR "+") (OPTIONAL)
3268 ;        A DOLLAR SIGN (OPTIONAL)
3269 ;        A ZERO [MANDATORY
3270 ;        A DECIMAL POINT [MANDATORY]
3271 ;        ANOTHER DIGIT [MANDATORY]
3272 ; IF YOU SEE A LEADING ZERO, IT MUST BE THE ONE BEFORE A DECIMAL POINT
3273 ; OR ELSE FOUTZS WOULD HAVE SUPPRESSED IT, SO WE CAN JUST "INX H"
3274 ; OVER THE CHARACTER FOLLOWING THE ZERO, AND NOT CHECK FOR THE
3275 ; DECIMAL POINT EXPLICITLY.
3276 FOUBE2: PUSH PSW ;PUT THE LAST CHARACTER ON THE STACK, THE
3277 ;ZERO FLAG IS SET. THE FIRST TIME THE ZERO
3278 ;ZERO FLAG IS NOT SET.
3279 LXI B,FOUBE2 ;GET THE ADDRESS WE GO TO IF WE SEE A CHARACTER
3280
3281 PUSH B ;WE ARE LOOKING FOR
3282 CHRGET ;GET THE NEXT CHARACTER
3283 CPI "-" ;SAVE IT AND GET THE NEXT CHARACTER IF IT IS
3284 RZ ;A MINUS SIGN, A PLUS SIGN OR A DOLLAR SIGN
3285 CPI "+"
3286 RZ
3287 CPI "$"
3288 RZ
3289 POP B ;IT ISNET, GET THE ADDRESS OFF THE STACK
3290 CPI "0" ;IS IT A ZERO?
3291 JNZ FOUBE4 ;NO, WE CAN NOT GET RID OF ANOTHER CHARACTER
3292 INX H ;SKIP OVER THE DECIMAL POINT
3293 CHRGET ;GET THE NEXT CHARACTER
3294 JNC FOUBE4 ;IT IS NOT A DIGIT, WE CAN'T SHORTEN THE FIELD
3295 DCX H ;WE CAN111 POINT TO THE DECIMAL POINT
3296 XWD 1000,001 ;"LXI B" OVER THE NEXT 2 BYTES
3297 FOUBE3: DCX H ;POINT BACK ONE CHARACTER
3298 MOV M,A ;PUT THE CHARACTER BACK
3299
3300 ; IF WE CAN GET RID OF THE ZERO, WE PUT THE CHARACTERS ON THE STACK
3301 ; BACK INTO THE BUFFER ONE POSITION IN FRONT OF WHERE THEY ORIGINALLY
3302 ; WERE. NOTE THAT THE MAXIMUM NUMBER OF STACK LEVELS THIS USES IS
3303 ; THREE -- ONE FOR THE LAST ENTRY FLAG, ONE FOR A POSSIBLE SIGN,
3304 ; AND ONE FOR A POSSIBLE DOLLAR SIGN, WE DON'T HAVE TO WORRY ABOUT
3305 ; THE FIRST CHARACTER BEING IN THE BUFFER TWICE BECAUSE THE POINTER
3306 ; WHEN FOUT EXITS WILL BE POINTING TO THE SECOND OCCURANCE.
3307 POP PSW ;GET THE CHARACTER OFF THE STACK
3308 JZ FOUBE3 ;PUT IT BACK IN THE BUFFER IF IT IS NOT THE
3309 ;LAST ONE
3310 POP B ;GET THE BUFFER POINTER OFF THE STACK
3311 JMP FOUBE3 ;SEE IF THE FIELD IS NOW SMALL ENOUGH
3312 ; HERE IF THE NUMBER IS TOO BIG FOR THE FIELD
3313 FOUBE4: POP PSW ;GET THE CHARACTERS OFF THE STACK
3314 JZ FOUBE4 ;LEAVE THE NUMBER IN THE BUFFER ALONE
3315 POP H ;GET THE POINTER TO THE BEGINNING OF THE
3316 ;NUMBER MINUS 1
3317 MVI M,"%" ;PUT IN A PERCENT SIGN TO INDICATE THE NUMBER
3318 ;WAS TOO LARGE FOR THE FIELD
3319 RET ;ALL DONE -- RETURN FROM FOUT
3320
3321 ; HERE TO PRINT A SNG OR DBL IN FIXED FORMAT
3322 FOUFXV: PUSH H ;SAVE THE BUFFER POINTER
3323 RAR ;GET FIXED OR FLOATING NOTATION FLAG IN CARRY
3324 JC FFXFLV ;PRINT THE NUMBER IN E-NOTATION
3325 JZ FFXSFX ;WE HAVE A SNG
3326 ; HERE TO PRINT A DBL IN FIXED FORMAT--FIXED POINT NOTATION
3327 LXI D,FFXDXM ;GET POINTER TO 1D16
3328 CALL DCOMPD ;WE CAN'T PRINT A NUMBER .GE. 10^16 IN FIXED
3329 ;POINT NOTATION
3330 LXI D,16*400+$CODE ;SET D = NUMBER OF DIGITS TO PRINT FOR A DBL
3331 ;C = 0 FOR DBL (THIS IS FOR COMMAS)
3332 JM FFXSDC ;IF THE FAC WAS SMALL ENOUGH, GO PRINT IT
3333 ; HERE TO PRINT IN FREE FORMAT WITH A PERCENT SIGN A NUMBER GE. 10^16
3334 FFXSDO: XRA A ;SET THE FORMAT SPECS TO FREE FORMAT
3335 STA TEMP3
3336 POP H ;GET THE BUFFER POINTER
3337 DCX H ;SET UP TO JUMP BACK INTO FOUT
3338 ;NOW (HL)=FBUFFR+1
3339 CALL FOUT1 ;PRINT THE NUMBER IN FREE FORMAT, THE SIGN
3340 ;IS ALREADY IN THE BUFFER
3341 DCX H ;POINT IN FRONT OF THE NUMBER
3342 MVI M,"%" ;PUT IN THE PERCENT SIGN
3343 RET ;ALL DONE -- RETURN FROM FOUT
3344 ; HERE TO PRINT A SNG IN FIXED FORMAT--FIXED POINT NOTATION
3345 FFXSFX: MOVRI 26,016,033,312 ;GET 1E16, CHECK IF THE NUMBER IS TOO BIG
3346 CALL FCOMP
3347 JP FFXSDO ;IT IS, PRINT IT IN FREE FORMAT WITH A % SIGN
3348 LXI D,6*400+2+$CODE ;SET UP FLAGS FOR SNG --
3349 ;D = NUMBER OF DIGITS TO PRINT IN A SNG
3350 ;C = 2 (THIS IS FOR THE COMMAS)
3351 ; HERE TO ACTUALLY PRINT A SNG OR DBL IN E NOTATION
3352 FFXSDC: FSIGN ;SEE IF WE HAVE ZERO
3353 CNZ FOUTNV ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
3354 ;BE PRINTED ARE IN THE INTEGER PART
3355 POP H ;GET THE BUFFER POINTER
3356 POP B ;GET THE FIELD LENGTH SPECS
3357 JM FFXXVS ;DO DIFFERENT STUFF IF EXPONENT IS NEGATIVE
3358
3359 ; HERE TO PRINT A NUMBER WITH NO FRACTIONAL DIGITS
3360 PUSH B ;SAVE THE FIELD LENGTH SPECS AGAIN
3361 MOV C,A ;SAVE THE EXPONENT
3362 MOV A,B ;WE HAVE TO PRINT LEADING ZEROS IF THE FIELD
3363 SUB D ;HAS MORE CHARACTERS THAN THERE ARE DIGITS IN
3364 SUB C ;THE NUMBER
3365 CP FOTZER ;FOUTZS WILL LATER SUPPRESS THEM
3366 MOV A,C ;SET UP THE COMMA COUNT
3367 ADD E
3368 MOV E,C ;WE NO LONGER NEED THE NUMBER WE SETUP IN E
3369 FFXXV1: SUI 3 ;REDUCE A MOD 3
3370 JNC FFXXV1
3371 ADI 5 ;ADD 3 BACK AND ADD IN 2 MORE FOR SCALING
3372 CALL FOUTCC ;CHECK IF WE HAVE TO USE COMMAS AT ALL
3373 MOV A,E ;SETUP THE DECIMAL POINT COUNT
3374 ADD D
3375 INR A
3376 MOV B,A ;IT GOES IN B
3377 PUSH D ;SAVE SNG OR DBL AND EXPONENT INFORMATION
3378 CALL FOUTCV ;CONVERT THE NUMBER TO DECIMAL DIGITS
3379 POP D ;GET THE SNG OR DBL AND EXPONENT INFO BACK
3380 ORA E ;PUT IN DIGITS AFTER THE NUMBER IF IT
3381 ;IS BIG ENOUGH, HERE A=0
3382 CNZ FOTZRC ;THERE CAN BE COMMAS IN THESE ZEROS
3383 POP D ;GET THE FIELD LENGTH SPECS
3384 ORA E ;HERE A=0
3385 CNZ FOUTDP ;PRINT A DECIMAL POINT IF NECESSARY
3386 DCR A ;SEE IF WE SHOULD PRINT SOME ZEROS TO FILL IN
3387 CP FOTZER ;THE DECIMAL PLACES
3388 JMP FOUTTS ;GO CHECK THE SIZE, ZERO SUPPRESS, ETC. AND
3389 ;FINISH THE NUMBER
3390 ; HERE TO PRINT A SNG OR DBL THAT HAS FRACTIONAL DIGITS
3391 FFXXVS: MOV E,A ;SAVE THE EXPONENT, WE DON'T NEED WHAT IS IN E
3392 MOV A,C ;DIVIDE BY TEN THE RIGHT NUMBER OF TIMES SO
3393 ORA A ;THE RESULT WILL BE ROUNDED CORRECTLY AND
3394 CNZ DCRART ;HAVE THE CORRECT NUMBER OF SIGNIFICANT
3395 ADD E ;DIGITS
3396 PUSH PSW ;SAVE THIS NUMBER FOR LATER
3397 FFXXV2: CM FINDIV ;THIS IS THE DIVIDE LOOP
3398 JM FFXXV2
3399 MOV A,E ;WE HAVE TWO CASES DEPENDING ON WHETHER THE
3400 ADD D ;THE NUMBER IS .LT. .1 OR NOT
3401 MOV A,B
3402 JM FFXXV3
3403 ; HERE TO PRINT NUMBERS .GE.
3404 SUB D ;PRINT SOME LEADING ZEROS IF THE FIELD IS
3405 SUB E ;BIGGER THAN THE NUMBER OF DIGITS WE WILL
3406 CP FOTZER ;PRINT
3407 POP PSW ;WE DON'T NEED THE NUMBER WE SAVED BEFORE
3408 MOV B,E ;GET ALL THE PERTINENT INFO IN B,C
3409 PUSH B ;SAVE THE EXPONENT AND "C" IN FIELD SPEC
3410 MOV A,E ;SET UP THE DECIMAL POINT COUNT
3411 ADD D
3412 INR A
3413 MOV B,A
3414 MOV A,D ;SET UP THE COMMA COUNT
3415 ANI 2 ;THESE 2 INSTRUCTIONS MAP 6 TO 4
3416 ADI 2 ;AND 16 TO 2
3417 ADD E
3418 CALL FOUTCC ;CHECK IF WE HAVE TO DO THE COMMA THING
3419 JMP FFXXV6 ;CONVERT THE DIGITS AND DO THE TRIMMING UP
3420 ; HERE TO PRINT A NUMBER .LT. .1
3421 FFXXV3: CALL FOTZER ;PUT ALL ZEROS BEFORE THE DECIMAL POINT
3422 MOV A,C ;SAVE C
3423 CALL FOUTDP ;PUT IN A DECIMAL POINT
3424 MOV C,A ;RESTORE C
3425 POP PSW ;GET THE NUMBER WE SAVED
3426 JM FFXXV4 ;DECIDE HOW MANY ZEROS TO PRINT BETWEEN THE
3427 XRA A ;DECIMAL POINT AND THE FIRST DIGIT WE WILL
3428 SUB E ;PRINT. HERE THE FIELD IS BIG ENOUGH TO
3429 SUB 0 ;HOLD ALL THE DIGITS
3430 JMP FFXXV5 ;DO PRINT THEM
3431 FFXXV4: MOV A,C ;HERE WE HAD TO DIVIDE BY TEN SO THE FIELD
3432 SUB D ;IS SMALLER THAN ALL SIGNIFICANT DIGITS IN
3433 DCR A ;THE NUMBER
3434 FFXXV5: CALL FOTZER ;PRINT THE ZEROS
3435 MOV B,E ;SAVE THE EXPONENT IN B
3436 PUSH B ;SAVE EXPONENT AND THE "C" IN THE FIELD SPEC
3437 MOV B,A ;ZERO THE DECIMAL PLACE COUNT
3438 MOV C,A ;ZERO THE COMMA COUNT
3439 FFXXV6: CALL FOUTCV ;CONVERT THE NUMBER TO DECIMAL DIGITS
3440 POP D ;GET THE EXPONENT AND FIELD SPEC BACK
3441 ORA E ;CHECK IF WE HAVE TO PRINT ANY ZEROS AFTER
3442 ;THE LAST DIGIT
3443 JZ FFXXV7 ;CHECK IF THERE WERE ANY DECIMAL PLACES AT ALL
3444 ADD D ;PRINT SOME MORE TRAILING ZEROS
3445 DCR A
3446 CP FOTZER
3447 JMP FOUTTS ;FINISH UP THE NUMBER
3448 ;THERE WERE NO DECIMAL PLACES, IGNORE ALL DIGITS AFTER THE DECIMAL
3449 ;POINT
3450 FFXXV7: LHLO TEMP2 ;THE END OF THE NUMBER IS WHERE THE DP IS
3451 JMP FOUTTS ;FINISH UP THE NUMBER
3452
3453 ; HERE TO PRINT AN INTEGER IN FIXED FORMAT--FLOAT POING NOTATION
3454 FFXIFL: PUSH H ;SAVE THE BUFFER POINTER
3455 PUSH D ;SAVE THE FORMAT SPECS
3456 CALL CONSI ;CONVERT THE INTEGER TO A SNG
3457 POP D ;GET THE FORMAT SPECS BACK
3458 POP H ;GET THE BUFFER POINTER BACK
3459 XRA A ;SET FLAGS TO PRINT THE NUMBER AS A SNG
3460 ;FALL INTO FFXFLV
3461
3462 ; HERE TO PRINT A SNG OR DBL IN FIXED FORMAT=FLOTATING POINT NOTATION
3463 FFXFLV: JZ FFXSFL ;IF WE HAVE A SNG, SET THE RIGHT FLAGS
3464 MVI E,20 ;WE HAVE A DBL, GET HOW MANY DIGITS WE HAVE
3465 XWD 1000,001 ;"LXI B" OVER THE NEXT TWO BYTES
3466 FFXSFL: MVI E,6 ;WE HAVE A DBL, GET HOW MANY DIGITS WE PRINT
3467 FSIGN ;SEE IF WE HAVE ZERO
3468 CNZ FOUTNV ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
3469 ;BE PRINTED ARE IN THE INTEGER PART
3470 POP H ;GET THE BUFFER POINTER BACK
3471 POP B ;GET THE FIELD LENGTH SPECS
3472 PUSH PSW ;SAVE THE EXPONENT
3473 MOV A,C ;CALCULATE HOW MANY SIGNIFICANT DIGITS WE MUST
3474 ORA A ;PRINT
3475 PUSH PSW ;SAVE THE "C" FIELD SPEC FOR LATER
3476 CNZ DCRART
3477 ADD B
3478 MOV C,A
3479 MOV A,D ;GET THE FIELD SPEC
3480 ANI 4 ;SEE IF THE SIGN IS A TRAILING SIGN
3481 CPI 1 ;SET CARRY IF A IS ZERO
3482 SBB A ;SET D=0 IF WE HAVE A TRAILING SIGN,
3483 MOV D,A ;D=377 IF WE DO NOT
3484 ADD C
3485 MOV C,A ;SET C=NUMBER OF SIGNIFICANT DIGITS TO PRINT
3486 SUB E ;IF WE HAVE LESS THAN E, THEN WE MUST GET RID
3487 FFXLV1: CM FINDIV ;OF SOME BY DIVIDING BY TEN AND ROUNDING
3488 JM FFXLV1
3489 PUSH B ;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
3490 MOV A,B ;SET THE DECIMAL PLACE COUNT
3491 INR A
3492 SUB D ;TAKE INTO ACCOUNT IF THE SIGN IS TRAILING
3493 MOV B,A
3494 MVI C,0 ;SET COMMA COUNT TO ZERO, THE COMMA SPEC IS
3495 PUSH D ;IGNORED. SAVE TRAILING SIGN INFO
3496 CALL FOUTCV ;CONVERT THE NUMBER TO DECIMAL DIGITS
3497 POP D ;GET THE TRAILING SIGN INFO BACK
3498 POP B ;GET # OF SIG DIGITS AND "B" FIELD SPEC BACK
3499 MOV A,C ;PRINT TRAILING ZEROS IF THE FIELD LENGTH IS
3500 SUB E ;LONGER THAN ENUMBER OF DIGITS WE CAN PRINT
3501
3502 CP FOTZRC ;THE DECIMAL POINT COULD COME OUT IN HERE
3503 POP PSW ;GET THE "C" FIELD SPEC BACK
3504 CZ FOFXIS ;IF C=0, THE LAST THING WAS A DECIMAL POINT,
3505 ;SO IGNORE IT. ALL WE CARE ABOUT IS THE
3506 ;"DCX H" AND NOT THE "MOV M,B" AT FOFXIS
3507 POP PSW ;GET THE EXPONENT BACK
3508 ADD E ;SCALE IT CORRECTLY
3509 SUB B
3510 SUB D
3511 PUSH B ;SAVE THE "B" FIELD SPEC
3512 CALL FOFLDN ;PUT THE EXPONENT IN THE BUFFER
3513 XCHG ;GET THE POINTER TO THE END IN (HL)
3514 ;IN CASE WE HAVE A TRAILING SIGN
3515 POP D ;GET THE "B" FIELD SPEC IN D, PUT ON POSSIBLE
3516
3517 JMP FOUTTS ;TRAILING SIGN AND WE ARE DONE
3518
3519 ; NORMALIZE THE NUMBER IN THE FAC SO ALL THE DIGITS ARE IN THE INTEGER
3520 ; PART. RETURN THE BASE 10 EXPONENT IN A
3521 ; D,E ARE LEFT UNALTERED
3522 FOUTNV: PUSH D ;SAVE (DE)
3523 LDA VALTYP ;GET WHAT KIND OF VALUE WE HAVE
3524 CPI 4
3525 JNZ FOUTND ;WE HAVE A DBL
3526 ; NORMALIZE A SNG
3527 XRA ;ZERO THE EXPONENT
3528 PUSH PSW ;SAVE IT
3529 CALL FOUNSC ;IS THE FAC TOO BIG OR TOO SMALL?
3530 FOUNS1: MOVRI 221,103,117,370 ;GET 99999.9499 TO SEE IF THE FAC IS BIG
3531 CALL FCOMP ;ENOUGH YET
3532 JPO FOUNS3 ;IT IS, WE ARE DONE
3533 POP PSW ;IT ISN'T, MULTIPLY BY TEN
3534 CALL FINMLT
3535 PUSH PSW ;SAVE THE EXPONENT AGAIN
3536 JMP FOUNS1 ;NOW SEE IF IT IS BIG ENOUGH
3537 FOUNS2: POP PSW ;THE FAC IS TOO BIG, GET THE EXPONENT
3538 CALL FINDIV ;DIVIDE IT BY TEN
3539 PUSH PSW ;SAVE THE EXPONENT AGAIN
3540 CALL FOUNSC ;SEE IF THE FAC IS SMALL ENOUGH
3541 FOUNS3: POP PSW ;WE ARE DONE, GET THE EXPONENT BACK
3542 POP D ;GET (DE) BACK
3543 RET ;ALL DONE
3544 ; HERE TO SEE IF THE FAC IS SMALL ENOUGH YET
3545 FOUNSC: MOVRI 224,164,043,367 ;GET 999999.499 TO SEE IF THE FAC IS TOO BIG
3546 CALL FCOMP
3547 POP H ;GET THE RETURN ADRESS OFF THE STACK
3548 JPO FOUNS2 ;IT IS TOO BIG, MAKE IT SMALLER
3549 PCHL ;IT IS SMALL ENOUGH, RETURN
3550 ; HERE TO NORMALIZE A DBL NUMBER
3551 >
3552 PAGE
3553 SUBTTL EXPONENTIATION AND THE SQUARE ROOT FUNCTION
3554 IFE EXTFNC,<
3555 ; SQUARE ROOT FUNCTION X=SQR(A)
3556 ; WE FIRST SCALE THE ARGUMENT TO BETWEEN 5 AND 2 BY LOOKING AT THE
3557 ; EXPONENT AND USING SQR(M*2*(2*N))=2^N*SQR(M) THEN NEWTON'S METHOD
3558 ; HIS USED TO COMPUTE QRCM). THE EXPONENT IS SAVED TO SCALE THE
3559 ; RESULT AT THE END.
3560 ; NEWTON'S METHOD FOR SQUARE ROOT:
3561 ;   X(0)=
3562 ;   X(N+1)=(X(N)+A/X(N))/2
3563 SQR: FSIGN ;CHECK FOR ERROR CONDITION
3564 JM FCERR ;CAN'T TAKE SQR OF NEGATIVE NUMBER
3565 RZ ;0=SQR(0)
3566 LXI H,FAC ;SCALE ARGUMENT TO BETWEEN .5 AND 2
3567 MOV A,M ;GET EXPONENT
3568 RAR ;GET EXPONENT OF SCALE FACTOR
3569 ;USE SQR(M*2*(2*N))=2^N*SQR(M)
3570 PUSH PSW ;SAVE IT
3571 PUSH H ;SAVE POINTER TO EXPONENT
3572 MVI A,100 ;SET EXPONENT OF SCALED DOWN NUMBER
3573 RAL
3574 MOV M,A ;REPLACE IT
3575 LXI H,FBUFFR ;SAVE A
3576 CALL MOVMF
3577 MVI A,4 ;SET ITERATION COUNT
3578 SQR1: PUSH PSW ;SAVE COUNT
3579 CALL PUSHF ;SAVE X(N)
3580 LXI H,FBUFFR ;COMPUTE A/X(N)
3581 CALL MOVRM ;GET A IN THE REGISTERS
3582 CALL FDIV
3583 POPR
3584 CALL FADD ;ADD IN X(N)
3585 LXI H,FHALF ;DIVIDE BY 2
3586 CALL FMULTS
3587 POP PSW ;GET COUNT
3588 DCR A ;ARE WE DONE?
3589 JNZ SQR1 ;NO, DO MORE ITERATIONS
3590 POP H ;YES, SET EXPONENT OF ANSWER
3591 POP PSW ;GET SCALE FACTOR
3592 ADI 300 ;CONVERT TO AN EXPONENT
3593 ADD M ;ADD EXPONENT IN
3594 MOV M,A ;REPLACE EXPONENT
3595 RET> ;ALL DONE
3596
3597
3598 IFN EXTFNC,<
3599 ; SUBROUTINE FOR FPWR, ATN
3600 PSHNEG: LXI H,NEG ;GET THE ADDRESS OF NEG
3601
3602
3603 XTHL ;SWITCH RET ADDR AND ADDR OF NEG
3604 PCHL ;RETURN, THE ADDRESS OF NEG IS ON THE STACK
3605
3606
3607 ; SQUARE ROOT FUNCTION
3608 ; WE USE SQR(X)=X^.5
3609 SQR: CALL PUSHF ;SAVE ARG
3610
3611
3612 LXI H,FHALF ;GET 1/2
3613
3614
3615 CALL MOVFM ;SQR(X)=X^.5
3616
3617
3618 FPWRT: POPR ;GET ARG IN REGISTERS, ENTRY TO FPWR IF
3619
3620 ;ARGUMENT IS ON STACK. FALL INTO FPWR
3621
3622
3623 ; EXPONENTIATION --- X^Y
3624 ; N.B. 0^0=1
3625 ; FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
3626 ; NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
3627 ; THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
3628 ; NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD. IF Y IS A NEGATIVE
3629 ; INTEGER, WE NEGATE X. IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
3630 ; IT. IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
3631 ; STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT. TO COMPUTE
3632 ; THE RESULT WE USE X*Y=EXP(Y*LOG(X))
3633 FPWR: FSIGN ;SEE IF Y IS ZERO
3634 JZ EXP ;IT IS, RESULT IS ONE
3635
3636
3637 MOV A,B ;SEE IF X IS ZERO
3638 ORA A
3639 JZ ZERO0 ;IT IS, RESULT IS ZERO
3640
3641
3642 PUSHR ;SAVE X ON STACK
3643
3644 MOV A,C ;CHECK THE SIGN OF X
3645 ORI 177 ;TURN THE ZERO FLAG OFF
3646
3647 CALL MOVRF ;GET Y IN THE REGISTERS
3648
3649
3650 JP FPWR1 ;NO PROBLEMS IF X IS POSITIVE
3651
3652
3653 PUSHR ;SAVE Y
3654
3655 CALL INT ;SEE IF Y IS AN INTEGER
3656
3657
3658 POPR ;GET Y BACK
3659
3660 PUSH PSW ;SAVE LO OF INT FOR EVEN AND ODD INFORMATION
3661 CALL FCOMP ;SEE IF WE HAVE AN INTEGER
3662
3663
3664 POP H ;GET EVEN-ODD INFORMATION
3665 MOV A,H ;PUT EVEN-ODD FLAG IN CARRY
3666 RAR
3667 FPWR1: POP H ;GET X BACK IN FAC
3668 SHLD FAC-1 ;STORE HO'S
3669
3670
3671 POP H ;GET LO'S OFF STACK
3672 SHLD FACLO ;STORE THEM IN FAC
3673
3674
3675 CC PSHNEG ;NEGATE NUMBER AT END IF Y WAS ODD
3676
3677
3678 CZ NEG ;NEGATE THE NEGATIVE NUMBER
3679
3680
3681 FPWR2: PUSHR ;SAVE Y AGAIN
3682
3683 CALL LOG ;COMPUTE EXP (CY*LOG(X))
3684
3685
3686 POPR ;IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
3687
3688 CALL FMULT> ;LOG WILL BLOW HIM OUT OF THE WATER
3689
3690
3691 ; JMP EXP
3692 PAGE
3693 SUBTTL EXPONENTIAL FUNCTON
3694 IFN EXTFNC,<
3695 ; WE FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY LOG2(E)
3696 ; THE RESULT IS USED TO DETERMINE IF WE WILL GET OVERFLOW SINCE
3697 ; EXP(X)=2^(X*LOG2(E)) WHERE LOG2(E)=LOG(E) BASE 2. THEN WE SAVE THE
3698 ; INTEGER PART OF THIS TO SCALE THE ANSWER AT THE END, SINCE
3699 ; 2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2*INT(Y) IS EASY TO COMPUTE. SO WE
3700 ; NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E))) BY
3701 ; P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
3702 ; POLYNOMIAL. THE RESULT IS THEN SCALED BY THE POWER OF 2 WE
3703 ; PREVIOUSLY SAVED.
3704 EXP: CALL PUSHF ;SAVE ARGUMENT
3705
3706
3707 MOVRI 201,070,252,073 ;GET LOG(E) BASE 2, CACULATE:
3708
3709
3710
3711
3712
3713 CALL FMULT ;INT(ARG/LN(2)) # INT(ARG*LN(2)) = INT(ARG*LOG2(E))
3714
3715
3716 LDA FAC ;CARRY=0 IF FAC IS TOO BIG
3717
3718
3719 CPI 210 ;I.E. IF ABS(FAC) .GE. 128
3720
3721 JNC MLDVEX ;IT IS TOO BIG
3722
3723
3724 CALL INT ;IS ARGUMENT TOO BIG?
3725
3726
3727 ADI 200 ;CHECK FOR OVERFLOW
3728
3729 ADI 2
3730
3731 JC MLDVEX ;WE HAVE OVERFLOW!!
3732
3733
3734 PUSH PSW ;SAVE SCALE FACTOR
3735 LXI H,FONE ;ADD ONE TO THE NUMBER
3736
3737
3738 CALL FADDS
3739
3740
3741 CALL MULLN2 ;MULTIPLY BY LN(2)
3742
3743
3744 POP PSW ;GET SCALE FACTOR OFF STACK
3745 POPR ;GET ARGUMENT
3746
3747 PUSH PSW ;PUT SCALE FACTOR BACK ON STACK
3748 CALL FSUB ;SUBTRACT ORIGINAL ARG
3749
3750
3751 CALL NEG
3752
3753
3754 LXI H,EXPCON ;EVALUATE THE APPROXIMATION POLYNOMIAL
3755
3756
3757 CALL POLY
3758
3759
3760 LXI D,$CODE ;MULTIPLY BY 2 ^ (B-1) INSTEAD OF JUST
3761
3762
3763 POP B ;ADDING IT TO THE EXPONENT SO FMULT
3764 MOV C,D ;WILL CHECK FOR EXPONENT OVERFLOW
3765 JMP FMULT
3766
3767
3768
3769 ; CONSTANTS FOR EXP
3770 EXPCON: 10 ;DEGREE
3771 100 ;-.0001413161
3772 056
3773 224
3774 164
3775 160 ;.001329882
3776 117
3777 056
3778 167
3779 156 ;-.00830136
3780 002
3781 210
3782 172
3783 346 ;.04165735
3784 240
3785 052
3786 174
3787 120 ;-.1666653
3788 252
3789 252
3790 176
3791 377 ;.4999999
3792 377
3793 177
3794 177
3795 000 ;-1.0
3796 000
3797 200
3798 201
3799 000 ;1.0
3800 000
3801 000
3802 201>
3803 PAGE
3804 SUBTTL POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
3805 IFN EXTFNC,<
3806 ; EVALUATE P(X^2)*X
3807 ; POINTER TO DEGREE+1 IS IN (HL)
3808 ; THE CONSTANTS FOLLOW THE DEGREE
3809 ; CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
3810 ; WE COMPUTE:
3811 ;   C0*X*C1*X^3+C2*X^5+C3*X^7...+C(N)*X^(2*N+1)
3812 POLYX: CALL PUSHF ;SAVE X
3813
3814
3815 LXI D,FMULTT ;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
3816
3817
3818 PUSH D ;RETURN WE WILL MULTIPLY BY X
3819 PUSH H ;SAVE CONSTANT POINTER
3820 CALL MOVRF ;SQUARE X
3821
3822
3823 CALL FMULT
3824
3825
3826 POP H ;GET CONSTANT POINTER
3827 ;FALL INTO POLY
3828
3829
3830 ; POLYNOMIAL EVALUATOR
3831 ; POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
3832 ; THE CONSTANTS FOLLOW THE DEGREE
3833 ; CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
3834 ; WE COMPUTE:
3835 ;   C+C1*X+C2*X^2+C3*X+...+C(N-1)*X^(N-1)+C(N)*X^N
3836 POLY: CALL PUSHF ;SAVE X
3837
3838
3839 MOV A,M ;GET DEGREE
3840 INX H ;INCREMENT POINTER TO FIRST CONSTANT
3841 CALL MOVFM ;MOVE FIRST CONSTANT TO FAC
3842
3843
3844 XWD 1000,006 ;"MVI B" OVER NEXT BYTE
3845 POLY1: POP PSW ;GET DEGREE
3846 POPR ;GET X
3847
3848 DCR A ;ARE WE DONE?
3849 RZ ;YES, RETURN
3850 PUSHR ;NO, SAVE X
3851
3852 PUSH PSW ;SAVE DEGREE
3853 PUSH H ;SAVE CONSTANT POINTER
3854 CALL FMULT ;EVALUATE THE POLY, MULTIPLY BY X
3855
3856
3857 POP H ;GET LOCATION OF CONSTANTS
3858 CALL MOVRM ;GET CONSTANT
3859
3860
3861 PUSH H ;STORE LOCATION OF CONSTANTS SO FADD AND FMULT
3862
3863 CALL FADD ;WILL NOT SCREW THEM UP, ADD IN CONSTANT
3864
3865
3866 POP H ;MOVE CONSTANT POINTER TO NEXT CONSTANT
3867 JMP POLY1> ;SEE IF DONE
3868
3869
3870
3871
3872 ; PSUEDO-RANDOM NUMBER GENERATOR
3873 ; IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
3874 ; IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
3875 ; USING THE ARGUMENT
3876 ; TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
3877 ; PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
3878 ; RANDOM CONSTANT. THEN THE HD AND LO BYTES ARE SWITCHED, THE
3879 ; EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
3880 ; EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
3881 ; THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
3882 ; THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
3883 ; GETTING A NUMBER LESS THAN OR GREATER THAN 5
3884 RND:
3885 IFN LENGTH-2,<
3886 FSIGN> ;GET SIGN OF ARG
3887 IFE LENGTH-2,<
3888 CALL VSIGN ;GET THE SIGN OF THE ARG
3889 PUSH PSW ;SAVE THE SIGN
3890 CM FRCSNG ;IF IT IS NEGATIVE, FORCE IT TO BE A SNG
3891 MVI A,4 ;SINCE WE WILL USE IT
3892 STA VALTYP ;MAKE SURE THE RESULT IS "SINGLE PRECISION"
3893 POP PSW> ;GET THE SIGN BACK
3894 JM RND1 ;START NEW SEQUENCE IF NEGATIVE
3895
3896
3897 LXI H,RNDX ;GET LAST NUMBER GENERATED
3898
3899
3900 CALL MOVFM
3901
3902
3903 RZ ;RETURN LAST NUMBER GENERATED IF ZERO
3904 IFE EXTFNC,<
3905 CALL FMULTS> ;MULTIPLY BY CONSTANT A
3906 IFN EXTFNC,<
3907 CALL MOVRM
3908
3909
3910 CALL FMULT>
3911
3912
3913 MOVRI 150,050,261,106 ;ADD IN CONSTANT OF ORDER 2^(-24)
3914
3915
3916
3917
3918
3919 CALL FADD
3920
3921
3922 RND1: CALL MOVRF ;SWITCH HO AND LO BYTES,
3923
3924
3925 MOV A,E ;GET LO
3926 MOV E,C ;PUT HO IN LO BYTE
3927 MOV C,A ;PUT LO IN HO BYTE
3928 MVI M,200 ;MAKE RESULT POSITIVE
3929
3930 DCX H ;GET POINTER TO EXPONENT
3931 MOV B,M ;PUT EXPONENT IN OVERFLOW POSITION
3932 MVI M,200 ;SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
3933
3934 CALL NORMAL ;NORMALIZE THE RESULT
3935
3936
3937 LXI H,RNDX ;SAVE RANDOM NUMBER GENERATED FOR NEXT
3938
3939
3940 JMP MOVMF ;TIME
3941
3942
3943
3944 ; CONSTANTS AND STORAGE FOR RND
3945 RNDX: 122 ;LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
3946 307
3947 117
3948 200
3949 172 ;RANDOM NUMBER OF ORDER 2^24
3950 104
3951 065
3952 230
3953 PAGE
3954 SUBTTL SINE, COSINE AND TANGENT FUNCTIONS
3955 IFN EXTFNC,<
3956 ; COSINE FUNCTION
3957 ; IDEA: USE COS(X)=SIN(X+PI/2)
3958 COS: LXI H,PI2 ;ADD PI/2 TO FAC
3959
3960
3961 CALL FADDS>
3962
3963
3964 ;FALL INTO SIN
3965
3966
3967 ; SINE FUNCTION
3968 ; IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
3969 ; THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
3970 ; SIN(X+2*PI)=SIN(X). THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
3971 ; COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2PI)1/4.
3972 ; IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
3973 ; AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE INCX).
3974 SIN: CALL PUSHF ;DIVIDE FAC BY 2*PI
3975
3976
3977 MOVRI 203,111,017,333 ;AFTER DIVIDING BY 2*PI, RESULT IS
3978
3979
3980
3981
3982
3983 CALL MOVFR ;BETWEEN 0 AND 1
3984
3985
3986 POPR
3987
3988 CALL FDIV
3989
3990
3991 CALL PUSHF ;DISREGARD INTEGER PART SINCE SIN
3992
3993
3994 CALL INT ;IS PERIODIC WITH PERIOD 2*PI
3995
3996
3997 POPR
3998
3999 CALL FSUB
4000
4001
4002 IFE EXTFNC,<
4003 LXI B,177*400+$CODE ;GET 1/4
4004 MOV D,C
4005 MOV E,C
4006 CALL FSUB>
4007 IFN EXTFNC,<
4008 LXI H,FR4 ;SEE WHAT QUADRANT WE ARE IN
4009
4010
4011 CALL FSUBS>
4012
4013
4014 FSIGN
4015 STC ;SET QUADRANT I FLAG
4016 JP SIN1 ;FIRST QUADRANT, GET BACK ORIGINAL X
4017
4018
4019 CALL FADDH ;ADD 1/2
4020
4021
4022 FSIGN
4023 ORA A ;CLEAR CARRY
4024 SIN1: PUSH PSW ;SAVE QUADRANT FLAG
4025 CP NEG ;NEGATE IF IN QUADRANTS I, II OR III
4026
4027
4028 IFE EXTFNC,<
4029 LXI B,177*400+$CODE ;GET 1/4
4030 MOV D,C
4031 MOV E,C
4032 CALL FADD>
4033 IFN EXTFNC,<
4034 LXI H,FR4 ;ADD 1/4, IN QUADRANTS II, III
4035
4036
4037 ;USE THE IDENTITY: SIN(PI-X)=SIN(X)
4038 ;IN QUADRANT IV, USE THE IDENTITY:
4039 CALL FADDS> ;SIN(X-2*PI)=SIN(X)
4040
4041
4042 POP PSW ;GET QUADRANT FLAG
4043 CNC NEG ;NEGATE IF IN QUADRANTS II, III OR IV
4044
4045
4046 IFE EXTFNC,< ;EVALUATE APPROXIMATION POLYNOMIAL
4047 CALL PUSHF ;SAVE X
4048 CALL MOVRF ;SQUARE X
4049 CALL FMULT
4050 CALL PUSHF ;SAVE X-2
4051 LXI H,SINCON
4052 CALL MOVFM ;MOVE FIRST CONSTANT INTO FAC
4053 POPR ;GET X*2
4054 MVI A,4 ;GET DEGREE
4055 POLY1: PUSH PSW ;SAVE DEGREE
4056 PUSHR ;SAVE X*2
4057 PUSH H ;SAVE CONSTANT POINTER
4058 CALL FMULT ;EVALUATE THE POLY, MULTIPLY BY X*2
4059 POP H ;GET POINTER TO CONSTANTS
4060 CALL MOVRM ;GET CONSTANT
4061 PUSH H ;SAVE POINTER
4062 CALL FADD ;ADD IN CONSTANT
4063 POP H ;MOVE POINTER TO NEXT CONSTANT
4064 POPR ;GET X*2
4065 POP PSW ;GET DEGREE
4066 DCR A ;SEE IF DONE
4067 JNZ POLY1 ;NO, DO NEXT TERM
4068 JMP FMULTT> ;MULTIPLY BY X AND WE ARE DONE
4069 IFN EXTFNC,<
4070 LXI H,SINCON ;CALCULATE THE SIN BY EVALUATING
4071
4072
4073 JMP POLYX> ;THE APPROXIMATION POLYNOMIAL
4074
4075
4076 ; CONSTANTS FOR SIN, COS
4077 IFN EXTFNC,<
4078 PI2: 333 ;PI/2
4079 017
4080 111
4081 201
4082 FR4: 000 ;1/4
4083 000
4084 000
4085 177>
4086 SINCON:
4087 IFN EXTFNC,<
4088 5> ;DEGREE
4089 272 ;39.701067
4090 327
4091 036
4092 206
4093 144 ;-76.57498
4094 046
4095 231
4096 207
4097 130 ;81.60223
4098 064
4099 043
4100 207
4101 340 ;-41.34168
4102 135
4103 245
4104 206
4105 332 ;6.283185
4106 017
4107 111
4108 203
4109
4110
4111 IFN EXTFNC,<
4112 ; TANGENT FUNCTION
4113 ; TAN(X)=SIN(X)/COS(X)
4114 TAN: CALL PUSHF ;SAVE ARG
4115
4116
4117 CALL SIN ;TAN(X)=SIN(X)/COS(X)
4118
4119
4120 POP B ;GET X OFF STACK
4121 POP H ;PUSHF SMASHES (DE)
4122 CALL PUSHF
4123
4124
4125 XCMG ;GET LO'S WHERE THEY BELONG
4126 CALL MOVFR
4127
4128
4129 CALL COS
4130
4131
4132 JMP FDIVT>
4133
4134
4135 PAGE
4136 SUBTTL ARCTANGENT FUNCTION
4137 IFN EXTFNC,<
4138 ; IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
4139 ; APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
4140 ATN: FSIGN ;SEE IF ARG IS NEGATIVE
4141 CM PSHNEG ;IF ARG IS NEGATIVE, USE:
4142
4143
4144 CM NEG ;ARCTAN(X)=-ARCTAN(-X)
4145
4146
4147 LDA FAC ;SEE IF FAC .GT. 1
4148
4149
4150 CPI 201
4151
4152 JC ATN2
4153
4154
4155 LXI B,201*400+$CODE ;GET THE CONSTANT 1
4156
4157
4158 MOV D,C
4159 MOV E,C ;COMPUTE RECIPROCAL TO USE THE IDENTITY:
4160 CALL FDIV ;ARCTAN(X)=PI/2-ARCTAN(1/X)
4161
4162
4163 LXI H,FSUBS ;PUT FSUBS ON THE STACK SO WE WILL RETURN
4164
4165
4166 PUSH H ;TO IT AND SUBTRACT THE REULT FROM PI/2
4167 ATN2: LXI H,ATNCON ;EVALUATE APPROXIMATION POLYNOMIAL
4168
4169
4170 CALL POLYX
4171
4172
4173 LXI H,PI2 ;GET POINTER TO PI/2 IN CASE WE HAVE TO
4174
4175
4176 RET ;SUBTRACT THE RESULT FROM PI/2
4177
4178 ;CONSTANTS FOR ATN
4179 ATNCON: 11 ;DEGREE
4180 112 ;.002866226
4181 327
4182 073
4183 170
4184 002 ;-.01616574
4185 156
4186 204
4187 173
4188 376 ;.04290961
4189 301
4190 057
4191 174
4192 164 ;-.07528964
4193 061
4194 232
4195 175
4196 204 ;.1065626
4197 075
4198 132
4199 175
4200 310 ;-.142089
4201 177
4202 221
4203 176
4204 344 ;.1999355
4205 273
4206 114
4207 176
4208 154 ;-.3333315
4209 252
4210 252
4211 177
4212 000 ;1.0
4213 000
4214 000
4215 201>
4216 PAGE
4217 SUBTTL SYSTEM INITIALIZATION CODE
4218 RADIX 10 ;IN ALL NON-MATH PACKAGE CODE
4219 ; THIS IS THE SYSTEM INITIALIZATION CODE
4220 ; IT SHOULD BE LOADED AT THE END OF THE BASIC
4221 ; INTERPRETER
4222
4223 INTERNAL INIT
4224
4225 EXTERNAL CRDO,LINGET,QINLIN,READY,SCRTCH,STROUT,REASON,BUF
4226 EXTERNAL SNERR,OMERR,ILLFUN
4227
4228 FUNIO==<^D256*^O312>+^O40+$CODE
4229 INITSA: BLOCK 10
4230 INITAT: LXI H,AUTTXT
4231
4232
4233 CALL STROUT
4234
4235
4236 INIT:
4237 IFN REALIO,<
4238 IN 1 ;IGNORE GARBAGE CHARACTER IN INTERFACE
4239
4240 IN ^D255 ;SEE WHAT KIND OF I/O HE IS
4241
4242 ANI ^O100 ;IS HE FUNNY TTY?
4243
4244 JZ NOTSIO
4245
4246
4247 LXI H,FUNIO
4248
4249
4250 SHLO CNLCA2##+2
4251
4252
4253 MVI H,^O310
4254
4255 SHLD CNLCA3##+2
4256
4257
4258 IFN LENGTH,<
4259 MVI H,^O304 ;SUBSTITUE "CNZ"
4260
4261 SHLD CNLCA4##+2>
4262
4263
4264 FUNIO==$CODE+<^O256*^O312>+2
4265 LXI H,FUNIO
4266
4267
4268 SHLD CNLCA1##+2
4269
4270
4271 NOTSIO: IN ^D255
4272
4273 ANI ^O40
4274
4275 JZ NOTPIO
4276
4277
4278 FUNIO=$CODE+<^D256*^O312>+2
4279 LXI H,FUNIO
4280
4281
4282 SHLD CNLCA2+2
4283
4284
4285 MVI H,^O310
4286
4287 SHLD CNLCA3+2
4288
4289
4290 IFN LENGTH,<
4291 MVI H,^O304
4292
4293 SHLD CNLCA4+2>
4294
4295
4296 FUNIO=$CODE+<^D256*^O312>+1
4297 LXI H,FUNIO
4298
4299
4300 SHLD CNLCA1+2
4301
4302
4303 NOTPIO:>
4304 LXI H,$CODE+^D65535
4305
4306
4307 SHLD CURLIN## ;IN CASE OF ERROR MESSAGE
4308
4309
4310 LXI H,TSTACK ;SET UP TEMP STACK
4311
4312
4313 SPHL
4314 SHLD STKTOP##
4315
4316
4317 IFN CONTRW,<
4318 XRA A
4319 STA CNTWFL##>
4320
4321
4322 CALL CRDO ;TYPE A CR
4323
4324
4325 IFN STRING,<
4326 LXI H,TEMPST##
4327
4328
4329 SHLD TEMPPT##>
4330
4331
4332 IFN REALIO,<
4333 LXI H,MEMORY ;ASK HOW MUCH MEMORY AVAILABLE
4334
4335
4336 CALL STROUT ;CALL THE STRING PRINTER
4337
4338
4339 CALL QINLIN ;GET A LINE OF INPUT
4340
4341
4342 CHRGET ;GET A CHAR
4343 CPI "A"
4344
4345 JZ INITAT
4346
4347
4348 QRA A
4349 JNZ USEDE9 ;NON ZERO, DONT USE DEFAULT
4350
4351
4352 LXI H,LASTWR
4353
4354
4355 LOOPMM: INX H
4356 MVI A,311
4357
4358 MOV M,A
4359 CMP M
4360 JNZ USEDEF
4361
4362
4363 DCR A
4364 MOV M,A
4365 CMP M
4366 JZ LOOPMM
4367
4368
4369 JMP USEDEF
4370
4371
4372 USEDE9: LXI H,BUF
4373
4374
4375 CALL LINGET ;GET DECIMAL AMOUNT OF MEMORY IN (D,E)
4376
4377
4378 ORA A
4379 JNZ SNERR ;MAKE SURE HE HAS A TERMINATOR
4380
4381
4382 XCHG
4383 DCX H
4384 USEDEF: DCX H>
4385 IFE REALIO,<
4386 LXI H,$CODE+16190>
4387 PUSH H ;ALSO SAVE FOR LATER
4388 TTYW: LXI H,TTYWID
4389
4390
4391 CALL STROUT
4392
4393
4394 CALL QINLIN
4395
4396
4397 CHRGET
4398 ORA A
4399 JZ DFLENT
4400
4401
4402 LXI H,BUF
4403
4404
4405 CALL LINGET
4406
4407
4408 MOV A,D
4409 QRA A
4410 JNZ TTYW
4411
4412
4413 MOV A,E
4414 CPI 16
4415
4416 JC TTYW
4417
4418
4419 STA LINPT1## ;DECLARE LINPT1 EXTERNAL
4420
4421
4422 IFN LENGTH,<
4423 STA LINPT2##>
4424
4425
4426 IFN STRING,<
4427 STA LINPT3##>
4428
4429
4430 MORCPS: SUI 14
4431
4432 JNC MORCPS
4433
4434
4435 ADI 28
4436
4437 CMA
4438 INR A
4439 ADD E
4440 STA LINPT4##
4441
4442
4443 DFLENT:
4444 IFN STRING,< ;SET UP DEFAULT STRING SPACE
4445 LXI D,$CODE+^D65536-^D50+1
4446
4447
4448 POP H
4449 SHLD MEMSIZ## ;SAVE IN REAL MEMORY SIZE
4450
4451
4452 SHLD FRETOP## ;STRINGS START FROM HERE DOWN
4453
4454
4455 DAD D ;CALC STRBOT BY SUBTRACTING 200 FROM STKTOP
4456 JNC OMERR ;MUST BE POSITIVE
4457
4458
4459 DCX H ;ONE LOWER IS STKTOP
4460 PUSH H> ;SAVE IT ON STACK
4461 IFE EXTFNC,<
4462
4463 ; FUNCTION DELETION ROUTINE FOR 4K MACHINE
4464 ; TO ADD A NEW FUNCTION JUST UPDATE TBLDO
4465
4466 ASKAGN: LXI H,TBLDO ;START OF FUNCTION TABLE
4467 LOPASK: PUSHM ;PUT ON CANDIDATE FOR START OF FREE MEMORY
4468 LXI D,TBDASK ;DONE ASKING?
4469 COMPAR
4470 JZ FINFUN ;YES, GET FIRST FREE MEM LOC
4471 ;INTO [D,E] AND QUIT
4472 PUSHM ;PUT ON MESSAGE LOCATION
4473 XTHL ;[H,L]=MESSAGE POINTER
4474 ;POINTER INTO TBLDO GOES ON THE STACK
4475 CALL STROUT ;PRINT THE MESSAGE
4476 CALL QINLIN ;SEE WHAT ME HAS TO SAY
4477 CHRGET ;SEE WHAT THE FIRST CHARACTER OF INPUT WAS
4478 POP H ;POP OFF POINTER INTO TBLDO
4479 CPI "Y"
4480 FINFUN: POP D ;POP OFF CANDIDATE FOR START OF
4481 ;FREE MEMORY
4482 JZ HAVFNS ;HE WANTS IT SO WE ARE DONE
4483 CPI "N" ;IF A BAD ANSWER
4484 JNZ ASKAGN ;MAKE HIM START OVER
4485 PUSHM ;PUSH ON FUNCTION CALL
4486 ;LOCATION THAT WE FIX UP
4487 XTHL ;[H,L]=FIXUP PLACE
4488 ;POINTER INTO TBLDO GOES ON THE STACK
4489 LXI D,ILLFUN ;THIS IS WHAT WE STORE
4490 MOV M,E
4491 INX H
4492 MOV M,D
4493 POP H ;GET TBLDO POINTER
4494 JMP LOPASK> ;GQ ASK AGAIN FOR ANOTHER FUNCTION
4495 IFN EXTFNC,<
4496 ASKAGN: LXI H,FNS ;ASK IF WANTS SIN, COS, ATN.
4497
4498
4499 CALL STROUT ;THE STRING
4500
4501
4502 CALL QINLIN
4503
4504
4505 CHRGET
4506 CPI "Y"
4507
4508 LXI D,INITSA ;ASSUME NOT DELETE ANY FNS
4509
4510
4511 JZ HAVFNS ;YUP.
4512
4513
4514 CPI "A"
4515
4516 JZ OKCHAR
4517
4518
4519 CPI "N"
4520
4521 JNZ ASKAGN
4522
4523
4524 OKCHAR: LXI H,ILLFUN ;MAKE SURE BOMBS IF TRIES TO CALL THEM
4525
4526
4527 LXI D,ATN
4528
4529
4530 SHLO ATNFIX##
4531
4532
4533 CPI "A" ;DELETE ATN BUT NOT SIN, COST
4534
4535 JZ HAVFNS ;TEST
4536
4537
4538 SHLD COSFIX##
4539
4540
4541 SHLD TANFIX##
4542
4543
4544 SHLD SINFIX##
4545
4546
4547 LXI D,COS>
4548
4549
4550 HAVFNS: ;TEXT ALWAYS PRECEDED BY ZERO
4551 XCHG ;PUT BOTTOM OF MEMORY IN (H,L)
4552 MVI M,0 ;STORE IT
4553
4554 INX H ;INCREMENT POINTER
4555 SHLD TXTTAB## ;SAVE BOTTOM OF MEMORY
4556
4557
4558 XTHL
4559 LXI D,TSTACK
4560
4561
4562 COMPAR
4563 JC OMERR
4564
4565
4566 POP D
4567 SPHL
4568 SHLD STKTOP
4569
4570
4571 XCMG
4572 CALL REASON
4573
4574
4575 MOV A,E ;SUBRACT VARTAB FROM STKTOP
4576 SUB L ;LOW PART
4577 MOV L,A
4578 MOV A,D ;HIGH PART
4579 SBB H
4580 MOV H,A ;LEAVE IN [B,C]
4581 LXI B,$CODE+65520
4582
4583
4584 DAD B
4585 CALL CRDO ;TYPE CRLF
4586
4587
4588 CALL LINPRT ;PRINT # OF BYTES FREE
4589
4590
4591 LXI H,WORDS ;TYPE THE HEADING
4592
4593
4594 CALL STROUT ;"ALTAIR BASIC VERSION-----"
4595
4596
4597 LXI H,STROUT
4598
4599
4600 SHLD REPINI##+1
4601
4602
4603 CALL SCRTCH ;NOW SET UP EVERYTHING ELSE
4604
4605
4606 IFN LPTSW,<
4607 MVI A,4
4608 OUT 2 ;CLEAR THE LPT
4609 XRA A
4610 STA PRTFLG##
4611 STA LPTPOS##>
4612 IFE CONSSW,<LXI H,READY>
4613
4614
4615 IFN CONSSW,<
4616 LXI H,CONSDO##>
4617 SHLD $CODE+2
4618
4619
4620 PCHL
4621
4622 IFE EXTFNC,<
4623 TBLDO: ADR(INITSA)
4624 ADR(FNS)
4625 ADR(SINFIX)
4626 ADR(SIN)
4627 ADR(FNS2)
4628 ADR(RNDFIX)
4629 ADR(RND)
4630 ADR(FNS3)
4631 ADR(SQRFIX)
4632 ADR(SQR)
4633 TBDASK: ;END OF ASK TABLE
4634 FNS: DC"WANT SIN"
4635 0
4636 FNS2: DC"WANT RND"
4637 0
4638 FNS3: DC"WANT SQR"
4639 0>
4640 IFN EXTFNC,<
4641 FNS: DC"WANT SIN-COS-TAN-ATN"
4642
4643
4644
4645
4646
4647
4648
4649
4650
4651
4652
4653
4654
4655
4656
4657
4658
4659
4660
4661
4662 0>
4663 AUTTXT: ACRLF
4664
4665 ^D10
4666 DC"WRITTEN BY BILL GATES & PAUL ALLEN & MONTE DAVIDOFF."
4667
4668
4669
4670
4671
4672
4673
4674
4675
4676
4677
4678
4679
4680
4681
4682
4683
4684
4685
4686
4687
4688
4689
4690
4691
4692
4693
4694
4695
4696
4697
4698
4699
4700
4701
4702
4703
4704
4705
4706
4707
4708
4709
4710
4711
4712
4713
4714
4715
4716
4717
4718
4719 ACRLF
4720
4721 0
4722
4723 TTYWID: DC"TERMINAL WIDTH"
4724
4725
4726
4727
4728
4729
4730
4731
4732
4733
4734
4735
4736
4737
4738 0
4739 WORDS: DC" BYTES FREE"
4740
4741
4742
4743
4744
4745
4746
4747
4748
4749
4750
4751 ACRLF
4752
4753 ACRLF
4754
4755 DC"ALTAIR BASIC VERSION 3.0"
4756
4757
4758
4759
4760
4761
4762
4763
4764
4765
4766
4767
4768
4769
4770
4771
4772
4773
4774
4775
4776
4777
4778
4779
4780 ACRLF
4781
4782 IFE LENGTH,<DC"[FOUR-K VERSION]">
4783 IFE LENGTH-1,<DC"[EIGHT-K VERSION]">
4784
4785
4786
4787
4788
4789
4790
4791
4792
4793
4794
4795
4796
4797
4798
4799
4800
4801 IFE LENGTH-2,<DC"[BIG VERSION]">
4802 ACRLF
4803
4804 0
4805
4806 MEMORY: DC"MEMORY SIZE"
4807
4808
4809
4810
4811
4812
4813
4814
4815
4816
4817
4818 0
4819 LASTWR: ;LAST WORD OF SYSTEM CODE+1
4820 BLOCK ^D30 ;SPACE FOR TEMP STACK
4821 TSTACK:
4822 IFE LENGTH,<
4823 BLOCK ^D13000>
4824 IFN LENGTH,<
4825 BLOCK ^D10000>
4826 .C2==:.P
4827 END
