  52          PUSH     D        
  53          PUSH     B>       
  55          POP      B        
  56          POP      D>       
 179 FADDH:   LXI      H,FHALF                  ;ENTRY TO ADD 1/2
 182 FADDS:   CALL     MOVRM                    ;GET ARGUMENT INTO THE REGISTERS
 185          JMP      FADD                     ;DO THE ADDITION
 192 FSUBS:   CALL     MOVRM>                   ;ENTRY IF POINTER TO ARG IS IN (HL)
 200 FSUB:    CALL     NEG                      ;NEGATE SECOND ARGUMENT
 212 FADD:    MOV      A,B                      ;CHECK IF FIRST ARGUMENT IS ZERO
 213          ORA      A                        ;GET EXPONENT
 214          RZ                                ;IT IS, RESULT IS NUMBER IN FAC
 215          LDA      FAC                      ;GET EXPONENT
 218          ORA      A                        ;SEE IF THE NUMBER IS ZERO
 219          JZ       MOVER                    ;IT IS, ANSWER IS IN REGISTERS
 226          SUB      B                        ;CHECK RELATIVE SIZES
 227          JNC      FADD1                    ;IS FAC SMALLER?
 230          CMA                               ;YES, NEGATE SHIFT COUNT
 231          INR      A        
 232          XCHG                              ;SWITCH FAC AND REGISTERS, SAVE (DE)
 233          CALL     PUSHF                    ;PUT FAC ON STACK
 236          XCHG                              ;GET (DE) BACK WHERE IT BELONGS
 237          CALL     MOVER                    ;PUT REGISTERS IN THE FAC
 244          CPI      31                       ;ARE WE WITHIN 24 BITS?
 247          PUSH     PSW                      ;SAVE SHIFT COUNT
 248          CALL     UNPACK                   ;UNPACK THE NUMBERS
 251          MOV      H,A                      ;SAVE SUBTRACTION FLAG
 252          POP      PSW                      ;GET SHIFT COUNT BACK
 253          CALL     SHIFTR                   ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
 268          ORA      H                        ;GET SUBTRACTION FLAG
 269          LXI      H,FACLO                  ;SET POINTER TO LO'S
 272          JP       FADD3                    ;SUBTRACT IF THE SIGNS WERE DIFFERENT
 275          CALL     FADDA                    ;ADD THE NUMBERS
 278          JNC      ROUND                    ;ROUND RESULT IF THERE WAS NO OVERFLOW
 282          INX      H                        ;THERE WAS OVERFLOW
 283          INR      M                        ;INCREMENT EXPONENT
 284          JZ       OVERR                    ;CHECK FOR OVERFLOW
 288          CALL     SHFTRO>                  ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
 290          MVI      L,1                      ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
 292          CALL     SHRADD>  
 295          JMP      ROUND                    ;ROUND RESULT AND WE ARE DONE
 299 FADD3:   XRA      A                        ;SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
 300          SUB      8        
 301          MOV      B,A                      ;SAVE IT
 302          MOV      A,M                      ;SUBTRACT LOW ORDERS
 303          SBB      E        
 304          MOV      E,A      
 305          INX      H                        ;UPDATE POINTER TO NEXT BYTE
 306          MOV      A,M                      ;SUBTRACT MIDDLE ORDERS
 307          SBB      D        
 308          MOV      D,A      
 309          INX      H                        ;UPDATE POINTER TO HIGH ORDERS
 310          MOV      A,M                      ;SUBTRACT HIGH ORDERS
 311          SBB      C        
 312          MOV      C,A      
 315 FADFLT:  CC       NEGR                     ;ENTRY FROM FLOATR, INT: NEGATE NUMBER IF IT
 328          MVI      H,0                      ;CLEAR SHIFT COUNT
 329          MOV      A,C                      ;IS THE NUMBER NORMALIZED?
 330          ORA      A        
 331          JM       ROUND                    ;YES, WE ARE DONE
 332 NORM2:   CPI      340                      ;IS THE RESULT ZERO?
 333          JZ       ZERO                     ;YES, ZERO THE FAC
 335          MOV      A,B                      ;SHIFT THE LO LEFT
 336          ADD      A                        ;SHIFT IN A ZERO
 337          MOV      B,A      
 338          CALL     SHFTLO                   ;SHIFT THE REST OF THE NUMBER LEFT ONE
 339          MOV      A,H                      ;GET THE SHIFT COUNT
 340          JP       NORM2>                   ;CONTINUE IF NUMBER IS NOT NORMALIZED
 342          MOV      L,B                      ;PUT LOWEST 2 BYTES IN (HL)
 343          MOV      H,E      
 344          XRA      A                        ;ZERO SHIFT COUNT
 345 NORM1:   MOV      B,A                      ;SAVE SHIFT COUNT
 346          MOV      A,C                      ;DO WE HAVE 1 BYTE OF ZEROS
 347          ORA      A        
 348          JNZ      NORM3                    ;NO, SHIFT ONE PLACE AT A TIME
 352          MOV      C,D                      ;YES, SHIFT OVER 1 BYTE
 353          MOV      D,H      
 354          MOV      H,L      
 355          MOV      L,A                      ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
 356          MOV      A,B                      ;UPDATE SHIFT COUNT
 357          SUI      10       
 359          CPI      340                      ;DID WE SHIFT IN 4 BYTES OF ZEROS?
 361          JNZ      NORM1                    ;NO, TRY TO SHIFT OVER 8 MORE
 372 ZERO:    XRA      A                        ;ZERO A
 373 ZERO0:   STA      FAC                      ;ZERO THE FAC'S EXPONENT, ENTRY IF A=0
 376          RET                               ;ALL DONE
 380          DAD      H                        ;ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
 381          MOV      A,D                      ;ROTATE NEXT HIGHER ORDER LEFT ONE
 382          RAL      
 383          MOV      D,A      
 384          MOV      A,C                      ;ROTATE HIGH ORDER LEFT ONE
 385          ADC      A                        ;SET CONDITION CODES
 386          MOV      C,A      
 387 NORM3:   JP       NORM2                    ;WE HAVE MORE NORMALIZATION TO DO
 390          MOV      A,B                      ;ALL NORMALIZED, GET SHIFT COUNT
 391          MOV      E,H                      ;PUT LO'S BACK IN E,B
 392          MOV      B,L      
 393          ORA      A                        ;CHECK IF WE DID NO SHIFTING
 394          JZ       ROUND>   
 397          LXI      H,FAC                    ;LOOK AT FAC'S EXPONENT
 400          ADD      M                        ;UPDATE EXPONENT
 401          MOV      M,A      
 402          JNC      ZERO                     ;CHECK FOR UNDERFLOW
 405          RZ                                ;NUMBER IS ZERO, ALL DONE
 412 ROUND:   MOV      A,B                      ;SEE IF WE SHOULD ROUND UP
 413 ROUNDB:  LXI      H,FAC                    ;ENTRY FROM FDIV, GET POINTER TO EXPONENT
 416          ORA      A        
 417          CM       ROUNDA                   ;DO IT IF NECESSARY
 420          MOV      B,M                      ;PUT EXPONENT IN B
 422          INX      H                        ;POINT TO SIGN
 423          MOV      A,M                      ;GET SIGN
 424          ANI      200                      ;GET RID OF UNWANTED BITS
 426          XRA      C                        ;PACK SIGN AND HO
 427          MOV      C,A                      ;SAVE IT IN C
 428          JMP      MOVER                    ;SAVE NUMBER IN FAC
 437 SHFTLO:  MOV      A,E                      ;GET THE LO
 438          RAL                               ;SHIFT IT
 439          MOV      E,A                      ;SAVE IT
 440          MOV      A,D                      ;SHIFT THE NEXT HIGHER ORDER
 441          RAL      
 442          MOV      D,A      
 443          MOV      A,C                      ;SHIFT THE HIGHEST ORDER
 444          ADC      A                        ;ROTATE A LEFT AND SET CONDITION CODES
 445          MOV      C,A      
 450 ROUNDA:  INR      E                        ;ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
 451          RNZ                               ;ALL DONE IF IT IS NOT ZERO
 452          INR      D                        ;ADD ONE TO NEXT HIGHER ORDER
 453          RNZ                               ;ALL DONE IF NO OVERFLOW
 454          INR      C                        ;ADD ONE TO THE HIGHEST ORDER
 455          RNZ                               ;RETURN IF NO OVEFLOW
 456          MVI      C,200                    ;THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
 458          INR      M                        ;UPDATE EXPONENT
 459          RNZ                               ;RETURN IF IT DID NOT OVERFLOW
 463 OVERR:   MVI      E,ERROV                  ;SET OVERFLOW ERROR CODE
 465          JMP      ERROR                    ;GO TO IT!!
 472 FADDA:   MOV      A,M                      ;GET LOWEST ORDER
 473          ADD      E                        ;ADD IN OTHER LOWEST ORDER
 474          MOV      E,A                      ;SAVE IT
 475          INX      H                        ;UPDATE POINTER TO NEXT BYTE
 476          MOV      A,M                      ;ADD MIDDLE ORDERS
 477          ADC      D        
 478          MOV      D,A      
 479          INX      H                        ;UPDATE POINTER TO HIGH ORDER
 480          MOV      A,M                      ;ADD HIGH ORDERS
 481          ADC      C        
 482          MOV      C,A      
 483          RET                               ;ALL DONE
 489 NEGR:    LXI      H,FAC+1                  ;NEGATE FAC
 492          MOV      A,M                      ;GET SIGN
 493          CMA                               ;COMPLEMENT IT
 494          MOV      M,A                      ;SAVE IT AGAIN
 495          XRA                               ;ZERO A
 496          MOV      L,A                      ;SAVE ZERO IN L
 497          SUB      B                        ;NEGATE LOWEST ORDER
 498          MOV      B,A                      ;SAVE IT
 499          MOV      A,L                      ;GET A ZERO
 500          SBB      E                        ;NEGATE NEXT HIGHEST ORDER
 501          MOV      E,A                      ;SAVE IT
 502          MOV      A,L                      ;GET A ZERO
 503          SBB      D                        ;NEGATE NEXT HIGHEST ORDER
 504          MOV      D,A                      ;SAVE IT
 505          MOV      A,L                      ;GET ZERO BACK
 506          SBB      C                        ;NEGATE HIGHEST ORDER
 507          MOV      C,A                      ;SAVE IT
 508          RET                               ;ALL DONE
 516 SHIFTR:  MVI      B,0                      ;ZERO OVERFLOW BYTE
 519          INR      A>                       ;ADD ONE TO SHIFT COUNT
 521 SHFTR1:  SUI      10                       ;CAN WE SHIFT IT 8 RIGHT?
 523          JC       SHFTR2                   ;NO, SHIFT IT ONE PLACE AT A TIME
 527          MOV      B,E                      ;SHIFT NUMBER 1 BYTE RIGHT
 528          MOV      E,D      
 529          MOV      D,C      
 530          MVI      C,0                      ;PUT 0 IN HO
 532          JMP      SHFTR1                   ;TRY TO SHIFT 8 RIGHT AGAIN
 535 SHFTR2:  ADI      11>                      ;CORRECT SHIFT COUNT
 537          MOV      L,A                      ;SAVE SHIFT COUNT
 538 SHFTR3:  XRA      A                        ;CLEAR CARRY
 539          DCR      L                        ;ARE WE DONE SHIFTING?
 540          RZ                                ;RETURN IF WE ARE
 542 SHRADD:  CALL     SHFTRO>                  ;SHIFT THE NUMBER RIGHT ONE
 544          MOV      A,C                      ;GET HO
 545 SHRADD:  RAR                               ;ENTRY FROM FADD, SHIFT IT RIGHT
 546          MOV      C,A                      ;SAVE IT
 547          MOV      A,D                      ;SHIFT NEXT BYTE RIGHT
 548          RAR      
 549          MOV      D,A      
 550          MOV      A,E                      ;SHIFT LOW ORDER RIGHT
 551          RAR      
 552          MOV      E,A      
 553          MOV      A,B                      ;SHIFT OVERFLOW BYTE RIGHT
 554          RAR      
 555          MOV      B,A>     
 556          JMP      SHFTR3                   ;SEE IF WE ARE DONE
 565 SHFTRO:  MOV      A,C                      ;GET THE HO
 566 SHFROA:  RAR                               ;SHIFT IT RIGHT, ENTRY FROM FMULT
 567          MOV      C,A      
 568          MOV      A,D                      ;SHIFT THE MO RIGHT
 569          RAR      
 570          MOV      D,A      
 571          MOV      A,E                      ;SHIFT THE LO
 572          RAR      
 573          MOV      E,A      
 574          MOV      A,B                      ;SHIFT THE EXTRA LO BYTE
 575          RAR      
 576          MOV      B,A      
 605          JPE      FCERR                    ;FAC .LE. 0, BLOW HIM OUT OF THE WATER
 610          LXI      H,FAC                    ;GET POINTER TO EXPONENT
 613          MOV      A,M                      ;GET EXPONENT IN A
 620          SUB      B                        ;REMOVE EXCESS 200
 621          PUSH     PSW                      ;SAVE EXPONENT FOR LATER
 622          MOV      M,B                      ;SET EXP TO 200, RESULT IS NUM IN (.5,1)
 625          CALL     FADD                     ;CALCULATE (F-SQR(.5))/(F+SQR(.5))
 630          INR      8                        ;GET SQR(2)
 631          CALL     FDIV                     ;WHERE F=NUMBER LEFT IN FAC
 634          LXI      H,FONE                   ;THE CALCULATION IS EQUIVALENT TO THE ABOVE,
 637          CALL     FSUBS                    ;BUT DONE IN A DIFFERENT ORDER
 640          LXI      H,LOGCN2                 ;EVALUATE APPROXIMATION POLYNOMIAL
 643          CALL     POLYX    
 652          CALL     FADD                     ;ADD IN LAST CONSTANT
 655          POP      PSW                      ;RETRIEVE ORIGINAL EXPONENT
 656          CALL     FINLOG                   ;ADD IT TO ORIGINAL NUMBER
 671 FMULTS:  CALL     MOVRM>                   ;ENTRY WITH POINTER TO ARG IN (HL)
 677          RZ                                ;IF IT IS, RESULT IS ZERO
 678          MVI      L,0                      ;ADD THE TWO EXPONENTS, L IS A FLAG
 680          CALL     MULDIV                   ;FIX UP THE EXPONENTS
 684          MOV      A,C                      ;GET HO
 685          STA      FMULTA+1                 ;STORE HO OF REGISTERS
 688          XCHG                              ;STORE THE TWO LO'S OF THE REGISTERS
 689          SHLD     FMULTB+1 
 692          LXI      B,$CODE                  ;ZERO THE PRODUCT REGISTERS
 695          MOV      D,B      
 696          MOV      E,B      
 697          LXI      H,NORMAL                 ;PUT ADDRESS OF NORMAL, WERE WE FINISH UP,
 700          PUSH     H                        ;ON THE STACK
 701          LXI      H,FMULT2                 ;PUT FMULT2 ON THE STACK TWICE, SO AFTER
 704          PUSH     H                        ;WE MULTIPLY BY THE LO BYTE, WE WILL
 705          PUSH     H                        ;MULTIPLY BY THE MO AND HO
 706          LXI      H,FACLO                  ;GET ADDRESS OF LO OF FAC
 709 FMULT2:  MOV      A,M                      ;GET BYTE TO MULTIPLY BY
 710          INX      H                        ;MOVE POINTER TO NEXT BYTE
 712          ORA      A        
 713          JZ       FMULT3>                  ;ARE WE MULTIPLYING BY ZERO?
 716          PUSH     H                        ;SAVE POINTER
 718          MVI      L,10>                    ;SET UP A COUNT
 720          XCHG                              ;GET LO'S IN (HL)
 721          MVI      E,10>                    ;SET UP A COUNT
 735 FMULT4:  RAR                               ;ROTATE BYTE RIGHT
 737          MOV      H,A:                     ;SAVE THE COUNT
 739          MOV      D,A>                     ;SAVE IT
 740          MOV      A,C                      ;GET HO
 741          JNC      FMULT5                   ;DON'T ADD IN NUMBER IF BIT WAS ZERO
 746          PUSH     D                        ;SAVE COUNTERS
 747 FMULTB:  LXI      D,$CODE                  ;GET LO'S OF NUMBER TO ADD, THIS IS SET ABOVE
 750          DAD      D                        ;ADD THEM IN
 751          POP      D                        ;GET COUNTERS BACK
 752 FMULTA:  ACI      0                        ;ADD IN HO, THIS IS SET UP ABOVE
 755          XCHG                              ;PUT THE LO'S BACK IN (DE)
 756 FMULT5:  CALL     SHFROA                   ;SHIFT THE RESULT RIGHT ONE
 758          MOV      A,H>                     ;GET NUMBER WE ARE MULTIPLYING BY
 760 FMULT5:  RAR                               ;ROTATE RESULT RIGHT ONE
 761          MOV      C,A      
 762          MOV      A,H                      ;ROTATE NEXT BYTE
 763          RAR      
 764          MOV      H,A      
 765          MOV      A,L                      ;ROTATE NEXT LOWER ORDER
 766          RAR      
 767          MOV      L,A      
 768          MOV      A,B                      ;ROTATE LO
 769          RAR      
 770          MOV      B,A      
 771          DCR      E                        ;ARE WE DONE?
 772          MOV      A,D>                     ;GET NUMBER WE ARE MULTIPLYING BY
 773          JNZ      FMULT4                   ;MULTIPLY AGAIN IF WE ARE NOT DONE
 778 POPHRT:  POP      H                        ;GET POINTER TO NUMBER TO MULTIPLY BY
 779          RET                               ;ALL DONE
 781 FMULT3:  MOV      B,E                      ;MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
 782          MOV      E,D      
 783          MOV      D,C      
 784          MOV      C,A                      ;SHIFT IN 8 ZEROS ON THE LEFT
 790 DIV10:   CALL     PUSHF                    ;SAVE NUMBER
 800          CALL     MOVFR>                   ;MOVE THE CONSTANT TO THE FAC
 804          LXI      H,FTEN                   ;GET POINTER TO THE CONSTANT '10'
 805          CALL     MOVFM>                   ;MOVE TEN INTO THE FAC
 814          JZ       DVDERR                   ;HE IS TRYING TO GET AWAY WITH IT
 817          MVI      L,377                    ;SUBTRACT THE TWO EXPONENTS, L IS A FLAG
 819          CALL     MULDIV                   ;FIX UP THE EXPONENTS AND THINGS
 822          INR      M                        ;ADD 2 TO EXPONENT TO CORRECT SCALING
 823          INR      M        
 826          DCX      H                        ;POINT TO HO
 827          MOV      A,M                      ;GET HO
 828          STA      FOIVA+1                  ;SAVE IT
 831          DCX      H                        ;SAVE MIDDLE ORDER
 832          MOV      A,M      
 833          STA      FDIVB+1                  ;PUT IT WHERE NOTHING WILL HURT IT
 836          DCX      H                        ;SAVE LO
 837          MOV      A,M      
 838          STA      FDIVC+1  
 864          MOV      B,C                      ;GET NUMBER IN B,H,L
 865          XCHG     
 866          XRA      A                        ;ZERO C,D,E AND HIGHEST ORDER
 867          MOV      C,A      
 868          MOV      D,A      
 869          MOV      E,A      
 870          STA      FDIVG+1  
 873 FDIVI:   PUSH     H                        ;SAVE LO'S OF NUMBER
 874          PUSH     B                        ;SAVE HO OF NUMBER
 875          MOV      A,L                      ;SUBTRACT NUMBER THAT WAS IN FAC
 876 FDIVC:   SUI      0                        ;SUBTRACT LO
 878          MOV      L.A                      ;SAVE IT
 879          MOV      A,H                      ;SUBTRACT MIDDLE ORDER
 880 FDIVB:   SBI      0        
 882          MOV      H,A      
 883          MOV      A,B                      ;SUBTRACT HO
 884 FDIVA:   SBI      0        
 886          MOV      B,A      
 887 FDIVG:   MVI      A,0                      ;GET HIGHEST ORDER
 889          SBI      0                        ;SUBTRACT THE CARRY FROM IT
 891          CMC                               ;SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
 892          JNC      FDIV2                    ;GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
 895          STA      FDIVG+1                  ;UPDATE HIGHEST ORDER
 898          POP      PSW                      ;THE SUBTRACTION WAS GOOD
 899          POP      PSW                      ;GET PREVIOUS NUMBER OFF STACK
 900          STC                               ;NEXT BIT IN QUOTIENT IS A ONE
 902 FDIV2:   POP      B                        ;WE SUBTRACTED TOO MUCH
 903          POP      H                        ;GET OLD NUMBER BACK
 904          MOV      A,C                      ;ARE WE DONE?
 905          INR      A                        ;SET SIGN FLAG WITHOUT AFFECTING CARRY
 906          DCR      A        
 907          RAR                               ;PUT CARRY IN MSB
 908          JM       ROUNDB                   ;WE ARE DONE
 911          RAL                               ;WE AREN'T, GET OLD CARRY BACK
 913          CALL     SHFTLO>                  ;ROTATE EVERYTHING LEFT ONE
 915          MOV      A,E                      ;ROTATE EVERYTHING LEFT ONE
 916          RAL                               ;ROTATE NEXT BIT OF QUOTIENT IN
 917          MOV      E,A      
 919          RAL      
 920          MOV      D,A      
 921          MOV      A,C      
 922          RAL      
 923          MOV      C,A>     
 924          DAD      H                        ;ROTATE A ZERO INTO RIGHT END OF NUMBER
 925          MOV      A,B                      ;THE HO BYTE, FINALLY!
 926          RAL      
 927          MOV      B,A      
 928          LDA      FDIVG+1                  ;ROTATE THE HIGHEST ORDER
 931          RAL      
 932          STA      FDIVG+1  
 935          MOV      A,C                      ;ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
 936          ORA      D                        ;DID NOT WORK
 937          ORA      E        
 938          JNZ      FDIV1                    ;THIS ISN'T THE CASE
 941          PUSH     H                        ;SAVE PART OF NUMBER
 942          LXI      H,FAC                    ;GET POINTER TO FAC
 945          DCR      M                        ;DECREMENT EXPONENT
 946          POP      H                        ;GET NUMBER BACK
 947          JNZ      FDIVI                    ;DIVIDE MORE IF NO OVERFLOW OCCURED
 950          JMP      OVERR                    ;OVERFLOW!!
 958 MULDVS:  MVI      A,377                    ;ENTRY FROM DDIV, SUBTRACT EXPONENTS
 960 MULDVA:  XRA      A                        ;ENTRY FROM DMULT, ADD EXPONENTS
 961          LXI      H,ARG-1                  ;GET POINTER TO SIGN AND HO OF ARG
 962          MOV      C,M                      ;GET HO AND SIGN FOR UNPACKING
 963          INX      H                        ;INCREMENT POINTER TO EXPONENT
 964          MOV      B,M                      ;GET EXPONENT FOR BELOW
 965          MOV      L,A>                     ;SAVE ADD OR SUBTRACT FLAG
 966 MULDIV:  MOV      A,B                      ;IS NUMBER IN REGISTERS ZERO?
 967          ORA      A        
 968          JZ       MULDV2                   ;IT IS, ZERO FAC AND WE ARE DONE
 971          MOV      A,L                      ;GET ADD OR SUBTRACT FLAG
 972          LXI      H,FAC                    ;GET POINTER TO EXPONENT
 975          XRA      M                        ;GET EXPONENT
 976          ADD      8                        ;ADD IN REGISTER EXPONENT
 977          MOV      B,A                      ;SAVE IT
 978          RAR                               ;CHECK FOR OVERFLOW
 979          XRA      B                        ;OVERFLOW IF SIGN IS THE SAME AS CARRY
 980          MOV      A,B                      ;GET SUM
 981          JP       MULDV1                   ;WE HAVE OVERFLOW!!
 984          ADI      200                      ;PUT EXPONENT IN EXCESS 200
 986          MOV      M,A                      ;SAVE IT IN THE FAC
 987          JZ       POPHRT                   ;WE HAVE UNDEFLOW!! RETURN,
 990          CALL     UNPACK                   ;UNPACK THE ARGUMENTS
 993          MOV      M,A                      ;SAVE THE NEW SIGN
 994          DCX      H                        ;POINT TO EXPONENT
 995          RET                               ;ALL DONE, LEAVE HO IN A
 998          CMA                               ;PICK OVERFLOW IF POSITIVE
 999          POP      H>                       ;DON'T SCREW UP STACK
1000 MULDV1:  ORA      A                        ;IS ERROR OVERFLOW OR UNDEFLOW?
1001 MULDV2:  POP      H                        ;GET OLD RETURN ADDRESS OFF STACK
1003          JM       OVERR                    ;OVERFLOW
1010 ZERO:    XRA      A                        ;ZERO A
1011          STA      FAC                      ;ZERO FAC
1016          JP       ZERO                     ;UNDERFLOW
1019          JMP      OVERR>                   ;OVERFLOW
1026 MUL10:   CALL     MOVRF                    ;GET NUMBER IN REGISTERS
1029          MOV      A,B                      ;GET EXPONENT
1030          ORA      A                        ;RESULT IS ZERO IF ARG IS ZERO
1031          RZ                                ;IT IS
1032          ADI      2                        ;MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
1034          JC       OVERR                    ;OVERFLOW!!
1037          MOV      B,A                      ;RESTORE EXPONENT
1038          CALL     FADD                     ;ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
1041          LXI      H,FAC                    ;ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
1044          INR      M                        ;2 TO GET 10 TIMES ORIGINAL NUMBER
1045          RNZ                               ;ALL DONE IF NO OVERFLOW
1046          JMP      OVERR                    ;OVERFLOW!!
1059 SIGN:    LDA      FAC                      ;CHECK IF THE NUMBER IS ZERO
1060          ORA      A        
1062 SIGNC:   LDA      FAC-1                    ;GET SIGN OF FAC, IT IS NON-ZERO
1066 FCOMPS:  CMA                               ;ENTRY FROM FCOMP, COMPLEMENT SIGN
1067 ICOMPS:  RAL                               ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
1068 SIGNS:   SBB      A                        ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
1069          RNZ                               ;RETURN IF NUMBER WAS NEGATIVE
1070 INRART:  INR      A                        ;PUT ONE IN A IF NUMBER WAS POSITIVE
1071          RET                               ;ALL DONE
1083 FLOAT:   MVI      B,210                    ;SET EXPONENT CORRECTLY
1085          LXI      D,$CODE                  ;ZERO D,E
1093 FLOATR:  LXI      H,FAC                    ;GET POINTER TO FAC
1096          MOV      C,A                      ;PUT HO IN C
1097          MOV      M,B                      ;PUT EXPONENT IN THE FAC
1098          MVI      B,0                      ;ZERO OVERFLOW BYTE
1100          INX      H                        ;POINT TO SIGN
1101          MVI      M,200                    ;ASSUME A POSITIVE NUMBER
1103          RAL                               ;PUT SIGN IN CARRY
1104          JMP      FADFLT                   ;GO AND FLOAT THE NUMBER
1113          CPI      2                        ;IS THE ARGUMENT AN INTEGER?
1114          JZ       IABS>                    ;YES, USE THE INTEGER ABSOLUTE VALUE
1116          RP                                ;ALL DONE IF IT IS POSITIVE
1123 NEG:     LXI      H,FAC-1                  ;GET POINTER TO SIGN
1126          MOV      A,M                      ;GET SIGN
1127          XRI      200                      ;COMPLEMENT SIGN BIT
1129          MOV      M,A                      ;SAVE IT
1130          RET                               ;ALL DONE
1136 VNEG:    LDA      VALTYP                   ;SEE WHAT KIND OF NUMBER WE HAVE
1137          CPI      2        
1139          JM       TMERR                    ;BLOW UP ON STRINGS
1140          JMP      NEG                      ;NEGATE SNG AND DBL THE SAME
1145 SGN:     CALL     VSIGN                    ;GET THE SIGN OF THE FAC IN A
1146          MOV      L,A                      ;PUT IT IN THE LO POSITION
1147          RAL                               ;EXTEND THE SIGN TO THE HO
1148          SBB      A        
1149          MOV      H,A      
1150          JMP      CONISS                   ;RETURN THE RESULT AND SET VALTYP
1156 VSIGN:   CPI      2                        ;IS THE ARGUMENT AN INTEGER?
1157          JNZ      SIGN                     ;NO, SINGLE AND DOUBLE PREC. WORK THE SAME
1158          LHLD     FACLO                    ;GET THE INTEGER ARGUMENT
1159          MOV      A,H                      ;GET ITS SIGN
1160          ORA      L                        ;CHECK IF THE NUMBER IS ZERO
1161          RZ                                ;IT IS, WE ARE DONE
1162          MOV      A,H                      ;IT ISN'T, SIGN IS THE SIGN OF H
1163          JMP      ICOMPS>                  ;GO SET A CORRECTLY
1168 PUSHF:   XCHG                              ;SAVE (HL)
1169          LHLD     FACLO                    ;GET LO'S
1172          XTHL                              ;SWITCH LO'S AND RET ADDR
1173          PUSH     H                        ;PUT RET ADDR BACK ON STACK
1174          LHLD     FAC-1                    ;GET HO'S
1177          XTHL                              ;SWITCH HO'S AND RET ADDR
1178          PUSH     H                        ;PUT RET ADDR BACK ON STACK
1179          XCHG                              ;GET OLD (HL) BACK
1180          RET                               ;ALL DONE
1187 MOVFM:   CALL     MOVRM                    ;GET NUMBER IN REGISTERS
1195 MOVER:   XCHG                              ;GET LO'S IN (HL)
1196          SHLD     FACLO                    ;PUT THEM WHERE THEY BELONG
1199          MOV      H,B                      ;GET HO'S IN (HL)
1200          MOV      L,C      
1204          XCHG                              ;GET OLD (HL) BACK
1205          RET                               ;ALL DONE
1210 MOVRF:   LXI      H,FACLO                  ;GET POINTER TO FAC
1219 MOVRM:   MOV      E,M                      ;GET LO
1220          INX      H                        ;POINT TO MO
1221          MOV      D,M                      ;GET MO
1222          INX      H                        ;POINT TO HO
1223          MOV      C,M                      ;GET HO
1224          INX      H                        ;POINT TO EXPONENT
1225          MOV      B,M                      ;GET EXPONENT
1226 INXHRT:  INX      H                        ;INC POINTER TO BEGINNING OF NEXT NUMBER
1227          RET                               ;ALL DONE
1232 MOVMF:   LXI      D,FACLO                  ;GET POINTER TO FAC
1241 MOVE:    MVI      B,4                      ;SET COUNTER
1247          MOV      M,A                      ;PUT IT WHERE IT BELONGS
1248          INX      D                        ;INCREMENT POINTERS TO NEXT WORD
1249          INX      H        
1250          DCR      B                        ;SEE IF DONE
1251          JNZ      MOVE1    
1254          RET      
1262 UNPACK:  LXI      H,FAC-1                  ;POINT TO HD AND SIGN
1265          MOV      A,M                      ;GET HO AND SIGN
1266          PUSH     PSW                      ;SAVE SIGN
1267          ORI      200                      ;RESTORE THE HIDDEN ONE
1269          MOV      M,A                      ;SAVE HO
1270          POP      PSW                      ;GET SIGN
1271          XRA      M                        ;GET COMPLEMENT OF SIGN IN MSB
1272          INX      H                        ;POINT TO TEMPORARY SIGN BYTE
1273          INX      H        
1274          MOV      M,A                      ;SAVE COMPLEMENT OF SIGN
1275          MOV      A,C                      ;GET HO AND SIGN OF THE REGISTERS
1276          PUSH     PSW                      ;SAVE SIGN
1277          ORI      200                      ;RESTORE THE HIDDEN ONE
1279          MOV      C,A                      ;SAVE THE HO
1280          POP      PSW                      ;GET THE SIGN BACK
1281          XRA      M                        ;COMPARE SIGN OF FAC AND SIGN OF REGISTERS
1282          RET                               ;ALL DONE
1290 VPUSHF:  LDA      VALTYP                   ;GET THE VALUE TYPE
1291          CPI      4                        ;SET FLAGS ACCORDING TO VALTYP
1292          LXI      H,FACLO                  ;GET POINTER TO LO IN FAC
1294          JM       VPUSHD                   ;RETURN IF THE DATA WAS AN INTEGER OR A STRING
1296          JZ       VPUSHD                   ;RETURN IF WE HAD A SINGLE PRECISION NUMBER
1297          LXI      D,FACLO                  ;WE HAVE A DOUBLE PRECISON NUMBER
1305 VMOVFA:  LXI      H,ARGLO                  ;ENTRY FROM DADD, MOVE ARG TO FAC
1306 VMOVFM:  LXI      D,MOVVFM                 ;GET ADDRESS OF LOCATION THAT DOES
1307          JMP      VMVVFM                   ;AN "XCHG" AND FALLS INTO MOVE1
1312 VMOVAF:  LXI      H,ARGLO                  ;ENTRY FROM FIN, DMUL10, DDIV10
1314 VMOVMF:  LXI      D,MOVE1                  ;GET ADDRESS OF MOVE SUBROUTINE
1315 VMVVFM:  PUSH     D                        ;SHOVE IT ON THE STACK
1316          LXI      D,FACLO                  ;GET FIRST ADDRESS FOR INT, SNG
1318          ANI      177                      ;STRINGS LOOK LIKE REALS
1319          MOV      B,A                      ;SET UP THE COUNT
1320          CPI      10                       ;DO WE HAVE DBL?
1321          RNZ                               ;WE DO NOT, GO DO THE MOVE
1322          LXI      D,DFACLO                 ;WE DO, GET LO ADDR OF THE DBL NUMBER
1333 FCOMP:   MOV      A,B                      ;CHECK IF ARG IS ZERO
1334          ORA      A        
1335          JZ       SIGN     
1338          LXI      H,FCOMPS                 ;WE JUMP TO FCOMPS WHEN WE ARE DONE
1341          PUSH     H                        ;PUT THE ADDRESS ON THE STACK
1343          MOV      A,C                      ;IF IT IS, RESULT IS MINUS THE SIGN OF ARG
1344          RZ                                ;IT IS
1345          LXI      H,FAC-1                  ;POINT TO SIGN OF FAC
1348          XRA      M                        ;SEE IF THE SIGNS ARE THE SAME
1349          MOV      A,C                      ;IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
1350          RM                                ;THEY ARE DIFFERENT
1351          CALL     FCOMP2                   ;CHECK THE REST OF THE NUMBER
1354 FCOMPD:  RAR                               ;NUMBERS ARE DIFFERENT, CHANGE SIGN IF
1355          XRA      C                        ;BOTH NUMBERS ARE NEGATIVE
1356          RET                               ;GO SET UP A
1358 FCOMP2:  INX      H                        ;POINT TO EXPONENT
1359          MOV      A,B                      ;GET EXPONENT OF ARG
1360          CMP      M                        ;COMPARE THE TWO
1361          RNZ                               ;NUMBERS ARE DIFFERENT
1362          DCX      H                        ;POINT TO HO
1363          MOV      A,C                      ;GET HO OF ARG
1364          CMP      M                        ;COMPARE WITH HO OF FAC
1365          RNZ                               ;THEY ARE DIFFERENT
1366          DCX      M                        ;POINT TO MO OF FAC
1367          MOV      A,D                      ;GET MO OF ARG
1368          CMP      M                        ;COMPARE WITH MO OF FAC
1369          RNZ                               ;THE NUMBERS ARE DIFFERENT
1370          DCX      H                        ;POINT TO LO OF FAC
1371          MOV      A,E                      ;GET LO OF ARG
1372          SUB      M                        ;SUBTRACT LO OF FAC
1373          RNZ                               ;NUMBERS ARE DIFFERENT
1374          POP      H                        ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
1375          POP      H        
1376          RET                               ;ALL DONE
1385 ICOMP:   MOV      A,D                      ;ARE THE SIGNS THE SAME?
1386          XRA      H        
1387          MOV      A,H                      ;IF NOT, ANSWER IS THE SIGN OF (HL)
1388          JM       ICOMPS                   ;THEY ARE DIFFERENT
1389          CMP      D                        ;THEY ARE THE SAME, COMPARE THE HO'S
1390          JNZ      SIGNS                    ;GO SET UP A
1391          MOV      A,L                      ;COMPARE THE LO'S
1392          SUB      E        
1393          JNZ      SIGNS                    ;GO SET UP A
1394          RET                               ;ALL DONE, THEY ARE THE SAME
1402 DCOMPD:  LXI      H,ARGLO                  ;ENTRY WITH POINTER TO ARG IN (DE)
1403          MVI      B,10                     ;SET UP COUNT TO MOVE DBL NUMBERS
1404          CALL     MOVE1                    ;MOVE THE ARGUMENT INTO ARG
1405 DCOMP:   LXI      D,ARG                    ;GET POINTER TO ARG
1407          ORA      A        
1408          JZ       SIGN                     ;ARG=0, GO SET UP A
1409          LXI      H,FCOMPS                 ;PUSH FCOMPS ON STACK SO WE WILL RETURN TO
1410          PUSH     H                        ;TO IT AND SET UP A
1412          DCX      D                        ;POINT TO SIGN OF ARG
1413          LDAX     D                        ;GET SIGN OF ARG
1414          MOV      C,A                      ;SAVE IT FOR LATER
1415          RZ                                ;FAC=0, SIGN OF RESULT IS SIGN OF ARG
1416          LXI      H,FAC-1                  ;POINT TO SIGN OF FAC
1417          XRA      M                        ;SEE IF THE SIGNS ARE THE SAME
1418          MOV      A,C                      ;IF THEY ARE, GET THE SIGN OF THE NUMBERS
1419          RM                                ;THE SIGNS ARE DIFFERENT, GO SET A
1420          INX      D                        ;POINT BACK TO EXPONENT OF ARG
1421          INX      H                        ;POINT TO EXPONENT OF FAC
1422          MVI      B,10                     ;SET UP A COUNT
1424          SUB      M                        ;COMPARE IT WITH THE FAC
1425          JNZ      FCOMPD                   ;THEY ARE DIFFERENT, GO SET UP A
1426          DCX      D                        ;THEY ARE THE SAME, EXAMINE THE NEXT LOWER
1427          DCX      H                        ;ORDER BYTES
1428          DCR      B                        ;ARE WE DONE?
1429          JNZ      DCOMP1                   ;NO, COMPARE THE NEXT BYTES
1430          POP      B                        ;THEY ARE THE SAME, GET FCOMPS OFF STACK
1437 FRCINT:  LDA      VALTYP                   ;SEE WHAT WE HAVE
1438          CPI      4        
1439          LHLD     FACLO                    ;GET FACLO+0,1 IN CASE WE HAVE AN INTEGER
1440          RC                                ;WE HAVE AN INTEGER, ALL DONE
1441          JM       TMERR                    ;WE HAVE A STRING, THAT IS A "NO-NO"
1442          CNZ      CONSD                    ;IF WE HAVE A DBL, CONVERT IT TO A SNG
1443          LXI      H,OVERR                  ;PUT OVERR ON THE STACK SO WE WILL GET ERROR
1444          PUSH     H                        ;IF NUMBER IS TOO BIG
1450 CONIS:   LDA      FAC                      ;GET THE EXPONENT
1451          CPI      220                      ;SEE IF IT IS TOO BIG
1452          JNC      CONIS2                   ;IT IS, BUT IT MIGHT BE -32768
1453          CALL     QINT                     ;IT ISN'T, CONVERT IT TO AN INTEGER
1454          XCHG                              ;PUT IT IN (HL)
1455 CONIS1:  POP      D                        ;GET ERROR ADDRESS OFF STACK
1457 CONISS:  SHLD     FACLO                    ;STORE THE NUMBER IN FACLO
1458          MVI      A,2                      ;SET VALTYP TO "INTEGER"
1459 CONISD:  STA      VALTYP                   ;ENTRY FROM CONDS
1460          RET                               ;ALL DONE
1462          CALL     FCOMP    
1463          RNZ                               ;ERROR: IT CAN'T BE CONVERTED TO AN INTEGER
1464          MOV      H,C                      ;IT IS -32768, PUT IT IN (HL)
1465          MOV      L,D      
1466          JMP      CONIS                    ;STORE IT IN THE FAC AND SET VALTYP
1471 FRCSNG:  LDA      VALTYP                   ;SEE WHAT KIND OF NUMBER WE HAVE
1472          CPI      4        
1473          RZ                                ;WE ALREADY HAVE AN INTEGER, ALL DONE
1474          JC       CONSI                    ;WE HAVE AN INTEGER, CONVERT IT
1475          JM       TMERR                    ;STRINGS!! -- ERROR!!
1481 CONSO:   CALL     MOVRF                    ;GET THE HO'S IN THE REGISTERS
1482          MVI      A,4                      ;SET VALTYP TO "SINGLE PRECISON"
1483          STA      VALTYP   
1484          MOV      A,B                      ;CHECK IF THE NUMBER IS ZERO
1485          ORA      A        
1486          RZ                                ;IF IT IS, WE ARE DONE
1487          CALL     UNPACK                   ;UNPACK THE NUMBER
1488          LXI      H,FACLO-1                ;GET FIRST BYTE BELOW A SNG NUMBER
1489          MOV      B,M                      ;PUT IT IN B FOR ROUND
1490          JMP      ROUND                    ;ROUND THE DBL NUMBER UP AND WE ARE DONE
1495 CONSI:   LHLD     FACLO                    ;GET THE INTEGER
1496 CONSIH:  MVI      A,4                      ;SET VALTYP TO "SINGLE PRECISION"
1497          STA      VALTYP   
1498          MOV      A,H                      ;SET UP REGISTERS FOR FLOATR
1499          MOV      D,L      
1500          MVI      E,0      
1501          MVI      B,220    
1502          JMP      FLOATR                   ;GO FLOAT THE NUMBER
1507 FRCOBL:  LDA      VALTYP                   ;SEE WHAT KIND OF NUMBER WE HAVE
1508          CPI      10       
1509          RZ                                ;WE ALREADY HAVE A DBL, WE ARE DONE
1510          JNC      TMERR                    ;GIVE AN ERROR IF WE HAVE A STRING
1511          CPI      2                        ;SEE IF WE HAVE A SNG OR INT
1512          CZ       CONSI                    ;CONVERT TO SNG IF WE HAVE AN INT
1518 CONDS:   LXI      H,$CODE                  ;ZERO H,L
1519          SHLD     DFACLO                   ;CLEAR THE FOUR LOWER BYTES IN THE DOUBLE
1520          SHLD     DFACLO+2                 ;PRECISION NUMBER
1521          MVI      A,10                     ;SET VALTYP TO "DOUBLE PRECISION"
1522          JMP      CONISD>                  ;GO TO IT
1530 QINT:    MOV      B,A                      ;ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
1531          MOV      C,A      
1532          MOV      D,A      
1533          MOV      E,A      
1534          ORA      A                        ;SET CONDITION CODES
1535          RZ                                ;IT IS ZERO, WE ARE DONE
1547          PUSH     H                        ;SAVE (HL)
1548          CALL     MOVRF                    ;GET NUMBER IN THE REGISTERS
1551          CALL     UNPACK                   ;UNPACK THE NUMBER
1554          XRA      M                        ;GET SIGN OF NUMBER
1555          MOV      H,A                      ;DON'T LOSE IT
1556          CM       QINTA                    ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1559          MVI      A,230                    ;SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
1561          SUB      B                        ;NUMBER TO AN INTEGER
1562          CALL     SHIFTR                   ;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
1565          MOV      A,H                      ;GET SIGN
1566          RAL                               ;PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
1567          CC       ROUNDA                   ;IF NUMBER WAS NEGATIVE, ADD ONE
1570          MVI      B,0                      ;FORGET THE BITS WE SHIFTED OUT
1572          CC       NEGR                     ;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
1576          POP      H                        ;GET OLD (HL) BACK
1577          RET                               ;ALL DONE
1579 QINTA:   DCX      D                        ;SUBTRACT ONE FROM C,D,E
1580          MOV      A,D                      ;WE HAVE TO SUBTRACT ONE FROM C IF
1581          ANA      E                        ;D AND E ARE BOTH ALL ONES
1582          INR      A                        ;SEE IF BOTH WERE -1
1583          RNZ                               ;THEY WERE NOT, WE ARE DONE
1585          DCR      C>                       ;THEY WERE, SUBTRACT ONE FROM C
1587 DCXBRT:  DCX      B>                       ;THIS IS FOR BILL. C WILL NEVER BE ZERO
1590          RET                               ;ALL DONE
1596 INTFNC:  CPI      4                        ;SEE WHAT KIND OF NUMBER WE HAVE
1597          RC                                ;IT IS AN INTEGER, ALL DONE
1598          JNZ      DINT                     ;CONVERT THE DOUBLE PRECISION NUMBER
1599          CALL     CONIS>                   ;TRY TO CONVERT THE NUMBER TO AN INTEGER
1602 INT:     LXI      H,FAC                    ;GET EXPONENT
1605          MOV      A,M      
1606          CPI      230                      ;SEE IF NUMBER HAS ANY FRACTIONAL BITS
1609          LDA      FACLO>                   ;ABOUT THE SIGN
1612          RNC                               ;IT DOES NOT
1614          MOV      A,M>                     ;GET EXPONENT BACK
1615          CALL     QINT                     ;IT DOES, SHIFT THEM OUT
1618          MVI      M,230                    ;CHANGE EXPONENT SO IT WILL BE CORRECT
1622          MOV      A,E                      ;GET LO
1623          PUSH     PSW>                     ;SAVE IT
1624          MOV      A,C                      ;NEGATE NUMBER IF IT IS NEGATIVE
1625          RAL                               ;PUT SIGN IN CARRY
1627          JMP      FADFLT>                  ;REFLOAT NUMBER
1629          CALL     FADFLT                   ;REFLOAT NUMBER
1632 POPPRT:  POP      PSW                      ;GET LO BACK
1639 DINT:    LXI      H,FAC                    ;GET POINTER TO FAC
1640          MOV      A,M                      ;GET EXPONENT
1641          CPI      220                      ;CAN WE CONVERT IT TO AN INTEGER?
1642          JC       FROINT                   ;THEN DO SO
1643          JNZ      DINT2                    ;CHECK FOR -32768
1644          MOV      C,A                      ;SAVE EXPONENT IN C
1645          DCX      H                        ;GET POINTER TO SIGN AND HO
1646          MOV      A,M                      ;GET SIGN AND HO
1647          XRI      200                      ;CHECK IF IT IS 200
1648          MVI      B,6                      ;SET UP A COUNT TO CHECK IF THE REST OF
1649 DINTI:   DCX      H                        ;THE NUMBER IS ZERO, POINT TO NEXT BYTE
1650          ORA      M                        ;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
1652          JNZ      DINTI                    ;NO, CHECK THE NEXT LOWER ORDER BYTE
1653          ORA      A                        ;IS A NOW ZERO?
1654          LXI      H,200*400+$CODE          ;GET -32768 JUST IN CASE
1655          JZ       CONISS                   ;A IS ZERO SO WE HAVE -32768
1656          MOV      A,C                      ;GET EXPONENT
1657 DINT2:   CPI      270                      ;ARE THERE ANY FRACTIONAL BITS?
1658          RNC                               ;NO, THE NUMBER IS ALREADY AN INTEGER
1659 DINTFO:  PUSH     PSW                      ;ENTRY FROM FOUT, CARRY IS ZERO IF WE COME
1661          CALL     MOVRF                    ;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
1662          CALL     UNPACK                   ;UNPACK IT
1663          XRA      M                        ;GET ITS SIGN BACK
1664          DCX      H                        ;SET THE EXPONENT TO NORMALIZE CORRECTLY
1665          MVI      M,270    
1666          PUSH     PSW                      ;SAVE THE SIGN
1667          CM       DINTA                    ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1668          MVI      A,270                    ;GET HOW MANY BITS WE HAVE TO SHIFT OUT
1669          SUB      8        
1670          CALL     DSHFTR                   ;SHIFT THEM OUT!!
1671          POP      PSW                      ;GET THE SIGN BACK
1672          CM       DROUNA                   ;IF NUMBER WAS NEGATIVE, ADD ONE
1673          XRA      A                        ;PUT A ZERO IN THE EXTRA LO BYTE SO WHEN
1674          STA      DFACLO-1                 ;WE NORMALIZE, WE WILL SHIFT IN ZEROS
1675          POP      PSW                      ;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE,
1676          RNC                               ;JUST RETURN
1677          JMP      ONORML                   ;RE-FLOAT THE INTEGER
1679 DINTA:   LXI      H,DFACLO                 ;SUBTRACT ONE FROM FAC, GET POINTER TO LO
1680 DINTAI:  MOV      A,M                      ;GET A BYTE OF FAC
1681          DCR      M                        ;SUBTRACT ONE FROM IT
1682          ORA      A                        ;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
1683          INX      H                        ;INCREMENT POINTER TO NEXT BYTE
1684          JZ       DINTAI                   ;CONTINUE IF NECESSARY
1692 DMULT:   LXI      H,$CODE                  ;ZERO PRODUCT REGISTERS
1695          MOV      A,B                      ;CHECK IF (BC) IS ZERO
1696          ORA      C                        ;IF SO, JUST RETURN, (HL) IS ALREADY ZERO
1697          RZ                                ;THIS IS DONE FOR SPEED
1698          MVI      A,20                     ;SET UP A COUNT
1700 DMULT1:  DAD      H                        ;ROTATE (HL) LEFT ONE
1701          JC       BSERR##                  ;CHECK FOR OVERFLOW, IF SO,
1704          XCHG                              ;BAD SUBSCRIPT (BS) ERROR
1705          DAD      H                        ;ROTATE (DE) LEFT ONE
1706          XCHG     
1707          JNC      DMULT2                   ;ADD IN (BC) IF HO WAS 1
1710          DAD      B        
1711          JC       BSERR                    ;CHECK FOR OVERFLOW
1714 DMULT2:  DCR      A                        ;SEE IF DONE
1715          JNZ      DMULT1   
1743 ISUB:    MOV      A,H                      ;EXTEND THE SIGN OF (HL) TO B
1744          RAL                               ;GET SIGN IN CARRY
1745          SBB      A        
1746          MOV      B,A      
1747          CALL     INEGHL                   ;NEGATE (HL)
1748          MOV      A,C                      ;GET A ZERO
1749          SBB      B                        ;NEGATE SIGN
1750          JMP      IADDS                    ;GO ADD THE NUMBERS
1755 ADD:     MOV      A,H                      ;EXTEND THE SIGN OF (HL) TO B
1756          RAL                               ;GET SIGN IN CARRY
1757          SBB      A        
1758 IADDS:   MOV      B,A                      ;SAVE THE SIGN
1759          PUSH     H                        ;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
1760          MOV      A,D                      ;EXTEND THE SIGN OF (DE) TO A
1761          RAL                               ;GET SIGN IN CARRY
1762          SBB      A        
1763          DAD      D                        ;ADD THE TWO LO'S
1764          ADC      B                        ;ADD THE EXTRA HO
1765          RRC                               ;IF THE LSB OF A IS DIFFERENT FROM THE MSB OF
1766          XRA      H                        ;H, THEN OVERFLOW OCCURED
1767          JP       POPPRT                   ;NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
1769          PUSH     B                        ;OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
1770          XCHG                              ;GET (DE) IN (HL)
1771          CALL     CONSIH                   ;FLOAT IT
1772          POP      PSW                      ;GET SIGN OF (HL) IN A
1773          POP      H                        ;GET OLD (HL) BACK
1774          CALL     PUSHF                    ;PUT FIRST ARGUMENT ON STACK
1775          XCHG                              ;PUT SECOND ARGUMENT IN (DE) FOR FLOATR
1776          CALL     INEGAD                   ;FLOAT IT
1778          JMP      FADD                     ;ADD THE TWO NUMBERS USING SINGLE PRECISION
1783 IMULT:   PUSH     H                        ;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
1784          PUSH     D                        ;SAVE FIRST ARGUMENT
1785          CALL     IMULOV                   ;FIX UP THE SIGNS
1786          PUSH     B                        ;SAVE THE SIGN OF THE RESULT
1787          MOV      B,H                      ;COPY SECOND ARGUMENT INTO (BC)
1788          MOV      C,L      
1789          LXI      H,$CODE                  ;ZERO (HL), THAT IS WHERE THE PRODUCT GOES
1790          MVI      A,20                     ;SET UP A COUNT
1791 IMULT1:  DAD      H                        ;ROTATE PRODUCT LEFT ONE
1792          JC       IMULTS                   ;CHECK FOR OVERLFOW
1793          XCHG                              ;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
1794          DAD      H                        ;WE ADD IN (BC) OR NOT
1795          XCHG     
1796          JNC      IMULT2                   ;DON'T ADD IN ANYTHING
1797          DAD      B                        ;ADD IN (BC)
1798          JC       IMULTS                   ;CHECK FOR OVERLFOW
1799 IMULT2:  DCR      A                        ;ARE WE DONE?
1800          JNZ      IMULT1                   ;NO, DO IT AGAIN
1801          POP      B                        ;WE ARE DONE, GET SIGN OF RESULT
1802          POP      D                        ;GET ORIGINAL FIRST ARGUMENT
1803 IMLDIV:  MOV      A,H                      ;ENTRY FROM IDIV, IS RESULT ,GE, 32768?
1804          ORA      A        
1805          JM       IMULT3                   ;IT IS, CHECK FOR SPECIAL CASE OF -32768
1806          POP      D                        ;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
1807          MOV      A,B                      ;GET THE SIGN OF RESULT IN A
1808          JMP      INEGA                    ;NEGATE THE RESULT IF NECESSARY
1809 IMULT3:  XRI      200                      ;IS RESULT 32768?
1810          ORA                               ;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
1811          JZ       IMULT4                   ;MUST BE 32768, IT CANNOT BE GREATER
1812          XCHG                              ;IT IS .GT. 32768, WE HAVE OVERFLOW
1814 IMULTS:  POP      B                        ;GET SIGN OF RESULT OFF STACK
1815          POP      H                        ;GET THE ORIGINAL FIRST ARGUMENT
1816          CALL     CONSIH                   ;FLOAT IT
1817          POP      H                        ;GET THE ORIGINAL SECOND ARGUMENT
1818          CALL     PUSHF                    ;SAVE FLOATED FIRST ARUMENT
1819          CALL     CONSIH                   ;FLOAT SECOND ARGUMENT
1822          JMP      FMULT                    ;MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
1823 IMULT4:  MOV      A,B                      ;IS RESULT +32768 OR -32768?
1824          ORA      A                        ;GET ITS SIGN
1825          POP      B                        ;DISCARD ORIGINAL SECOND ARGUMENT
1826          RM                                ;THE RESULT SHOULD BE NEGATIVE, IT IS OK
1827          PUSH     D                        ;IT IS POSITIVE, SAVE REMAINDER FOR MOD
1828          CALL     CONSIH                   ;FLOAT -32768
1829          POP      D                        ;GET MOD'S REMAINDER BACK
1830          JMP      NEG                      ;NEGATE -32768 TO GET 32768, WE ARE DONE
1836 IDIV:    MOV      A,H                      ;CHECK FOR DIVISION BY ZERO
1837          ORA      L        
1838          JZ       DVDERR                   ;WE HAVE DIVISION BY ZERO11
1839          CALL     IMULDV                   ;FIX UP THE SIGNS
1840          PUSH     B                        ;SAVE THE SIGN OF THE RESULT
1841          XCHG                              ;GET DENOMINATOR IN (HL)
1842          CALL     INEGHL                   ;NEGATE IT
1843          MOV      B,H                      ;SAVE NEGATED DENOMINATOR IN (BC)
1844          MOV      C,L      
1845          LXI      H,$CODE                  ;ZERO WHERE WE DO THE SUBTRACTION
1846          MVI      A,21                     ;SET UP A COUNT
1847          PUSH     PSW                      ;SAVE IT
1848          ORA      A                        ;CLEAR CARRY
1849          JMP      IDIV3                    ;GO DIVIDE
1850 IDIVI:   PUSH     PSW                      ;SAVE COUNT
1851          PUSH     H                        ;SAVE (HL) I.E. CURRENT NUMERATOR
1852          DAD      B                        ;SUBTRACT DENOMINATOR
1853          JNC      IDIV2                    ;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
1854          POP      PSW                      ;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
1855          STC                               ;NEXT BIT IN QUOTIENT IS A ONE
1857 IDIV2:   POP      H                        ;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
1858 IDIV3:   MOV      A,E                      ;SHIFT IN THE NEXT QUOTIENT BIT
1859          RAL      
1860          MOV      E,A      
1861          MOV      A,D                      ;SHIFT THE HO
1862          RAL      
1863          MOV      D,A      
1864          MOV      A,L                      ;SHIFT IN THE NEXT BIT OF THE NUMERATOR
1865          RAL      
1866          MOV      L,A      
1867          MOV      A,H                      ;DO THE HO
1868          RAL      
1869          MOV      H,A                      ;SAVE THE HD
1870          POP      PSW                      ;GET COUNT BACK
1871          DCR      A                        ;ARE WE DONE?
1872          JNZ      IDIVI                    ;NO, DIVIDE AGAIN
1873          XCHG                              ;GET QUOTIENT IN (HL), REMAINDER IN (DE)
1874          POP      B                        ;GET SIGN OF RESULT
1875          PUSH     D                        ;SAVE REMAINDER SO STACK WILL BE ALRIGHT
1876          JMP      IMLDIV                   ;CHECK FOR SPECIAL CASE OF 32768
1881 IMULOV:  MOV      A,H                      ;GET SIGN OF RESULT
1882          XRA      D        
1883          MOV      B,A                      ;SAVE IT IN B
1884          CALL     INEGH                    ;NEGATE SECOND ARGUMENT IF NECESARY
1885          XCHG                              ;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
1891 INEGH:   MOV      A,H                      ;GET SIGN OF (HL)
1892 INEGA:   ORA      A                        ;SET CONDITION CODES
1893          RP                                ;WE DON'T HAVE TO NEGATE, IT IS POSITIVE
1894 INEGHL:  XRA                               ;CLEAR A
1895          MOV      C,A                      ;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
1896          SUB                               ;NEGATE LO
1897          MOV      L,A                      ;SAVE IT
1898          MOV      A,C                      ;GET A ZERO BACK
1899          SBB      H                        ;NEGATE HO
1900          MOV      H,A                      ;SAVE IT
1901          RET                               ;ALL DONE
1906 IABS:    LDA      FACLO+1                  ;GET SIGN OF INTEGER IN FAC
1907          ORA      A                        ;CHECK ITS SIGN
1908          RP                                ;IT IS POSITIVE, LEAVE IT ALONE
1914 INEG:    LHLD     FACLO                    ;GET THE INTEGER
1915          CALL     INEGHL                   ;NEGATE IT
1916          SHLD     FACLO                    ;STORE IT BACK IN THE FAC
1917          XRI      200                      ;CHECK FOR SPECIAL CASE OF 32768
1918          ORA      
1919          RNZ                               ;IT DID NOT OCCUR, EVERYTHING IS FINE
1920          XCHG                              ;WE HAVE IT, FLOAT 32768
1921          MVI      A,4                      ;CHANGE VALTYP 10 "SINGLE PRECISION"
1922          STA      VALTYP   
1923 INEGAD:  MVI      B,230                    ;ENTRY FROM ;ADD, SET EXPONENT
1924          JMP      FLOATR                   ;GO FLOAT THE NUMBER
1930 MOD:     PUSH     D                        ;SAVE (DE) FOR ITS SIGN
1931          CALL     IDIV                     ;DIVIDE AND GET THE REMAINDER
1932          XCHG                              ;PUT REMAINDER IN (DE)
1933          MVI      A,2                      ;SET VALTYP TO "INTEGER" IN CASE RESULT OF
1934          STA      VALTYP                   ;THE DIVISION WAS 32768
1935          POP      PSW                      ;GET THE SIGN OF (DE) BACK
1936          JMP      INEGA>                   ;NEGATE THE REMAINDER IF NECESSARY
1961 DSUB:    CALL     NEG                      ;NEGATE THE SECOND ARGUMENT
1967 DADD:    LXI      H,ARG                    ;GET POINTER TO EXPONENT OF FIRST ARGUMENT
1968          MOV      A,M                      ;CHECK IF IT IS ZERO
1969          ORA      A        
1970          RZ                                ;IT IS, RESULT IS ALREADY IN FAC
1971          MOV      B,A                      ;SAVE EXPONENT FOR UNPACKING
1972          DCX      H                        ;POINT TO HO AND SIGN
1973          MOV      C,M                      ;GET HO AND SIGN FOR UNPACKING
1974          LXI      D,FAC                    ;GET POINTER TO EXPONENT OF SECOND ARGUMENT
1975          LDAX     D                        ;GET EXPONENT
1976          ORA      A                        ;SEE IF IT IS ZERO
1977          JZ       VMOVFA                   ;IT IS, MOVE ARG TO FAC AND WE ARE DONE
1978          SUB      B                        ;SUBTRACT EXPONENTS TO GET SHIFT COUNT
1979          JNC      DADD2                    ;PUT THE SMALLER NUMBER IN FAC
1980          CMA                               ;NEGATE SHIFT COUNT
1981          INR      A        
1982          PUSH     PSW                      ;SAVE SHIFT COUNT
1983          PUSH     B                        ;SAVE HO TO UNPACK LATER
1984          MVI      C,10                     ;SWITCH FAC AND ARG, SET UP A COUNT
1985          INX      H                        ;POINT TO ARG
1986 DADD1:   LDAX     0                        ;GET A BYTE OF THE FAC
1987          MOV      B,M                      ;GET A BYTE OF ARG
1988          MOV      M,A                      ;PUT THE FAC BYTE IN ARG
1989          MOV      A,B                      ;PUT THE ARG BYTE IN A
1990          STAX     D                        ;PUT THE ARG BYTE IN FAC
1991          DCX      D                        ;POINT TO THE NEXT LO BYTE OF FAC
1992          DCX      H                        ;POINT TO THE NEXT LO BYTE OF ARG
1993          DCR      C                        ;ARE WE DONE?
1994          JNZ      DADD1                    ;NO, DO THE NEXT LO BYTE
1995          POP      B                        ;GET THE HO BACK
1996          POP      PSW                      ;GET THE SHIFT COUNT BACK
1997 DADD2:   CPI      71                       ;ARE WE WITHIN 56 BITS?
1998          RNC                               ;NO, ALL DONE
1999          PUSH     PSW                      ;SAVE SHIFT COUNT
2000          CALL     UNPACK                   ;UNPACK THE NUMBERS
2001          MOV      B,A                      ;SAVE SUBTRACTION FLAG
2002          MOV      A,C                      ;SAVE THE UNPACKED HO
2003          STA      ARG-1    
2004          POP      PSW                      ;GET SHIFT COUNT
2005          CALL     DSHFTR                   ;SHIFT FAC RIGHT THE RIGHT NUMBER OF TIMES
2006          ORA      B                        ;GET SUBTRACTION FLAG, HERE A=0
2007          JP       DADD3                    ;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
2008          CALL     DADDAA                   ;SIGNS ARE THE SAME, ADD THE NUMBERS
2009          JNC      DROUND                   ;ROUND THE RESULT IF NO CARRY
2010          INR      M                        ;WE HAVE OVERFLOW, ADD ONE TO THE EXPONENT
2011          JZ       OVERR                    ;CHECK FOR OVERFLOW
2012          MVI      D,1                      ;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
2013          CALL     DSHFRA   
2014          JMP      DROUND                   ;ROUND THE RESULT
2016          SBB      M                        ;GET THE SUBTRACT INSTRUCTION IN A
2017          CALL     DADDA                    ;SUBTRACT THE NUMBERS
2018          INX      H                        ;POINT TO THE UNPACKED SIGN
2019          MOV      A,M                      ;COMPLEMENT IT, SINCE THE FAC WAS SMALLER
2020          CMA      
2021          MOV      M,A      
2022          CC       DNEGR                    ;NEGATE THE RESULT IF IT WAS NEATIVE
2028 DNORML:  XRA      A                        ;CLEAR SHIFT COUNT
2029 DNORM1:  MOV      B,A                      ;SAVE SHIFT COUNT
2030          LDA      FAC-1                    ;GET HO
2031          ORA      A                        ;SEE IF WE CAN SHIFT 8 LEFT
2032          JNZ      DNORMS                   ;WE CAN'T, SEE IF NUMBER IS NORMALIZED
2033          LXI      H,DFACLO-1               ;WE CAN, GET POINTER TO LO
2034          MVI      C,10                     ;SET UP A COUNT
2035 DNORM2:  MOV      D,M                      ;GET A BYTE OF FAC
2036          MOV      M,A                      ;PUT IN BYTE FROM LAST LOCATION, THE FIRST
2038          MOV      A,D                      ;PUT THE CURRENT BYTE IN A FOR NEXT TIME
2039          INX      H                        ;INCREMENT POINTER TO NEXT HIGHER ORDER
2040          DCR      C                        ;ARE WE DONE?
2041          JNZ      DNORM2                   ;NO, DO THE NEXT BYTE
2042          MOV      A,B                      ;SUBTRACT 8 FROM SHIFT COUNT
2043          SUI      10       
2044          CPI      300                      ;HAVE WE SHIFTED ALL BYTES TO ZERO?
2045          JNZ      DNORM1                   ;NO, TRY TO SHIFT 8 MORE
2046          JMP      ZERO                     ;YES, THE NUMBER IS ZERO
2047 DNORM3:  DCR      B                        ;DECREMENT SHIFT COUNT
2048          LXI      H,DFACLO-1               ;GET POINTER TO LO
2049          CALL     DSHFLC                   ;SHIFT THE FAC LEFT
2050          ORA      A                        ;SEE IF NUMBER IS NORMALIZED
2051 DNORMS:  JP       DNORM3                   ;SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
2052          MOV      A,B                      ;GET THE SHIFT COUNT
2053          ORA      A                        ;SEE IF NO SHIFTING WAS DONE
2054          JZ       DROUND                   ;NONE WAS, PROCEED TO ROUND THE NUMBER
2055          LXI      H,FAC                    ;GET POINTER TO EXPONENT
2056          ADD      M                        ;UPDATE IT
2057          MOV      M,A                      ;SAVE UPDATED EXPONENT
2058          JNC      ZERO                     ;UNDERFLOW, THE RESULT IS ZERO
2059          RZ                                ;RESULT IS ALREADY ZERO, WE ARE DONE
2065 DROUND:  LDA      DFACLO-1                 ;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
2066 DROUND:  ORA      A                        ;ENTRY FROM DDIV
2067          CM       OROUNA                   ;ROUND UP IF NECESSARY
2068          LXI      H,FAC+1                  ;GET POINTER TO UNPACKED SIGN
2069          MOV      A,M                      ;GET SIGN
2070          ANI      200                      ;ISOLATE SIGN BIT
2071          DCX      H                        ;POINT TO HD
2072          DCX      H        
2073          XRA      M                        ;PACK SIGN AND HO
2074          MOV      M,A                      ;PUT PACKED SIGN AND HO IN FAC
2075          RET                               ;WE ARE DONE
2079 DROUNA:  LXI      H,DFACLO                 ;GET POINTER TO LO, ENTRY FROM DINT
2080          MVI      B,7                      ;SET UP A COUNT
2081 DRONA1:  INR      M                        ;INCREMENT A BYTE
2082          RNZ                               ;RETURN IF THERE WAS NO CARRY
2083          INX      H                        ;INCREMENT POINTER TO NEXT HIGHER ORDER
2084          DCR      B                        ;HAVE WE INCREMENTED ALL BYTES
2085          JNZ      DRONA1                   ;NO, TRY THE NEXT ONE
2086          INR      M                        ;YES, INCREMENT THE EXPONENT
2087          JZ       OVERR                    ;CHECK FOR OVERFLOW
2088          DCX      H                        ;THE NUMBER OVERFLOWED ITS EXPONENT
2089          MVI      M,200                    ;PUT 200 IN HO
2090          RET                               ;ALL DONE
2095 DADDD:   LXI      H,FBUFFR+^D17            ;ENTRY FROM DDIV
2096          LXI      D,ARGLO                  ;ADD OR SUBTRACT FBUFFR+17 AND ARG
2097          JMP      DADDS                    ;DO THE OPERATION
2100          ADC      M                        ;SETUP ADD INSTRUCTION FOR LOOP
2101 DADDA:   LXI      H,ARGLO                  ;GET POINTER TO ARG, ENTRY FROM DADO
2102 DADDFO:  LXI      D,DFACLO                 ;GET POINTER TO FAC, ENTRY FROM FOUT
2103 DADDS:   MVI      C,7                      ;SET UP A COUNT
2104          STA      DADDDP                   ;STORE THE ADD OR SUBTRACT INSTRUCTION
2105          XRA      A                        ;CLEAR CARRY
2107 DADDDP:  NOP                               ;THIS IS EITHER "ADC M" OR "SBB M"
2108          STAX     D                        ;SAVE THE CHANGED BYTE
2109          INX      D                        ;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
2110          INX      H        
2111          DCR      C                        ;ARE WE DONE?
2112          JNZ      DADDL                    ;NO, DO THE NEXT HIGHER ORDER BYTE
2113          RET                               ;ALL DONE
2119 DNEGR:   MOV      A,M                      ;COMPLEMENT SIGN OF FAC
2120          CMA                               ;USE THE UNPACKED SIGN BYTE
2121          MOV      M,A                      ;SAVE THE NEW SIGN
2122          LXI      H,DFACLO-1               ;GET POINTER TO LO
2123          MVI      B,10                     ;SET UP A COUNT
2124          XRA      A                        ;CLEAR CARRY AND GET A ZERO
2125          MOV      C,A                      ;SAVE ZERO IN C
2126 DNEGR1:  MOV      A,C                      ;GET A ZERO
2128          MOV      M,A                      ;UPDATE FAC
2129          INX      H                        ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2130          DCR      B                        ;ARE WE DONE?
2131          JNZ      DNEGR1                   ;NO, NEGATE THE NEXT BYTE
2132          RET                               ;ALL DONE
2138 DSHFTR:  LXI      H,DFACLO-1               ;GET POINTER TO LO
2139          MVI      M,0                      ;PUT ZERO IN EXTRA LO ORDER BYTE
2140 DSHFR1:  SUI      10                       ;SEE IF WE CAN SHIFT 8 RIGHT
2141          JC       DSHFR3                   ;WE CAN'T, CHECK IF WE ARE DONE
2142 DSHFRM:  LXI      H,FAC-1                  ;ENTRY FROM DMULT, GET POINTER TO HO
2143          MVI      E,0                      ;SHIFT A ZERO INTO THE HO
2144          MVI      D,10                     ;SET UP A COUNT
2145 DSHFR2:  MOV      C,M                      ;SAVE A BYTE OF FAC
2146          MOV      M,E                      ;PUT THE LAST BYTE IN ITS PLACE
2147          MOV      E,C                      ;SET UP E FOR NEXT TIME THROUGH THE LOOP
2148          DCX      H                        ;POINT TO NEXT LOWER ORDER BYTE
2149          DCR      D                        ;ARE WE DONE?
2150          JNZ      DSHFR2                   ;NO, DO THE NEXT BYTE
2151          JMP      DSHFR1                   ;YES, SEE IF WE CAN SHIFT OVER 8 MORE
2152 DSHFR3:  ADI      11                       ;CORRECT SHIFT COUNT
2153          MOV      D,A                      ;SAVE SHIFT COUNT IN D
2154 DSHFR4:  XRA      A                        ;CLEAR CARRY
2155          DCR      D                        ;ARE WE DONE?
2157 DSHFRA:  LXI      H,FAC-1                  ;NO, GET POINTER TO LO, ENTRY FROM DADD, DMULT
2158          MVI      E,10                     ;SET UP A COUNT, ROTATE FAC ONE LEFT
2159 DSHFR5:  MOV      A,M                      ;GET A BYTE OF THE FAC
2160          RAR                               ;ROTATE IT LEFT
2161          MOV      M,A                      ;PUT THE UPDATED BYTE BACK
2162          DCX      H                        ;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
2163          DCR      E                        ;ARE WE DONE?
2164          JNZ      DSHFR5                   ;NO, ROTATE THE NEXT LOWER ORDER BYTE
2165          JMP      DSHFR4                   ;YES, SEE IF WE ARE DONE SHIFTING
2170 DSHFLC:  MVI      C,10                     ;SET UP A COUNT
2171 DSHFTL:  MOV      A,M                      ;GET A BYTE OF FAC
2172          RAL                               ;ROTATE IT LEFT ONE
2173          MOV      M,A                      ;UPDATE BYTE IN FAC
2174          INX      H                        ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2175          DCR      C                        ;ARE WE DONE?
2176          JNZ      DSHFTL                   ;NO, ROTATE THE NEXT BYTE
2177          RET                               ;ALL DONE
2183          RZ                                ;YES, ALL DONE, THE FAC IS ZERO
2184          CALL     MULDVA                   ;ADD EXPONENTS AND TAKE CARE OF SIGNS
2185          CALL     DMULDV                   ;ZERO FAC AND PUT FAC IN FBUFFR
2186          MOV      M,C                      ;PUT UNPACKED HO IN ARG
2187          LXI      D,ARGLO                  ;GET POINTER TO LO OF ARG
2188          MVI      B,7                      ;SET UP A COUNT
2189 DMULT2:  LDAX     D                        ;GET THE BYTE OF ARG TO MULTIPLY BY
2190          INX      D                        ;INCREMENT POINTER TO NEXT HIGHER BYTE
2191          ORA      A                        ;CHECK IF WE ARE MULTIPLYING BY ZERO
2192          PUSH     D                        ;SAVE POINTER TO ARG
2193          JZ       DMULT5                   ;WE ARE
2194          MVI      C,10                     ;SET UP A COUNT
2195 DMULT3:  PUSH     B                        ;SAVE COUNTERS
2196          RAR                               ;ROTATE MULTIPLIER RIGHT
2197          MOV      B,A                      ;SAVE IT
2198          CC       DADDAA                   ;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
2199          MVI      0,1                      ;ROTATE PRODUCT RIGHT ONE
2200          CALL     DSHFRA   
2201          MOV      A,B                      ;GET MULTIPLIER IN A
2202          POP      B                        ;GET COUNTERS BACK
2203          DCR      C                        ;ARE WE DONE WITH THIS BYTE OF ARG?
2204          JNZ      DMULT3                   ;NO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
2206 DMULT4:  POP      D                        ;YES, GET POINTER INTO ARG BACK
2207          DCR      B                        ;ARE WE DONE?
2208          JNZ      DMULT2                   ;NO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
2209          JMP      NORMAL                   ;ALL DONE, NORMALIZE AND ROUND RESULT
2210 DMULT5:  CALL     DSHFRM                   ;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
2211          JMP      DMULT4                   ;MULTIPLYIING BY ZERO
2226 DDIV10:  CALL     VMOVAF                   ;SAVE THE FAC IN ARG
2227          LXI      H,DTEN                   ;GET POINTER TO A DOUBLE PRECISION 10
2228          CALL     VMOVFM                   ;MOVE TEN INTO THE FAC
2235          JZ       DV0ERR                   ;DON'T LET HIM DO IT
2236          CALL     MULDVS                   ;SUBTRACT EXPONENTS AND CHECK SIGNS
2237          INR      M                        ;ADD TWO TO EXPONENT TO CORRECT SCALING
2238          INR      M        
2239          CALL     DMULDV                   ;ZERO FAC AND PUT FAC IN FBUFFR
2240          LXI      H,ARG                    ;GET POINTER TO THE EXTRA HO BYTE WE WILL USE
2241          MOV      M,C                      ;ZERO IT
2242          MVI      B,0                      ;ZERO FLAG TO SEE WHEN WE START DIVIDING
2244          SBB      M                        ;GET SUBTRACT INSTRUCTION
2245          CALL     DADDD                    ;DO THE SUBTRACTION
2246          LDAX     D                        ;SUBTRACT FROM EXTRA HO BYTE
2247          SBB      C                        ;HERE C=0
2248          CMC                               ;CARRY=1 IF SUBTRACTION WAS GOOD
2249          JC       DDIV2                    ;WAS IT OK?
2251          ADC      M                        ;GET ADD INSTRUCTION
2252          CALL     DADDD                    ;DO THE ADDITION
2253          XRA      A                        ;CLEAR CARRY
2255 DDIV2:   STAX     D                        ;STORE THE NEW HIGHEST ORDER BYTE
2256          INR      B                        ;INCREMENT FLAG TO SHOW WE COULD DIVIDE
2257          LDA      FAC-1                    ;CHECK IF WE ARE DONE DIVIDING
2258          INR      A                        ;SET SIGN FLAG WITHOUT AFFECTING CARRY
2259          DCR      A        
2260          RAR                               ;PUT CARRY IN MSB FOR DROUND
2261          JM       DROUND                   ;WE ARE DONE, WE HAVE 57 BITS OF ACCURACY
2262          RAL                               ;GET OLD CARRY BACK WHERE IT BELONGS
2263          LXI      H,DFACLO                 ;GET POINTER TO LO OF FAC
2264          MVI      C,7                      ;SET UP A COUNT, SHIFT FAC LEFT ONE
2265          CALL     DSHFTL                   ;SHIFT IN THE NEXT BIT IN THE QUOTIENT
2266          LXI      H,ARGLO                  ;GET POINTER TO LO IN ARG
2267          CALL     DSHFLC                   ;SHIFT DIVIDEND ONE LEFT
2268          MOV      A,B                      ;IS THIS THE FIRST TIME AND WAS THE
2269          ORA      A                        ;SUBTRACTION NOT GOOD? (B WILL GET
2270          JNZ      DDIVI                    ;CHANGED ON THE FIRST OR SECOND SUBTRACTION)
2271          LXI      H,FAC                    ;YES, SUBTRACT ONE FROM EXPONENT TO CORRECT
2272          DCR      M                        ;SCALING
2273          JNZ      DDIVI                    ;CONTINUE DIVIDING IF NO OVERFLOW
2274          JMP      OVERR                    ;WE HAVE OVERFLOW11
2279 DMULDV:  MOV      A,C                      ;PUT UNPACKED HO BACK IN ARG
2280          STA      ARG-1    
2281          DCX      H                        ;POINT TO HO OF FAC
2282          LXI      D,FBUFFR+^D23            ;POINT TO END OF FBUFFR
2283          MVI      B,7                      ;SET UP A COUNT
2284          MVI      C,0                      ;GET A ZERO TO FILL FAC WITH
2285 DMLDV1:  MOV      A,M                      ;GET A BYTE FROM FAC
2286          STAX     D                        ;PUT IT IN FBUFFR
2287          MOV      M,C                      ;PUT A ZERO IN FAC
2288          DCX      D                        ;POINT TO NEXT BYTE IN FBUFFR
2289          DCX      H                        ;POINT TO NEXT LOWER ORDER BYTE IN FAC
2290          DCR      B                        ;ARE WE DONE?
2291          JNZ      DMLDV1                   ;NO, TRANSFER THE NEXT BYTE
2292          RET                               ;ALL DONE
2297 DMUL10:  CALL     VMOVAF                   ;SAVE THE FAC IN ARG
2299          XCHG                              ;GET THE POINTER INTO THE FAC IN (HL)
2300          DCX      H                        ;POINT TO THE EXPONENT
2301          MOV      A,M                      ;GET THE EXPONENT
2302          ADI      2                        ;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
2303          JC       OVERR                    ;CHECK FOR OVERFLOW
2304          MOV      M,A                      ;SAVE THE NEW EXPONENT
2305          PUSH     H                        ;SAVE POINTER TO FAC
2306          CALL     DADD                     ;ADD IN THE ORIGINAL FAC TO GET 5 TIMES FAC
2307          POP      H                        ;GET THE POINTER TO FAC BACK
2308          INR      M                        ;ADD ONE TO EXPONENT TO GET 10 TIMES FAC
2309          RNZ                               ;ALL DONE IF OVERFLOW DID NOT OCCUR
2310          JMP      OVERR>                   ;IT DID, GIVE THE APPROPRIATE MESSAGE
2325          CPI      "-"                      ;SEE IF NUMBER IS NEGATIVE
2327          PUSH     PSW                      ;SAVE SIGN
2328          JZ       FIN1                     ;IGNORE MINUS SIGN
2331          CPI      "+"                      ;IGNORE A LEADING SIGN
2333          JZ       FIN1>    
2336          DCX      H                        ;SET CHARACTER POINTER BACK ONE
2339          CALL     ZERO                     ;CLEAR FAC
2342          MOV      B,A                      ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
2343          MOV      D,A                      ;D=SIGN OF EXPONENT
2344          MOV      E,A                      ;E=EXPONENT
2345          CMA      
2346          MOV      C,A                      ;C="." FLAG
2349          JC       FINDIG                   ;DO WE HAVE A DIGIT?
2352          CPI      ","                      ;TEST FOR DECIMAL POINT
2354          JZ       FINDP    
2357          CPI      "E"                      ;CHECK FOR BEGINNING OF EXPONENT
2359          JNZ      FINE                     ;"NONE OF THE ABOVE" SO END OF NUMBER
2365          PUSH     H                        ;SAVE TEXT POINTER
2366          LXI      H,FINEC                  ;PUT FINEC ON STACK SO WE CAN JUMP
2370          DCR      D                        ;SET SIGN OF EXPONENT FLAG
2371          CPI      MINUTK                   ;NEGATIVE EXPONENT?
2374          JZ       FINEC>   
2376          RZ       
2377          CPI      "-"      
2380          INR      D                        ;NO, RESET FLAG
2382          CPI      "+"      
2385          CPI      PLUSTK                   ;IGNORE "+"
2388          JZ       FINEC>   
2390          RZ       
2391          POP      PSW>                     ;GET FINEC OFF STACK
2392          DCX      H                        ;CHECK IF LAST CHARACTER WAS A DIGIT
2395          JC       FINEDG                   ;IS IT A DIGIT?
2398          INR      D                        ;NO, EXPONENT ALL IN
2399          JNZ      FINE                     ;SET ITS SIGN
2402          XRA      A        
2403          SUB      E        
2404          MOV      E,A      
2405          INR      C                        ;MAKE SURE C IS NOT 377
2408 FINDP:   INR      C                        ;DECIMAL POINTS -- SET FLAG
2409          JZ       FINC                     ;CONTINUE SCANNING CHARACTERS
2415 FINE:    PUSH     H                        ;SAVE POINTER FOR LATER
2416          MOV      A,E                      ;EXPONENT=EXPONENT-# OF DECIMAL PLACES
2417          SUB      B        
2418 FINE2:   CP       FINMUL                   ;MULTIPLY BY TEN IF EXPONENT IS POSITIVE
2421          JP       FINE3                    ;DIVIDE BY TEN IF EXPONENT IS NEGATIVE
2424          PUSH     PSW                      ;SAVE EXPONENT
2425          CALL     DIV10                    ;DIVIDE NUMBER BY TEN
2428          POP      PSW                      ;GET EXPONENT
2429          INR      A                        ;INCREMENT IT
2430 FINE3:   JNZ      FINE2                    ;DO AGAIN IF WE ARE NOT DONE
2434          POP      H>                       ;GET CHARACTER POINTER
2436          POP      D                        ;GET CHARACTER POINTER
2437          POP      PSW                      ;GET SIGN
2438          CZ       NEG                      ;NEGATE IF NECESSARY
2444          XCHG                              ;SAVE THE TEXT POINTER IN (DE)
2445          LXI      B,377+$CODE              ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
2447          MOV      H,C                      ;ZERO (HL)
2448          MOV      L,C      
2449          CALL     CONISS                   ;ZERO FAC, SET VALTYP TO "INTEGER"
2450          XCHG                              ;GET THE TEXT POINTER BACK IN (HL)
2453          JC       FINDIG                   ;WE HAVE A DIGIT
2454          CPI      "."                      ;CHECK FOR A DECIMAL POINT
2455          JZ       FINDP                    ;WE HAVE ONE, I GUESS
2456          CPI      "E"                      ;CHECK FOR A SINGLE PRECISION EXPONENT
2457          JZ       FINEX                    ;WE HAVE A SINGLE PRECISION NUMBER
2458          CPI      "D"                      ;CHECK FOR A DOUBLE PRECISION EXPONENT
2459          JNZ      FINE                     ;WE DON'T HAVE ONE, THE NUMBER IS FINISHED
2461 FINEX:   CALL     INFRC                    ;FORCE THE FAC TO BE SNG OR DBL
2462          PUSH     H                        ;SAVE THE TEXT POINTER
2463          LXI      H,FINEC                  ;GET ADDRESS TO JUMP TO, THIS IS TO SAVE BYTES
2464          XTHL                              ;PUT IT ON STACK AND GET TEXT POINTER
2467          DCR      D                        ;SET SIGN OF EXPONENT TO MINUS
2468          CPI      MINUTK                   ;CHECK IF THE EXPONENT IS NEGATIVE
2469          RZ                                ;IT IS
2470          CPI                               ;THIS IS IN CASE WE ARE CALLED BY VAL
2471          RZ       
2472          INR      D                        ;EXPONENT IS STILL POSITIVE, RESET FLAG
2473          CPI      PLUSTK                   ;IGNORE A LEADING PLUS SIGN
2474          RZ       
2475          CPI      "+"      
2476          RZ       
2477          DCX      H                        ;THE FIRST CHARACTER WAS NOT A SIGN, GO BACK
2479          POP      PSW                      ;POP FINEC OFF THE STACK, WE NO LONGER NEED IT
2482          JC       FINEDG                   ;PACK THE NEXT DIGIT INTO THE EXPONENT
2483          INR      D                        ;IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
2484          JNZ      FINE                     ;THE EXPONENT, IT IS POSITIVE
2485          XRA      A                        ;THE EXPONENT IS NEGATIVE
2486          SUB      E                        ;NEGATE IT
2487          MOV      E,A                      ;SAVE IT AGAIN
2489 FINE:    LDA      VALTYP                   ;FINISH UP -- WHAT KIND OF A NUMBER IS IT?
2490          CPI      2        
2491          JNZ      FINEF                    ;IT IS A FLOATING POINT ONE
2493          POP      PSW                      ;IT IS AN INTEGER, GET ITS SIGN
2494          XCHG                              ;SAVE THE TEXT POINTER IN (DE)
2496          XCHG                              ;GET THE TEXT POINTER BACK IN (HL)
2497          RET                               ;ALL DONE
2499 FINEF:   PUSH     H                        ;SAVE THE TEXT POINTER
2500          MOV      A,E                      ;FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
2501          SUB      B                        ;OR DIVIDE BY TEN
2503 FINEF2:  CP       FINMUL                   ;MULTIPLY IF WE HAVE TO
2504          CM       FINDIV                   ;DIVIDE IF WE HAVE TO
2505          JNZ      FINEF2                   ;MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
2507          POP      D                        ;GET THE TEXT POINTER
2508          POP      PSW                      ;GET THE SIGN
2509          CZ       NEG                      ;NEGATE IF NECESSARY
2510          XCHG                              ;GET THE TEXT POINTER IN (HL)
2511          LDA      VALTYP                   ;WE WANT -32768 TO BE AN INT, BUT UNTIL NOW
2512          CPI      4                        ;IT WOULD BE A SNG
2513          RNZ                               ;IT IS NOT SNG, SO IT IS NOT -32768
2514          PUSH     H                        ;WE HAVE A SNG, SAVE TEXT POINTER
2515          LXI      H,POPHRT                 ;GET ADDRESS THAT POP'S H OFF STACK BECAUSE
2516          PUSH     H                        ;CONIS2 DOES FUNNY THINGS WITH THE STACK
2517          CALL     CONIS2                   ;CHECK IF WE HAVE -32768
2518          RET                               ;WE DON'T, POPHRT IS STILL ON THE STACK SO
2523 FINDP:   INR      C                        ;SET THE FLAG
2524          JNZ      FINEF                    ;WE HAD 2 DECIMAL POINTS, NOW WE ARE DONE
2525          CALL     FINFRC                   ;THIS IS THE FIRST ONE, CONVERT FAC TO SNG
2526          JMP      FINC                     ;CONTINUE LOOKING FOR DIGITS
2531 FINFRC:  PUSH     H                        ;SAVE TEXT POINTER
2532          PUSH     D                        ;SAVE EXPONENT INFORMATION
2533          PUSH     B                        ;SAVE DECIMAL POINT INFORMATION
2534          PUSH     PSW                      ;SAVE WHAT WE WANT THE FAC TO BE
2535          CZ       FRCSNG                   ;CONVERT TO SNG IF WE HAVE TO
2536          POP      PSW                      ;GET TYPE FLAG BACK
2537          CNZ      FRCOBL                   ;CONVERT TO DBL IF WE HAVE TO
2538          POP      B                        ;GET DECIMAL POINT INFORMATION BACK
2539          POP      D                        ;GET EXPONENT INFORMATION BACK
2540          POP      H                        ;GET TEXT POINTER BACK
2545 FINMUL:  RZ                                ;RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
2546 FINMLT:  PUSH     PSW                      ;SAVE EXPONENT, ENTRY FROM FOUT
2548          CALL     MUL10>                   ;MULTIPLY BY TEN
2552          LDA      VALTYP                   ;SEE WHAT KIND OF NUMBER WE HAVE
2553          CPI      4        
2554          PUSH     PSW                      ;SAVE THE TYPE
2555          CZ       MUL10                    ;WE HAVE A SNG, MULTIPLY BY 10.0
2556          POP      PSW                      ;GET THE TYPE BACK
2557          CNZ      DMUL10>                  ;WE HAVE A DBL, MULTIPLY BY 1000
2558          POP      PSW                      ;GET EXPONENT
2559 DCRART:  DCR      A                        ;DECREASE IT
2560          RET                               ;ALL DONE
2563 FINDIV:  PUSH     PSW                      ;WE HAVE TO DIVIDE -- SAVE COUNT
2564          LDA      VALTYP                   ;SEE WHAT KIND OF NUMBER WE HAVE
2565          CPI      4        
2566          PUSH     PSW                      ;SAVE THE TYPE
2567          CZ       DIV10                    ;WE HAVE A SNG NUMBER
2568          POP      PSW                      ;GET THE TYPE BACK
2569          CNZ      DDIV10                   ;WE HAVE A DBL NUMBER
2570          POP      PSW                      ;GET COUNT BACK
2571          INR      A                        ;UPDATE IT
2578          PUSH     D                        ;DIGITS: SAVE EXPONENT INFORMATION
2579          MOV      D,A                      ;PROTECT DIGIT FROM BELOW
2580          MOV      A,B                      ;INCREMENT DECIMAL PLACE COUNT
2581          ADC      C                        ;IF PAST THE DECIMAL POINT
2582          MOV      B,A      
2583          PUSH     B                        ;SAVE NECESSARY DATA
2584          PUSH     H        
2585          PUSH     D                        ;SAVE DIGIT
2586          CALL     MUL10                    ;MULTIPLY OLD NUMBER BY 10
2589          POP      PSW                      ;GET NEXT DIGIT
2590          SUI      "0"                      ;SUBTRACT OFF ASCII CODE
2593          CALL     PUSHF                    ;PUT NUMBER ON STACK
2594          CALL     FLOAT                    ;CONVERT TO FLOATING POINT NUMBER
2596          CALL     FADD>                    ;ADD IN NEXT DIGIT
2598          CALL     FINLOG>  
2601          POP      H                        ;RECALL DATA
2602          POP      B        
2603          POP      D        
2604          JMP      FINC>                    ;GET NEXT CHARACTER
2608          PUSH     D                        ;SAVE EXPONENT INFORMATION
2609          MOV      A,B                      ;INCREMENT DECIMAL PLACE COUNT IF WE ARE
2610          ADC      C                        ;PAST THE DECIMAL POINT
2611          MOV      B,A      
2612          PUSH     B                        ;SAVE DECIMAL POINT INFORMATION
2613          PUSH     H                        ;SAVE TEXT POINTER
2614          MOV      A,M                      ;GET THE DIGIT
2615          SUI      "0"                      ;CONVERT IT TO ASCII
2616          PUSH     PSW                      ;SAVE THE DIGIT
2617          LDA      VALTYP                   ;SEE WHAT KIND OF A NUMBER WE HAVE
2618          CPI      4        
2619          JNC      FINDGV                   ;WE DO NOT HAVE AN INTEGER
2622          LXI      D,^D3277+$CODE           ;SEE IF WE WILL OVERFLOW
2624          JNC      FINDG2                   ;(HL) .LT. (DE), SO THE NUMBER IS TOO BIG
2625          MOV      D,H                      ;COPY (HL) INTO (DE)
2626          MOV      E,L      
2627          DAD      H                        ;MULTIPLY (HL) BY 2
2628          DAD      H                        ;MULTIPLY (HL) BY 2, (HL) NOW IS 4*(DE)
2629          DAD      D                        ;ADD IN OLD (HL) TO GET 5* (DE)
2630          DAD      H                        ;MULTIPLY BY 2 TO GET TEN TIMES THE OLD (HL)
2631          POP      PSW                      ;GET THE DIGIT
2632          MOV      C,A                      ;SAVE IT SO WE CAN USE DAD, B IS ALREADY ZERO
2633          DAD      B                        ;ADD IN THE NEXT DIGIT
2634          MOV      A,H                      ;CHECK FOR OVERFLOW
2635          ORA      A                        ;OVERFLOW OCCURED IF THE MSB IS ON
2636          JM       FINDGI                   ;WE HAVE OVERFLOW!!
2637          SHLD     FACLO                    ;EVERYTHING IS FINE, STORE THE NEW NUMBER
2638 FINDGE:  POP      H                        ;ALL DONE, GET TEXT POINTER BACK
2640          POP      D                        ;GET EXPONENT INFORMATION BACK
2641          JMP      FINC                     ;GET THE NEXT CHARACTER
2643 FINDGI:  MOV      A,C                      ;GET THE DIGIT
2644          PUSH     PSW                      ;PUT IT BACK ON THE STACK
2646 FINDG2:  CALL     CONSI                    ;CONVERT THE INTEGER TO SINGLE PRECISION
2647          XRA      A                        ;DO NOT TAKE THE FOLLOWING JUMP
2649 FINDGV:  JNZ      FINDGO                   ;FALL THROUGH IF VALTYP WAS 4 I.E. SNG PREC
2651          CALL     FCOMP                    ;IF SO, FAC .GE. 1000000
2652          JP       FINDG3                   ;WE DO, CONVERT TO DOUBLE PRECISION
2653          POP      PSW                      ;GET THE NEXT DIGIT
2654          CALL     FINLOG                   ;PACK IT INTO THE FAC
2655          JMP      FINDGE                   ;GET FLAGS OFF STACK AND WE ARE DONE
2657 FINDG3:  CALL     CONDS                    ;CONVERT SINGLE TO DOUBLE PRECISION
2659 FINDGO:  CALL     DMUL10                   ;MULTIPLY THE FAC BY 10
2660          CALL     VMOVAF                   ;SAVE THE FAC IN ARG
2661          POP      PSW                      ;GET THE NEXT DIGIT
2662          CALL     FLOAT                    ;CONVERT THE DIGIT TO SINGLE PRECISION
2663          CALL     CONDS                    ;NOW, CONVERT THE DIGIT TO DOUBLE PRECISION
2664          CALL     DADO                     ;ADD IN THE DIGIT
2665          JMP      FINDGE                   ;GET THE FLAGS OFF THE STACK AND WE ARE DONE
2669 FINLOG:  CALL     PUSHF                    ;SAVE FAC ON STACK
2672          CALL     FLOAT                    ;CONVERT A TO A FLOATING POINT NUMBER
2676          JMP      FADDT>                   ;ADD IT IN
2681          JMP      FAOD>>                   ;ADD IT IN
2686 FINEDG:  MOV      A,E                      ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
2687          RLC                               ;FIRST BY 4
2688          RLC      
2689          ADD      E                        ;ADD 1 TO MAKE 5
2690          RLC                               ;NOW DOUBLE TO GET 10
2691          ADD      M                        ;ADD IT IN
2692          SUI      "0"                      ;SUBTRACT OFF ASCII CODE
2694          MOV      E,A                      ;STORE EXPONENT
2695          JMP      FINEC                    ;CONTINUE
2701 INPRT:   PUSH     H                        ;SAVE LINE NUMBER
2702          LXI      H,INTXT##                ;PRINT MESSAGE
2705          CALL     STROUT   
2708          POP      H                        ;FALL INTO LINPRT
2715          XCHG                              ;SET UP REGISTERS FOR FLOATR
2716          XRA      A        
2717          MVI      B,230    
2719          CALL     FLOATRO                  ;CONVERT TO FLOATING POINT
2723          CALL     CONISS                   ;PUT THE LINE NUMBER IN THE FAC AS AN INTEGER
2724          XRA      A                        ;SET FORMAT TO FREE FORMAT
2725          CALL     FOUINIO                  ;SET UP THE SIGN
2726          LXI      H,STROUI##               ;PUT PRINT STRING ADDRESS ON STACK SO WE WILL
2729          PUSH                              ;RETURN TO IT AND DO AN "INX H"
2734          PUSH     B                        ;PUT DUMMY FIELD LENGTHS ON STACK
2735          JMP      STROUI##                 ;PRINT THE NUMBER
2742 FOUT:    LXI      H,FBUFFR                 ;GET BEGINING OF CHARACTER BUFFER
2745          PUSH     H                        ;SAVE IT FOR WHEN WE RETURN
2748          MVI      M,"      "               ;PRINT SPACE IF POSITIVE
2750          JP       FOUT1    
2753          MVI      M,"-"                    ;PRINT A MINUS SIGN IF NEGATIVE
2755 FOUT1:   INX      H                        ;INCREMENT POINTER 10 NEXT CHRACTER POSITION
2756          MVI      M,"0"                    ;PUT A ZERO IN BUFFER IN CASE NUMBER=0
2758          JZ       FOUT19                   ;DO IT IF THE NUMBER IS ZERO
2761          PUSH     H                        ;SAVE BUFFER POINTER
2762          CM       NEG                      ;NEGATE NUMBER IF NEGATIVE
2771          XRA      A                        ;PUT TEN'S EXPONENT COUNT ON STACK
2772          PUSH     PSW      
2773          CALL     FOUTCH                   ;SEE IF NUMBER IS TOO BIG OR TOO SMALL
2782          CALL     FCOMP                    ;FCOMP RETURNS 377, 0 OR 1 IN A, SO THE
2786          JPO      FOUTS                    ;NO, NUMBER IS IN RANGE
2789          POP      PSW      
2790          CALL     FINMLT                   ;YES, MULTIPLY IT BY TEN TO GET
2793          PUSH     PSW                      ;IT IN RANGE
2794          JMP      FOUT3                    ;SEE IF NUMBER IS NOW IN RANGE
2797 FOUT9:   CALL     DIV10                    ;NO, DIVIDE NUMBER BY TEN, IT IS TOO BIG
2800          POP      PSW                      ;ADD ONE TO EXPONENT
2801          INR      A        
2802          PUSH     PSW      
2803          CALL     FOUTCB                   ;IS NUMBER .LE. 999999.499?
2809 FOUTS:   CALL     FADDH                    ;ROUND NUMBER TO NEAREST INTEGER
2812          INR      A                        ;MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE
2816          CALL     QINT                     ;GET INTEGER PART IN C,D,E
2819          CALL     MOVER                    ;SAVE NUMBER IN FAC
2823          LXI      B,2*400+6+$CODE          ;SET DECIMAL POINT COUNT FOR E NOTATION
2827          POP      PSW                      ;GET EXPONENT
2828          ADD      C                        ;NUMBER PRINTED IN E NOTATION?
2830          JM       FOUT6                    ;YES, IT IS .LT. .1
2833          CPI      7        
2835          JNC      FOUT6                    ;YES, IT IS .GT. 999999
2838          INR      A        
2839          MOV      B,A                      ;B = DECIMAL POINT COUNT
2840          MVI      A,1                      ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
2843 FOUT6:   DCR      A                        ;E NOTATION: ADD 5 10 ORIGINAL EXPONENT
2844          POP      H                        ;GET BUFFER POINTER FROM STACK
2845          PUSH     PSW                      ;SAVE EXPONENT FOR LATER
2847          LXI      D,FOUTBL                 ;STORE LOC OF LARGEST POWER OF TEN
2850 FOUT8:   DCR      B                        ;SEE IF IT IS TIME TO PRINT A DECIMAL POINT
2851          MVI      M,"."                    ;PUT A DECIMAL POINT IN THE BUFFER
2853          CZ       INXHRT                   ;INCREMENT THE BUFFER POINTER IF IT IS TIME
2856          PUSH     B                        ;SAVE FLAGS
2857          PUSH     H                        ;SAVE CHARACTER POINTER
2858          PUSH     D                        ;SAVE POWER OF TEN POINTER
2859          CALL     MOVRF                    ;GET NUMBER IN C,D,E
2862          POP      H                        ;GET POWER OF TEN POINTER .
2863          MVI      B,"0"-1                  ;B = NEXT DIGIT TO BE PRINTED
2865 FOUT10:  INR      B                        ;ADD ONE TO DIGIT
2866          MOV      A,E                      ;SUBTRACT LO
2867          SUB      M        
2868          MOV      E,A      
2869          INX      H                        ;POINT TO NEXT BYTE OF POWER OF TEN
2870          MOV      A,D                      ;SUBTRACT MO
2871          SBB      M        
2872          MOV      D,A      
2873          INX      H        
2874          MOV      A,C                      ;SUBTRACT HO
2875          SBB      M        
2876          MOV      C,A      
2877          DCX      H                        ;POINT TO BEGINNING OF POWER OF TEN
2878          DCX      H        
2879          JNC      FOUT10                   ;SUBTRACT AGAIN IF RESULT WAS POSITIVE
2882          CALL     FADDA                    ;IT WASN'T, ADD POWER OF TEN BACK IN
2885          INX      H                        ;INCREMENT POINTER TO NEXT POWER OF TEN
2886          CALL     MOVER                    ;SAVE C,D,E IN FAC
2889          XCHG                              ;GET POWER OF TEN POINTER IN (DE)
2890          POP      H                        ;GET BUFFER POINTER
2891          MOV      M,B                      ;PUT CHARACTER IN BUFFER
2892          INX      H                        ;INCREMENT BUFFER POINTER
2893          POP      B                        ;GET COUNTERS OFF STACK
2895          JNZ      FOUT8                    ;DO MORE IF NOT
2898          DCR      B                        ;SEE IF DECIMAL POINT GOES AFTER LAST DIGIT
2899          JZ       FOUT12                   ;IT DOES, WE HAVE NO ZEROS TO SUPPRESS
2903 FOUT11:  DCX      H                        ;GO BACK TO LAST CHARACTER
2904          MOV      A,M                      ;GET IT
2905          CPI      "0"                      ;IGNORE TRAILING ZEROS
2907          JZ       FOUT11   
2911          CPI      ","                      ;IGNORE DECIMAL POINT BEFORE TRAILING ZEROS
2913          CNZ      INXHRT                   ;IF NO DP, MOVE POINTER TO NEXT POSITION
2916 FOUT12:  POP      PSW                      ;GET DECIMAL EXPONENT
2921          MVI      M,"E"                    ;PUT AN "E" IN THE BUFFER
2923          INX      H                        ;PUT SIGN OF EXPONENT IN BUFFER
2925          MVI      M,"+"                    ;A PLUS IF POSITIVE
2927          JP       FOUT14   
2930          MVI      M,"-"                    ;A MINUS IF NEGATIVE
2932          CMA                               ;NEGATE EXPONENT
2933          INR      A        
2935 FOUT14:  MVI      B,"0"-1                  ;INITIALIZE TEN'S DIGIT COUNT
2937 FOUT15:  INR      B                        ;INCREMENT DIGIT
2938          SUI      12                       ;SUBTRACT TEN
2940          JNC      FOUT15                   ;DO IT AGAIN IF RESULT WAS POSITIVE
2943          ADI      "0"+12                   ;ADD BACK IN TEN AND CONVERT TO ASCII
2946          INX      H        
2947          MOV      M,B                      ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
2948 FOUT19:  INX      H                        ;WHEN WE JUMP TO HERE, A IS ZERO
2949          MOV      M,A                      ;PUT ONE'S DIGIT IN BUFFER
2950          INX      H                        ;INCREMENT POINTER
2951 FOUT17:  MOV      M,C                      ;PUT ZERO AT END OF BUFFER
2952          POP      H                        ;EXIT WITH (HL) POINTING TO STRING
2953          RET                               ;ALL DONE
2962          CALL     FCOMP    
2965          POP      H                        ;GET RETURN ADDRESS OFF STACK
2966          JPO      FOUT9                    ;NUMBER TOO BIG, DIVIDE BY TEN
2969          PCHL                              ;NUMBER OK, RETURN
3034 FOUT:    XRA      A                        ;SET FORMAT FLAGS TO FREE FORMATED OUTPUT
3036 PUFOUT:  CALL     FOUINI                   ;SAVE THE FORMAT SPECIFICATION IN A AND PUT
3038          PUSH     B                        ;SAVE THE FIELD LENGTH SPECIFICATIONS
3039          ANI      10                       ;CHECK IF POSITIVE NUMBERS GET A PLUS SIGN
3040          JZ       FOUT1                    ;THEY DON'T
3041          MVI      M,"+"                    ;THEY DO, PUT IN A PLUS SIGN
3043          MOV      B,A                      ;SAVE IT
3044          XCHG                              ;SAVE BUFFER POINTER
3045          CALL     VSIGN                    ;GET THE SIGN OF THE FAC
3046          XCHG                              ;PUT THE BUFFER POINTER BACK IN (HL)
3047          MOV      A,B                      ;GET THE VALTYP BACK
3048          JP       FOUT2                    ;IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
3049          MVI      M,"-"                    ;AND PUT A MINUS SIGN IN THE BUFFER
3050          PUSH     H                        ;SAVE THE BUFFER POINTER
3051          CALL     VNEG                     ;NEGATE THE NUMBER
3052          POP      H                        ;GET THE BUFFER POINTER BACK
3053 FOUT2:   INX      H                        ;POINT TO WHERE THE NEXT CHARACTER GOES
3054          LDA      TEMP3                    ;GET THE FORMAT SPECIFICATION
3055          MOV      D,A                      ;SAVE IT FOR LATER
3056          RAL                               ;PUT THE FREE FORMAT OR NOT BIT IN THE CARRY
3057          LDA      VALTYP                   ;GET THE VALTYP, VNEG COULD HAVE CHANGED THIS
3060          JC       FOUTFX                   ;THE MAN WANTS FIXED FORMATED OUTPUT
3062          POP      B                        ;WE CAN IGNORE THE OLD B AND C
3063          MVI      M,"0"                    ;PUT A ZERO IN THE BUFFER IN CASE THE NUMBER
3064          JZ       FOUTZR                   ;IS ZERO. IT IS, FINISH IT UP
3065          CPI      4                        ;DECIDE WHAT KIND OF A VALUE WE HAVE
3066          JNC      FOUFRV                   ;WE HAVE A SNG OR DBL
3068          LXI      B,$CODE                  ;SET THE DECIMAL POINT COUNT AND COMMA COUNT
3070          CALL     FOUTCI                   ;CONVERT THE INTEGER TO DECIMAL
3076 FOUTZS:  LXI      H,FBUFFR+1               ;GET POINTER TO THE SIGN
3077          MOV      B,M                      ;SAVE THE SIGN IN B
3078          MVI      C,"      "               ;DEFAULT FILL CHARACTER TO A SPACE
3079          LDA      TEMP3                    ;GET FORMAT SPECS TO SEE IF WE HAVE TO
3081          ANI      40       
3082          JZ       FOTZS1                   ;WE DON'T
3083          MOV      A,B                      ;WE DO, SEE IF THE SIGN WAS A SPACE
3084          CMP      C                        ;ZERO FLAG IS SET IF IT WAS
3085          MVI      C,"*"                    ;SET FILL CHARACTER TO AN ASTERISK
3086          JNZ      FOTZS1                   ;SET THE SIGN TO AN ASTERISK IF IT WAS A SPACE
3087          MOV      B,C                      ;B HAS THE SIGN, C THE FILL CHARACTER
3088 FOTZS1:  MOV      M,C                      ;FILL IN THE ZERO OR THE SIGN
3092          CPI      "0"                      ;DO WE HAVE A ZERO?
3093          JZ       FOTZS1                   ;YES, SUPPRESS IT
3094          CPI      54                       ;54="," DO WE HAVE A COMMA?
3095          JZ       FOTZS1                   ;YES, SUPPRESS IT
3096          CPI      "."                      ;ARE WE AT THE DECIMAL POINT?
3097          JNZ      FOTZS2                   ;NO, I GUESS NOT
3098          DCX      H                        ;YES, BACK UP AND PUT A ZERO BEFORE IT
3099          MVI      M,"0"    
3100 FOTZS2:  MOV      A,E                      ;GET THE FORMAT SPECS TO CHECK FOR A FLOATING
3101          ANI      20                       ;DOLLAR SIGN
3102          JZ       FOTZS3                   ;WE DON'T HAVE ONE
3103          DCX      H                        ;WE HAVE ONE, BACK UP AND PUT IN THE DOLLAR
3104          MVI      M,"$"                    ;SIGN
3105 FOTZS3:  MOV      A,E                      ;DO WE HAVE A TRAILING SIGN?
3106          ANI      4        
3107          RNZ                               ;YES, RETURN NOTE THE NON-ZERO FLAG IS SET
3108 FOFXIS:  DCX      H                        ;NO, BACK UP ONE AND PUT THE SIGN BACK IN
3111          MOV      M,B                      ;PUT IN THE SIGN
3112          RET                               ;ALL DONE
3116 FOUINI:  STA      TEMP3                    ;SAVE THE FORMAT SPECIFICATION
3117          LXI      H,FBUFFR+1               ;GET A POINTER INTO FBUFFR
3118          MVI      M,"      "               ;PUT IN A SPACE
3119          RET                               ;ALL DONE
3122 FOUFRV:  PUSH     H                        ;SAVE THE BUFFER POINTER
3123          JZ       FOUFRS                   ;WE HAVE A SNG
3125          MVI      D,20                     ;WE HAVE A DBL, SET THE DIGIT COUNT
3128 FOUFRS:  MVI      D,6                      ;SET THE DIGIT COUNT
3129          CALL     FOUTNV                   ;NORMALIZE THE FAC SO ALL SIGNIFICANT DIGITS
3131          LXI      B,2*400+$CODE            ;B = DECIMAL POINT COUNT
3135          ADD      D                        ;SEE IF NUMBER SHOULD BE PRINTED IN E NOTATION
3136          JM       FOFRS1                   ;IT SHOULD, IT IS .LT. .1
3137          INR      D                        ;CHECK IF IT IS TOO BG
3138          CMP      D        
3139          JNC      FOFRS1                   ;IT IS TOO BIG, IT IS .GT. 10^D-1
3140          INR      A                        ;IT IS OK FOR FIXED POINT NOTATION
3141          MOV      B,A                      ;SET DECIMAL POINT COUNT
3142          MVI      A,1                      ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
3144 FOFRS1:  DCR      A                        ;E NOTATION: ADD D-1 TO ORIGINAL EXPONENT
3145          POP      H                        ;GET THE BUFFER POINTER BACK
3146          PUSH     PSW                      ;SAVE THE EXPONENT FOR LATER
3147          CALL     FOUTCV                   ;CONVERT THE NUMBER TO DECIMAL DIGITS
3149 FOFRS2:  DCX      H                        ;MOVE BACK TO THE LAST CHARACTER
3150          MOV      A,M                      ;GET IT AND SEE IF IT WAS ZERO
3151          CPI      "0"      
3152          JZ       FOFRS2                   ;IT WAS, CONTINUE SUPPRESSING
3153          CPI      "."                      ;HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
3154          CNZ      INXHRT                   ;YES, IGNORE THE DECIMAL POINT ALSO
3155          POP      PSW                      ;GET THE EXPONENT BACK
3156          JZ       FOUTON                   ;WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
3161 FOFLDN:  MOV      B,A                      ;SAVE THE EXPONENT
3162          LDA      VALTYP                   ;GET THE VALTYP TO DEIDE IF WE PRINT AN "E"
3163          CPI      4                        ;OR A "D"
3164          MOV      A,B                      ;GET THE EXPONENT BACK
3165          JZ       FOUCEE                   ;WE HAVE TO PRINT AN "E"
3166          MVI      M,"D"                    ;GET THE "D"
3168 FOUCEE:  MVI      M,"E"                    ;GET AN "E"
3169          INX      H                        ;PUT SIGN OF EXPONENT IN BUFFER
3171          MVI      M,"+"                    ;A PLUS IF POSITIVE
3172          JP       FOUCE1   
3173          MVI      M,"-"                    ;A MINUS IF NEGATIVE
3174          CMA                               ;NEGATE EXPONENT
3175          INR      
3177 FOUCE1:  MVI      B,"0"-1                  ;INITIALIZE TEN'S DIGIT COUNT
3178 FOUCE2:  INR      B                        ;INCREMENT DIGIT
3179          SUI      12                       ;SUBTRACT TEN
3180          JNC      FOUCE2                   ;DO IT AGAIN IF RESULT WAS POSITIVE
3181          ADI      "0"+12                   ;ADD BACK IN TEN AND CONVERT TO ASCII
3183          INX      H        
3184          MOV      M,B                      ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
3185          INX      H                        ;WHEN WE JUMP TO HERE, A IS ZERO
3186          MOV      M,A                      ;PUT ONE'S DIGIT IN BUFFER
3187 FOUTZR:  INX      M                        ;INCREMENT POINTER, HERE TO FINISH UP PRINTING
3189 FOUTON:  MVI      M,0                      ;PUT A ZERO AT THE END OF THE NUMBER
3190          XCHG                              ;SAVE THE POINTER TO THE END OF THE NUMBER
3192          LXI      H,FBUFFR+1               ;GET A POINTER TO THE BEGINNING
3193          RET                               ;ALL DONE
3197 FOUTCC:  MOV      C,A                      ;SAVE A POSSIBLE COMMA COUNT
3198 FOUICC:  LDA      TEMP3                    ;GET THE FORMAT SPECS
3199          ANI      100                      ;LOOK AT THE COMMA BIT
3200          RNZ                               ;WE ARE USING COMMAS, JUST RETURN
3201          MOV      C,A                      ;WE AREN'T, ZERO THE COMMA COUNT .
3202          RET                               ;ALL DONE
3205 FOUTFX:  CPI      4                        ;CHECK WHAT KIND OF VALUE WE HAVE
3206          MOV      A,D                      ;GET THE FORMAT SPECS
3207          JNC      FOUFXV                   ;WE HAVE A SNG OR A DBL
3209          RAR                               ;CHECK IF WE HAVE TO PRINT IT IN FLOATING
3210          JC       FFXIFL                   ;POINT NOTATION
3212          LXI      B,6*400+3+$CODE          ;SET DECIMAL POINT COUNT TO 6 AND
3214          CALL     FOICC                    ;CHECK IF WE DON'T HAVE TO USE THE COMMAS
3215          POP      D                        ;GET THE FIELD LENGTHS
3216          MOV      A,D                      ;SEE IF WE HAVE TO PRINT EXTRA SPACES BECAUSE
3217          SUI      5                        ;THE FIELD IS TOO BIG
3218          CP       FOTZER                   ;WE DO, PUT IN ZEROS, THEY WILL LATER BE
3220          PUSH     D                        ;SAVE THE FIELD LENGTHS AGAIN
3221          CALL     FOUTCI                   ;CONVERT THE NUMBER TO DECIMAL DIGITS
3222          POP      D                        ;GET THE FIELD LENGTHS BACK
3223          ORA      E                        ;DO WE NEED A DECIMAL POINT? HERE A=0
3224          CZ       FOFXIS                   ;WE DON'T, BACKSPACE OVER IT. AT FOFXIS,
3228          CNZ      FOTZER                   ;FOFXIS PRESERVES THE CONDITION CODES
3234 FOUTTS:  PUSH     H                        ;SAVE BUFFER POINTER
3235          CALL     FOUTZS                   ;ZERO SUPPRESS THE NUMBER
3236          POP      H                        ;GET THE BUFFER POINTER BACK
3237          JZ       FFXIX1                   ;CHECK IF WE HAVE A TRAILING SIGN
3238          MOV      M,B                      ;WE DO, PUT THE SIGN IN THE BUFFER
3239          INX      H                        ;INCREMENT THE BUFFER POINTER
3240 FFXIX1:  MVI      M,0                      ;PUT A ZERO AT THE END OF THE NUMBER
3246          LXI      H,FBUFFR                 ;GET A POINTER TO THE BEGINNING
3247 FOUBE1:  INX      H                        ;INCREMENT POINTER TO THE NEXT CHARACTER
3248 FOUBE5:  LDA      TEMP2                    ;GET THE LOCATION OF THE DECIMAL POINT
3249          SUB      L                        ;FIGURE OUT HOW MUCH SPACE WE ARE TAKING
3250          SUB      0                        ;IS THIS THE RIGHT AMOUNT OF SPACE TO TAKE?
3251          RZ                                ;YES, WE ARE DONE, RETURN FROM FOUT
3252          MOV      A,M                      ;NO, WE MUST HAVE TOO MUCH SINCE WE STARTED
3257          CPI      "        "               ;IF IT IS A SPACE OR AN ASTERISK, WE CAN
3258          JZ       FOUBE1                   ;IGNORE IT AND MAKE THE FIELD SHORTER WITH
3259          CPI      "*"                      ;NO ILL EFFECTS
3260          JZ       FOUBE1   
3261          DCX      H                        ;MOVE THE POINTER BACK ONE TO READ THE
3263          PUSH     H                        ;SAVE THE POINTER
3276 FOUBE2:  PUSH     PSW                      ;PUT THE LAST CHARACTER ON THE STACK, THE
3279          LXI      B,FOUBE2                 ;GET THE ADDRESS WE GO TO IF WE SEE A CHARACTER
3281          PUSH     B                        ;WE ARE LOOKING FOR
3283          CPI      "-"                      ;SAVE IT AND GET THE NEXT CHARACTER IF IT IS
3284          RZ                                ;A MINUS SIGN, A PLUS SIGN OR A DOLLAR SIGN
3285          CPI      "+"      
3286          RZ       
3287          CPI      "$"      
3288          RZ       
3289          POP      B                        ;IT ISNET, GET THE ADDRESS OFF THE STACK
3290          CPI      "0"                      ;IS IT A ZERO?
3291          JNZ      FOUBE4                   ;NO, WE CAN NOT GET RID OF ANOTHER CHARACTER
3292          INX      H                        ;SKIP OVER THE DECIMAL POINT
3294          JNC      FOUBE4                   ;IT IS NOT A DIGIT, WE CAN'T SHORTEN THE FIELD
3295          DCX      H                        ;WE CAN111 POINT TO THE DECIMAL POINT
3297 FOUBE3:  DCX      H                        ;POINT BACK ONE CHARACTER
3298          MOV      M,A                      ;PUT THE CHARACTER BACK
3307          POP      PSW                      ;GET THE CHARACTER OFF THE STACK
3308          JZ       FOUBE3                   ;PUT IT BACK IN THE BUFFER IF IT IS NOT THE
3310          POP      B                        ;GET THE BUFFER POINTER OFF THE STACK
3311          JMP      FOUBE3                   ;SEE IF THE FIELD IS NOW SMALL ENOUGH
3313 FOUBE4:  POP      PSW                      ;GET THE CHARACTERS OFF THE STACK
3314          JZ       FOUBE4                   ;LEAVE THE NUMBER IN THE BUFFER ALONE
3315          POP      H                        ;GET THE POINTER TO THE BEGINNING OF THE
3317          MVI      M,"%"                    ;PUT IN A PERCENT SIGN TO INDICATE THE NUMBER
3319          RET                               ;ALL DONE -- RETURN FROM FOUT
3322 FOUFXV:  PUSH     H                        ;SAVE THE BUFFER POINTER
3323          RAR                               ;GET FIXED OR FLOATING NOTATION FLAG IN CARRY
3324          JC       FFXFLV                   ;PRINT THE NUMBER IN E-NOTATION
3325          JZ       FFXSFX                   ;WE HAVE A SNG
3327          LXI      D,FFXOXM                 ;GET POINTER TO 1D16
3328          CALL     DCOMPD                   ;WE CAN'T PRINT A NUMBER .GE. 10^16 IN FIXED
3330          LXI      D,16*400+$CODE           ;SET D = NUMBER OF DIGITS TO PRINT FOR A DBL
3332          JM       FFXSDC                   ;IF THE FAC WAS SMALL ENOUGH, GO PRINT IT
3334 FFXSDO:  XRA      A                        ;SET THE FORMAT SPECS TO FREE FORMAT
3335          STA      TEMP3    
3336          POP      H                        ;GET THE BUFFER POINTER
3337          DCX      H                        ;SET UP TO JUMP BACK INTO FOUT
3339          CALL     FOUT1                    ;PRINT THE NUMBER IN FREE FORMAT, THE SIGN
3341          DCX      H                        ;POINT IN FRONT OF THE NUMBER
3342          MVI      M,"%"                    ;PUT IN THE PERCENT SIGN
3343          RET                               ;ALL DONE -- RETURN FROM FOUT
3346          CALL     FCOMP    
3347          JP       FFXSDO                   ;IT IS, PRINT IT IN FREE FORMAT WITH A % SIGN
3348          LXI      D,6*400+2+$CODE          ;SET UP FLAGS FOR SNG --
3353          CNZ      FOUTNV                   ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
3355          POP      H                        ;GET THE BUFFER POINTER
3356          POP      B                        ;GET THE FIELD LENGTH SPECS
3357          JM       FFXXVS                   ;DO DIFFERENT STUFF IF EXPONENT IS NEGATIVE
3360          PUSH     B                        ;SAVE THE FIELD LENGTH SPECS AGAIN
3361          MOV      C,A                      ;SAVE THE EXPONENT
3362          MOV      A,B                      ;WE HAVE TO PRINT LEADING ZEROS IF THE FIELD
3363          SUB      D                        ;HAS MORE CHARACTERS THAN THERE ARE DIGITS IN
3364          SUB      C                        ;THE NUMBER
3365          CP       FOTZER                   ;FOUTZS WILL LATER SUPPRESS THEM
3366          MOV      A,C                      ;SET UP THE COMMA COUNT
3367          ADD      E        
3368          MOV      E,C                      ;WE NO LONGER NEED THE NUMBER WE SETUP IN E
3369 FFXXV1:  SUI      3                        ;REDUCE A MOD 3
3370          JNC      FFXXV1   
3371          ADI      5                        ;ADD 3 BACK AND ADD IN 2 MORE FOR SCALING
3372          CALL     FOUTCO                   ;CHECK IF WE HAVE TO USE COMMAS AT ALL
3373          MOV      A,E                      ;SETUP THE DECIMAL POINT COUNT
3374          ADD      D        
3375          INR      A        
3376          MOV      B,A                      ;IT GOES IN B
3377          PUSH     D                        ;SAVE SNG OR DBL AND EXPONENT INFORMATION
3378          CALL     FOUTCV                   ;CONVERT THE NUMBER TO DECIMAL DIGITS
3379          POP      D                        ;GET THE SNG OR DBL AND EXPONENT INFO BACK
3380          ORA      E                        ;PUT IN DIGITS AFTER THE NUMBER IF IT
3382          CNZ      FOTZRC                   ;THERE CAN BE COMMAS IN THESE ZEROS
3383          POP      D                        ;GET THE FIELD LENGTH SPECS
3384          ORA      E                        ;HERE A=0
3385          CNZ      FOUTDP                   ;PRINT A DECIMAL POINT IF NECESSARY
3386          DCR      A                        ;SEE IF WE SHOULD PRINT SOME ZEROS TO FILL IN
3387          CP       FOTZER                   ;THE DECIMAL PLACES
3388          JMP      FOUTTS                   ;GO CHECK THE SIZE, ZERO SUPPRESS, ETC. AND
3391 FFXXVS:  MOV      E,A                      ;SAVE THE EXPONENT, WE DON'T NEED WHAT IS IN E
3392          MOV      A,C                      ;DIVIDE BY TEN THE RIGHT NUMBER OF TIMES SO
3393          ORA      A                        ;THE RESULT WILL BE ROUNDED CORRECTLY AND
3394          CNZ      DCRART                   ;HAVE THE CORRECT NUMBER OF SIGNIFICANT
3395          ADD      E                        ;DIGITS
3396          PUSH     PSW                      ;SAVE THIS NUMBER FOR LATER
3397 FFXXV2:  CM       FINDIV                   ;THIS IS THE DIVIDE LOOP
3398          JM       FFXXV2   
3399          MOV      A,E                      ;WE HAVE TWO CASES DEPENDING ON WHETHER THE
3400          ADD      D                        ;THE NUMBER IS .LT. .1 OR NOT
3401          MOV      A,B      
3402          JM       FFXXV3   
3404          SUB      D                        ;PRINT SOME LEADING ZEROS IF THE FIELD IS
3405          SUB      E                        ;BIGGER THAN THE NUMBER OF DIGITS WE WILL
3406          CP       FOTZER                   ;PRINT
3407          POP      PSW                      ;WE DON'T NEED THE NUMBER WE SAVED BEFORE
3408          MOV      B,E                      ;GET ALL THE PERTINENT INFO IN B,C
3409          PUSH     B                        ;SAVE THE EXPONENT AND "C" IN FIELD SPEC
3410          MOV      A,E                      ;SET UP THE DECIMAL POINT COUNT
3411          ADD      D        
3412          INR      A        
3413          MOV      B,A      
3414          MOV      A,D                      ;SET UP THE COMMA COUNT
3415          ANI      2                        ;THESE 2 INSTRUCTIONS MAP 6 TO 4
3416          ADI      2                        ;AND 16 TO 2
3417          ADD      E        
3418          CALL     FOUTCC                   ;CHECK IF WE HAVE TO DO THE COMMA THING
3419          JMP      FFXXV6                   ;CONVERT THE DIGITS AND DO THE TRIMMING UP
3421 FFXXV3:  CALL     FOTZER                   ;PUT ALL ZEROS BEFORE THE DECIMAL POINT
3422          MOV      A,C                      ;SAVE C
3423          CALL     FOUTOP                   ;PUT IN A DECIMAL POINT
3424          MOV      C,A                      ;RESTORE C
3425          POP      PSW                      ;GET THE NUMBER WE SAVED
3426          JM       FFXXV4                   ;DECIDE HOW MANY ZEROS TO PRINT BETWEEN THE
3427          XRA      A                        ;DECIMAL POINT AND THE FIRST DIGIT WE WILL
3428          SUB      E                        ;PRINT. HERE THE FIELD IS BIG ENOUGH TO
3429          SUB      0                        ;HOLD ALL THE DIGITS
3430          JMP      FFXXV5                   ;DO PRINT THEM
3431 FFXXV4:  MOV      A,C                      ;HERE WE HAD TO DIVIDE BY TEN SO THE FIELD
3432          SUB      D                        ;IS SMALLER THAN ALL SIGNIFICANT DIGITS IN
3433          DCR      A                        ;THE NUMBER
3434 FFXXV5:  CALL     FOTZER                   ;PRINT THE ZEROS
3435          MOV      B,E                      ;SAVE THE EXPONENT IN B
3436          PUSH     B                        ;SAVE EXPONENT AND THE "C" IN THE FIELD SPEC
3437          MOV      B,A                      ;ZERO THE DECIMAL PLACE COUNT
3438          MOV      C,A                      ;ZERO THE COMMA COUNT
3439 FFXXV6:  CALL     FOUTCV                   ;CONVERT THE NUMBER TO DECIMAL DIGITS
3440          POP      D                        ;GET THE EXPONENT AND FIELD SPEC BACK
3441          ORA      E                        ;CHECK IF WE HAVE TO PRINT ANY ZEROS AFTER
3443          JZ       FFXXV7                   ;CHECK IF THERE WERE ANY DECIMAL PLACES AT ALL
3444          ADD      D                        ;PRINT SOME MORE TRAILING ZEROS
3445          DCR      A        
3446          CP       FOTZER   
3447          JMP      FOUTTS                   ;FINISH UP THE NUMBER
3451          JMP      FOUTTS                   ;FINISH UP THE NUMBER
3454 FFXIFL:  PUSH     H                        ;SAVE THE BUFFER POINTER
3455          PUSH     D                        ;SAVE THE FORMAT SPECS
3456          CALL     CONSI                    ;CONVERT THE INTEGER TO A SNG
3457          POP      D                        ;GET THE FORMAT SPECS BACK
3458          POP      H                        ;GET THE BUFFER POINTER BACK
3459          XRA      A                        ;SET FLAGS TO PRINT THE NUMBER AS A SNG
3463 FFXFLV:  JZ       FFXSFL                   ;IF WE HAVE A SNG, SET THE RIGHT FLAGS
3464          MVI      E,20                     ;WE HAVE A DBL, GET HOW MANY DIGITS WE HAVE
3466 FFXSFL:  MVI      E,6                      ;WE HAVE A DBL, GET HOW MANY DIGITS WE PRINT
3468          CNZ      FOUTNV                   ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
3470          POP      H                        ;GET THE BUFFER POINTER BACK
3471          POP      B                        ;GET THE FIELD LENGTH SPECS
3472          PUSH     PSW                      ;SAVE THE EXPONENT
3473          MOV      A,C                      ;CALCULATE HOW MANY SIGNIFICANT DIGITS WE MUST
3474          ORA      A                        ;PRINT
3475          PUSH     PSW                      ;SAVE THE "C" FIELD SPEC FOR LATER
3476          CNZ      DCRART   
3477          ADD      B        
3478          MOV      C,A      
3479          MOV      A,D                      ;GET THE FIELD SPEC
3480          ANI      4                        ;SEE IF THE SIGN IS A TRAILING SIGN
3481          CPI      1                        ;SET CARRY IF A IS ZERO
3482          SBB      A                        ;SET D=0 IF WE HAVE A TRAILING SIGN,
3483          MOV      D,A                      ;D=377 IF WE DO NOT
3484          ADD      C        
3485          MOV      C,A                      ;SET C=NUMBER OF SIGNIFICANT DIGITS TO PRINT
3486          SUB      E                        ;IF WE HAVE LESS THAN E, THEN WE MUST GET RID
3487 FFXLV1:  CM       FINDIV                   ;OF SOME BY DIVIDING BY TEN AND ROUNDING
3488          JM       FFXLV1   
3489          PUSH     B                        ;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
3490          MOV      A,B                      ;SET THE DECIMAL PLACE COUNT
3491          INR      A        
3492          SUB      D                        ;TAKE INTO ACCOUNT IF THE SIGN IS TRAILING
3493          MOV      B,A      
3494          MVI      C,0                      ;SET COMMA COUNT TO ZERO, THE COMMA SPEC IS
3495          PUSH     D                        ;IGNORED. SAVE TRAILING SIGN INFO
3496          CALL     FOUTCV                   ;CONVERT THE NUMBER TO DECIMAL DIGITS
3497          POP      D                        ;GET THE TRAILING SIGN INFO BACK
3498          POP      B                        ;GET # OF SIG DIGITS AND "B" FIELD SPEC BACK
3499          MOV      A,C                      ;PRINT TRAILING ZEROS IF THE FIELD LENGTH IS
3500          SUB      E                        ;LONGER THAN ENUMBER OF DIGITS WE CAN PRINT
3502          CP       FOTZRC                   ;THE DECIMAL POINT COULD COME OUT IN HERE
3503          POP      PSW                      ;GET THE "C" FIELD SPEC BACK
3504          CZ       FOFXIS                   ;IF C=0, THE LAST THING WAS A DECIMAL POINT,
3507          POP      PSW                      ;GET THE EXPONENT BACK
3508          ADD      E                        ;SCALE IT CORRECTLY
3509          SUB      B        
3510          SUB      D        
3511          PUSH     B                        ;SAVE THE "B" FIELD SPEC
3512          CALL     FOFLDN                   ;PUT THE EXPONENT IN THE BUFFER
3513          XCHG                              ;GET THE POINTER TO THE END IN (HL)
3515          POP      D                        ;GET THE "B" FIELD SPEC IN D, PUT ON POSSIBLE
3517          JMP      FOUTTS                   ;TRAILING SIGN AND WE ARE DONE
3522 FOUTNV:  PUSH     D                        ;SAVE (DE)
3523          LDA      VALTYP                   ;GET WHAT KIND OF VALUE WE HAVE
3524          CPI      4        
3525          JNZ      FOUTNO                   ;WE HAVE A DBL
3527          XRA                               ;ZERO THE EXPONENT
3528          PUSH     PSW                      ;SAVE IT
3529          CALL     FOUNSC                   ;IS THE FAC TOO BIG OR TOO SMALL?
3531          CALL     FCOMP                    ;ENOUGH YET
3532          JPO      FOUNS3                   ;IT IS, WE ARE DONE
3533          POP      PSW                      ;IT ISN'T, MULTIPLY BY TEN
3534          CALL     FINMLT   
3535          PUSH     PSW                      ;SAVE THE EXPONENT AGAIN
3536          JMP      FOUNS1                   ;NOW SEE IF IT IS BIG ENOUGH
3537 FOUNS2:  POP      PSW                      ;THE FAC IS TOO BIG, GET THE EXPONENT
3538          CALL     FINDIV                   ;DIVIDE IT BY TEN
3539          PUSH     PSW                      ;SAVE THE EXPONENT AGAIN
3540          CALL     FOUNSC                   ;SEE IF THE FAC IS SMALL ENOUGH
3541 FOUNS3:  POP      PSW                      ;WE ARE DONE, GET THE EXPONENT BACK
3542          POP      D                        ;GET (DE) BACK
3543          RET                               ;ALL DONE
3546          CALL     FCOMP    
3547          POP      H                        ;GET THE RETURN ADRESS OFF THE STACK
3548          JPO      FOUNS2                   ;IT IS TOO BIG, MAKE IT SMALLER
3549          PCHL                              ;IT IS SMALL ENOUGH, RETURN
3564          JM       FCERR                    ;CAN'T TAKE SQR OF NEGATIVE NUMBER
3565          RZ                                ;0=SQR(0)
3566          LXI      H,FAC                    ;SCALE ARGUMENT TO BETWEEN .5 AND 2
3567          MOV      A,M                      ;GET EXPONENT
3568          RAR                               ;GET EXPONENT OF SCALE FACTOR
3570          PUSH     PSW                      ;SAVE IT
3571          PUSH     H                        ;SAVE POINTER TO EXPONENT
3572          MVI      A,100                    ;SET EXPONENT OF SCALED DOWN NUMBER
3573          RAL      
3574          MOV      M,A                      ;REPLACE IT
3575          LXI      H,FBUFFR                 ;SAVE A
3576          CALL     MOVMF    
3577          MVI      A,4                      ;SET ITERATION COUNT
3578          SQR11    PUSH     PSW             ;SAVE COUNT
3579          CALL     PUSHF                    ;SAVE X(N)
3580          LXI      H,FBUFFR                 ;COMPUTE A/X(N)
3581          CALL     MOVRM                    ;GET A IN THE REGISTERS
3582          CALL     FDIV     
3584          CALL     FADD                     ;ADD IN X(N)
3585          LXI      H,FHALF                  ;DIVIDE BY 2
3586          CALL     FMULTS   
3587          POP      PSW                      ;GET COUNT
3588          DCR      A                        ;ARE WE DONE?
3589          JNZ      SQR1                     ;NO, DO MORE ITERATIONS
3590          POP      H                        ;YES, SET EXPONENT OF ANSWER
3591          POP      PSW                      ;GET SCALE FACTOR
3592          ADI      300                      ;CONVERT TO AN EXPONENT
3593          ADD      M                        ;ADD EXPONENT IN
3594          MOV      M,A                      ;REPLACE EXPONENT
3600 PSHNEG:  LXI      H,NEG                    ;GET THE ADDRESS OF NEG
3603          XTHL                              ;SWITCH RET ADDR AND ADDR OF NEG
3604          PCHL                              ;RETURN, THE ADDRESS OF NEG IS ON THE STACK
3609 SQR:     CALL     PUSHF                    ;SAVE ARG
3612          LXI      H,FHALF                  ;GET 1/2
3615          CALL     MOVEM                    ;SQR(X)=X^.5
3634          JZ       EXP                      ;IT IS, RESULT IS ONE
3637          MOV      A,B                      ;SEE IF X IS ZERO
3638          ORA      A        
3639          JZ       ZERO0                    ;IT IS, RESULT IS ZERO
3644          MOV      A,C                      ;CHECK THE SIGN OF X
3645          ORI      177                      ;TURN THE ZERO FLAG OFF
3647          CALL     MOVRF                    ;GET Y IN THE REGISTERS
3650          JP       FPWR1                    ;NO PROBLEMS IF X IS POSITIVE
3655          CALL     INT                      ;SEE IF Y IS AN INTEGER
3660          PUSH     PSW                      ;SAVE LO OF INT FOR EVEN AND ODD INFORMATION
3661          CALL     FCOMP                    ;SEE IF WE HAVE AN INTEGER
3664          POP      H                        ;GET EVEN-ODD INFORMATION
3665          MOV      A,H                      ;PUT EVEN-000 FLAG IN CARRY
3666          RAR      
3667 FPWR1:   POP      H                        ;GET X BACK IN FAC
3668          SHLD     FAC-1                    ;STORE HO'S
3671          POP      H                        ;GET LO'S OFF STACK
3672          SHLD     FACLO                    ;STORE THEM IN FAC
3675          CC       PSHNEG                   ;NEGATE NUMBER AT END IF Y WAS ODD
3678          CZ       NEG                      ;NEGATE THE NEGATIVE NUMBER
3683          CALL     LOG                      ;COMPUTE EXP (CY*LOG(X))
3688          CALL     FMULT>                   ;LOG WILL BLOW HIM OUT OF THE WATER
3704 EXP:     CALL     PUSHF                    ;SAVE ARGUMENT
3713          CALL     FMULT                    ;INT(ARG/LN(2)) # INT(ARG*LN(2)) = INT(ARG*LOG2(E))
3716          LDA      FAC                      ;CARRY=0 IF FAC IS TOO BIG
3719          CPI      210                      ;I.E. IF ABS(FAC) .GE. 128
3721          JNC      MLDVEX                   ;IT IS TOO BIG
3724          CALL     INT                      ;IS ARGUMENT TOO BIG?
3727          ADI      200                      ;CHECK FOR OVERFLOW
3729          ADI      2        
3731          JC       MLDVEX                   ;WE HAVE OVERFLOW!!
3734          PUSH     PSW                      ;SAVE SCALE FACTOR
3735          LXI      H,FONE                   ;ADD ONE TO THE NUMBER
3738          CALL     FADDS    
3741          CALL     MULLN2                   ;MULTIPLY BY LN(2)
3744          POP      PSW                      ;GET SCALE FACTOR OFF STACK
3747          PUSH     PSW                      ;PUT SCALE FACTOR BACK ON STACK
3748          CALL     FSUB                     ;SUBTRACT ORIGINAL ARG
3751          CALL     NEG      
3754          LXI      H,EXPCON                 ;EVALUATE THE APPROXIMATION POLYNOMIAL
3757          CALL     POLY     
3760          LXI      D,$CODE                  ;MULTIPLY BY 2 ^ (B-1) INSTEAD OF JUST
3763          POP      B                        ;ADDING IT TO THE EXPONENT SO FMULT
3764          MOV      C,D                      ;WILL CHECK FOR EXPONENT OVERFLOW
3765          JMP      FMULT    
3812 POLYX:   CALL     PUSHF                    ;SAVE X
3815          LXI      D,FMULTT                 ;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
3818          PUSH     D                        ;RETURN WE WILL MULTIPLY BY X
3819          PUSH     H                        ;SAVE CONSTANT POINTER
3820          CALL     MOVRF                    ;SQUARE X
3823          CALL     FMULT    
3826          POP      H                        ;GET CONSTANT POINTER
3836 POLY:    CALL     PUSHF                    ;SAVE X
3839          MOV      A,M                      ;GET DEGREE
3840          INX      H                        ;INCREMENT POINTER TO FIRST CONSTANT
3841          CALL     MOVFM                    ;MOVE FIRST CONSTANT TO FAC
3845 POLY1:   POP      PSW                      ;GET DEGREE
3848          DCR      A                        ;ARE WE DONE?
3849          RZ                                ;YES, RETURN
3852          PUSH     PSW                      ;SAVE DEGREE
3853          PUSH     H                        ;SAVE CONSTANT POINTER
3854          CALL     FMULT                    ;EVALUATE THE POLY, MULTIPLY BY X
3857          POP      H                        ;GET LOCATION OF CONSTANTS
3858          CALL     MOVRM                    ;GET CONSTANT
3861          PUSH     H                        ;STORE LOCATION OF CONSTANTS SO FADD AND FMULT
3863          CALL     FADD                     ;WILL NOT SCREW THEM UP, ADD IN CONSTANT
3866          POP      H                        ;MOVE CONSTANT POINTER TO NEXT CONSTANT
3867          JMP      POLY1>                   ;SEE IF DONE
3888          CALL     VSIGN                    ;GET THE SIGN OF THE ARG
3889          PUSH     PSW                      ;SAVE THE SIGN
3890          CM       FRCSNG                   ;IF IT IS NEGATIVE, FORCE IT TO BE A SNG
3891          MVI      A,4                      ;SINCE WE WILL USE IT
3892          STA      VALTYP                   ;MAKE SURE THE RESULT IS "SINGLE PRECISION"
3893          POP      PSW>                     ;GET THE SIGN BACK
3894          JM       RND1                     ;START NEW SEQUENCE IF NEGATIVE
3897          LXI      H,RNDX                   ;GET LAST NUMBER GENERATED
3900          CALL     MOVFM    
3903          RZ                                ;RETURN LAST NUMBER GENERATED IF ZERO
3905          CALL     FMULTS>                  ;MULTIPLY BY CONSTANT A
3907          CALL     MOVRM    
3910          CALL     FMULT>   
3919          CALL     FADD     
3922 RND1:    CALL     MOVRF                    ;SWITCH HO AND LO BYTES,
3925          MOV      A,E                      ;GET LO
3926          MOV      E,C                      ;PUT HO IN LO BYTE
3927          MOV      C,A                      ;PUT LO IN HO BYTE
3928          MVI      M,200                    ;MAKE RESULT POSITIVE
3930          DCX      H                        ;GET POINTER TO EXPONENT
3931          MOV      B,M                      ;PUT EXPONENT IN OVERFLOW POSITION
3932          MVI      M,200                    ;SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
3934          CALL     NORMAL                   ;NORMALIZE THE RESULT
3937          LXI      H,RNDX                   ;SAVE RANDOM NUMBER GENERATED FOR NEXT
3940          JMP      MOVMF                    ;TIME
3958 COS:     LXI      H,PI2                    ;ADD PI/2 TO FAC
3961          CALL     FADDS>   
3974 SIN:     CALL     PUSHF                    ;DIVIDE FAC BY 2*PI
3983          CALL     MOVER                    ;BETWEEN 0 AND 1
3988          CALL     FDIV     
3991          CALL     PUSHF                    ;DISREGARD INTEGER PART SINCE SIN
3994          CALL     INT                      ;IS PERIODIC WITH PERIOD 2*PI
3999          CALL     FSUB     
4003          LXI      B,177*400+$CODE          ;GET 1/4
4004          MOV      D,C      
4005          MOV      E,C      
4006          CALL     FSUB>    
4008          LXI      H,FR4                    ;SEE WHAT QUADRANT WE ARE IN
4011          CALL     FSUBS>   
4015          STC                               ;SET QUADRANT I FLAG
4016          JP       SIN1                     ;FIRST QUADRANT, GET BACK ORIGINAL X
4019          CALL     FADDH                    ;ADD 1/2
4023          ORA      A                        ;CLEAR CARRY
4024 SIN1:    PUSH     PSW                      ;SAVE QUADRANT FLAG
4025          CP       NEG                      ;NEGATE IF IN QUADRANTS I, II OR III
4029          LXI      B,177*400+$CODE          ;GET 1/4
4030          MOV      D,C      
4031          MOV      E,C      
4032          CALL     FADD>    
4034          LXI      H,FR4                    ;ADD 1/4, IN QUADRANTS II, III
4039          CALL     FADDS>                   ;SIN(X-2*PI)=SIN(X)
4042          POP      PSW                      ;GET QUADRANT FLAG
4043          CNC      NEG                      ;NEGATE IF IN QUADRANTS II, III OR IV
4047          CALL     PUSHF                    ;SAVE X
4048          CALL     MOVRF                    ;SQUARE X
4049          CALL     FMULT    
4050          CALL     PUSHF                    ;SAVE X-2
4051          LXI      H,SINCON 
4052          CALL     MOVEM                    ;MOVE FIRST CONSTANT INTO FAC
4054          MVI      A,4                      ;GET DEGREE
4055 POLY1:   PUSH     PSW                      ;SAVE DEGREE
4057          PUSH     H                        ;SAVE CONSTANT POINTER
4058          CALL     FMULT                    ;EVALUATE THE POLY, MULTIPLY BY X*2
4059          POP      H                        ;GET POINTER TO CONSTANTS
4060          CALL     MOVRM                    ;GET CONSTANT
4061          PUSH     H                        ;SAVE POINTER
4062          CALL     FADD                     ;ADD IN CONSTANT
4063          POP      H                        ;MOVE POINTER TO NEXT CONSTANT
4065          POP      PSW                      ;GET DEGREE
4066          DCR      A                        ;SEE IF DONE
4067          JNZ      POLY1                    ;NO, DO NEXT TERM
4068          JMP      FMULTI>                  ;MULTIPLY BY X AND WE ARE DONE
4070          LXI      H,SINCON                 ;CALCULATE THE SIN BY EVALUATING
4073          JMP      POLYX>                   ;THE APPROXIMATION POLYNOMIAL
4114 TAN:     CALL     PUSHF                    ;SAVE ARG
4117          CALL     SIN                      ;TAN(X)=SIN(X)/COS(X)
4120          POP      B                        ;GET X OFF STACK
4121          POP      H                        ;PUSHF SMASHES (DE)
4122          CALL     PUSHF    
4126          CALL     MOVER    
4129          CALL     COS      
4132          JMP      FDIVT>   
4141          CM       PSHNEG                   ;IF ARG IS NEGATIVE, USE:
4144          CM       NEG                      ;ARCTAN(X)=-ARCTAN(-X)
4147          LDA      FAC                      ;SEE IF FAC .GT. 1
4150          CPI      201      
4152          JC       ATN2     
4155          LXI      B,201*400+$CODE          ;GET THE CONSTANT 1
4158          MOV      D,C      
4159          MOV      E,C                      ;COMPUTE RECIPROCAL TO USE THE IDENTITY:
4160          CALL     FDIV                     ;ARCTAN(X)=PI/2-ARCTAN(1/X)
4163          LXI      H,FSUBS                  ;PUT FSUBS ON THE STACK SO WE WILL RETURN
4166          PUSH     H                        ;TO IT AND SUBTRACT THE REULT FROM PI/2
4167 ATN2:    LXI      H,ATNCON                 ;EVALUATE APPROXIMATION POLYNOMIAL
4170          CALL     POLYX    
4173          LXI      H,P12                    ;GET POINTER TO PI/2 IN CASE WE HAVE TO
4176          RET                               ;SUBTRACT THE RESULT FROM PI/2
4230 INITAT:  LXI      H,AUTTXT 
4233          CALL     STROUT   
4238          IN       1                        ;IGNORE GARBAGE CHARACTER IN INTERFACE
4240          IN       ^D255                    ;SEE WHAT KIND OF I/O HE IS
4242          ANI      ^O100                    ;IS HE FUNNY TTY?
4244          JZ       NOTSIO   
4247          LXI      H,FUNIO  
4253          MVI      H,^O310  
4255          SHLD     CNLCA3##+2
4259          MVI      H,^O304                  ;SUBSTITUE "CNZ"
4261          SHLD     CNLCA4##+2>
4265          LXI      H,FUNIO  
4268          SHLD     CNLCA1##+2
4271 NOTSIO:  IN       ^D255    
4273          ANI      ^O40     
4275          JZ       NOTPIO   
4279          LXI      H,FUNIO  
4282          SHLD     CNLCA2+2 
4285          MVI      H,^O310  
4287          SHLD     CNLCA3+2 
4291          MVI      H,^O304  
4293          SHLD     CNLCA4+2>
4297          LXI      H,FUNIO  
4300          SHLD     CNLCA1+2 
4304          LXI      H,$CODE+^D65535
4307          SHLD     CURLIN##                 ;IN CASE OF ERROR MESSAGE
4310          LXI      H,TSTACK                 ;SET UP TEMP STACK
4313          SPHL     
4314          SHLD     STKTOP## 
4318          XRA      A        
4319          STA      CNTWFL##>
4322          CALL     CRDO                     ;TYPE A CR
4326          LXI      H,TEMPST##
4329          SHLD     TEMPPT##>
4333          LXI      H,MEMORY                 ;ASK HOW MUCH MEMORY AVAILABLE
4336          CALL     STROUT                   ;CALL THE STRING PRINTER
4339          CALL     QINLIN                   ;GET A LINE OF INPUT
4343          CPI      "A"      
4345          JZ       INITAT   
4349          JNZ      USEDE9                   ;NON ZERO, DONT USE DEFAULT
4352          LXI      H,LASTWR 
4355 LOOPMM:  INX      H        
4356          MVI      A,311    
4358          MOV      M,A      
4359          CMP      M        
4360          JNZ      USEDEF   
4363          DCR      A        
4364          MOV      M,A      
4365          CMP      M        
4366          JZ       LOOPMM   
4369          JMP      USEDEF   
4372 USEDE9:  LXI      H,BUF    
4375          CALL     LINGET                   ;GET DECIMAL AMOUNT OF MEMORY IN (D,E)
4378          ORA      A        
4379          JNZ      SNERR                    ;MAKE SURE HE HAS A TERMINATOR
4382          XCHG     
4383          DCX      H        
4384 USEDEF:  DCX      H>       
4386          LXI      H,$CODE+16190>
4387          PUSH     H                        ;ALSO SAVE FOR LATER
4388 TTYW:    LXI      H,TTYWIO 
4391          CALL     STROUT   
4394          CALL     QINLIN   
4398          ORA      A        
4399          JZ       DFLENT   
4402          LXI      H,BUF    
4405          CALL     LINGET   
4408          MOV      A,D      
4410          JNZ      TTYW     
4413          MOV      A,E      
4414          CPI      16       
4416          JC       TTYW     
4419          STA      LINPT1##                 ;DECLARE LINPT1 EXTERNAL
4423          STA      LINPT2##>
4427          STA      LINPT3##>
4430 MORCPS:  SUI      14       
4432          JNC      MORCPS   
4435          ADI      28       
4437          CMA      
4438          INR      A        
4439          ADD      E        
4440          STA      LINPT4## 
4445          LXI      D,$CODE+^D65536-^D50+1
4448          POP      H        
4449          SHLD     MEMSIZ##                 ;SAVE IN REAL MEMORY SIZE
4452          SHLD     PRETOP##                 ;STRINGS START FROM HERE DOWN
4455          DAD      D                        ;CALC STRBOT BY SUBTRACTING 200 FROM STKTOP
4456          JNC      OMERR                    ;MUST BE POSITIVE
4459          DCX      H                        ;ONE LOWER IS STKTOP
4460          PUSH     H>                       ;SAVE IT ON STACK
4466 ASKAGN:  LXI      H,TBLDO                  ;START OF FUNCTION TABLE
4468          LXI      D,TBDASK                 ;DONE ASKING?
4470          JZ       FINFUN                   ;YES, GET FIRST FREE MEM LOC
4473          XTHL                              ;[H,L]=MESSAGE POINTER
4475          CALL     STROUT                   ;PRINT THE MESSAGE
4476          CALL     QINLIN                   ;SEE WHAT ME HAS TO SAY
4478          POP      H                        ;POP OFF POINTER INTO TBLDO
4479          CPI      "Y"      
4480 FINFUN:  POP      D                        ;POP OFF CANDIDATE FOR START OF
4482          JZ       HAVFNS                   ;HE WANTS IT SO WE ARE DONE
4483          CPI      "N"                      ;IF A BAD ANSWER
4484          JNZ      ASKAGN                   ;MAKE HIM START OVER
4487          XTHL                              ;[H,L]=FIXUP PLACE
4489          LXI      D,ILLFUN                 ;THIS IS WHAT WE STORE
4490          MOV      M,E      
4491          INX      H        
4492          MOV      M,D      
4493          POP      H                        ;GET TBLDO POINTER
4494          JMP      LOPASK>                  ;GQ ASK AGAIN FOR ANOTHER FUNCTION
4496 ASKAGN:  LXI      H,FNS                    ;ASK IF WANTS SIN, COS, ATN.
4499          CALL     STROUT                   ;THE STRING
4502          CALL     QINLIN   
4506          CPI      "Y"      
4508          LXI      D,INITSA                 ;ASSUME NOT DELETE ANY FNS
4511          JZ       HAVENS                   ;YUP.
4514          CPI      "A"      
4516          JZ       OKCHAR   
4519          CPI      "N"      
4521          JNZ      ASKAGN   
4524 OKCHAR:  LXI      H,ILLFUN                 ;MAKE SURE BOMBS IF TRIES TO CALL THEM
4527          LXI      D,ATN    
4533          CPI      "A"                      ;DELETE ATN BUT NOT SIN, COST
4535          JZ       HAVENS                   ;TEST
4538          SHLD     COSFIX## 
4541          SHLD     TANFIX## 
4544          SHLD     SINFIX## 
4547          LXI      D,COS>   
4551          XCHG                              ;PUT BOTTOM OF MEMORY IN (H,L)
4552          MVI      M,0                      ;STORE IT
4554          INX      H                        ;INCREMENT POINTER
4555          SHLD     TXTTAB##                 ;SAVE BOTTOM OF MEMORY
4558          XTHL     
4559          LXI      D,TSTACK 
4563          JC       OMERR    
4566          POP      D        
4567          SPHL     
4568          SHLD     STKTOP   
4572          CALL     REASON   
4575          MOV      A,E                      ;SUBRACT VARTAB FROM STKTOP
4576          SUB      L                        ;LOW PART
4577          MOV      L,A      
4578          MOV      A,D                      ;HIGH PART
4579          SBB      H        
4580          MOV      H,A                      ;LEAVE IN [B,C]
4581          LXI      B,$CODE+65520
4584          DAD      B        
4585          CALL     CRDO                     ;TYPE CRLF
4588          CALL     LINPRT                   ;PRINT # OF BYTES FREE
4591          LXI      H,WORDS                  ;TYPE THE HEADING
4594          CALL     STROUT                   ;"ALTAIR BASIC VERSION-----"
4597          LXI      H,STROUT 
4600          SHLD     REPINI##+1
4603          CALL     SCRTCH                   ;NOW SET UP EVERYTHING ELSE
4607          MVI      A,4      
4608          OUT      2                        ;CLEAR THE LPT
4609          XRA      A        
4610          STA      PRTFLG## 
4611          STA      LPTPOS##>
4616          LXI      H,CONSDO##>
4617          SHLD     $CODE+2  
4620          PCHL     
