
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 10-4
F4
MAC
23-AUG-64 06:08
INTEGER ARITHMETIC ROUTINES
1899
30600
SBB
H
;NEGATE HO
1900
30620
MOV
H,A
1SAVE IT
1901
30640
RET
FALL DONE
1902
30660
1903
30680
1904
30700
INTEGER ABSOLUTE VALUE
1905
30720
BALTERS A,B,C,D,E,H,L
1906
30740
IABS:
LDA
FACLO+1
;GET SIGN OF INTEGER IN FAC
1907
30760
ORA
A
;CHECK ITS SIGN
1908
30780
RP
IIT IS POSITIVE, LEAVE IT ALONE
1909
30800
IFALL INTO INEG AND NEGATE IT
1910
30820
1911
30840
1912
30860
;INTEGER NEGATION
1913
30880
BALTERS A,B,C,O,E,H,L
1914
30900
INEG:
LHLD
FACLO
IGET THE INTEGER
1915
30920
CALL
INEGHL
INEGATE IT
o
1916
30940
SHLD
FACLO
;STORE IT BACK IN THE FAC
1917
30960
XRI
200
;CHECK FOR SPECIAL CASE OF 32768
1918
30980
ORA
1919
31000
RNZ
IIT DID NOT OCCUR, EVERYTHING IS FINE
1920
31020
XCHG
;WE HAVE IT, FLOAT 32768
1921
31040
MVI
A,4
;CHANGE VALTYP 10 "SINGLE PRECISION"
1922
31060
STA
VALTYP
1923
31080
INEGAD: MVI
8,230
SENTRY FROM IADD, SET EXPONENT
1924
31100
JMP
FLOATR
;GO FLOAT THE NUMBER
1925
31120
1926
31140
1927
31160
;MOD OPERATOR
1928
31180
(HL):=(DE)-(DE)/(HL)*(HL) (DE)=QUOTIENT
1929
31200
BALTERS A,B,C,D,E,M,L
1930
31220
MOD:
PUSH
D
;SAVE (DE) FOR ITS SIGN
1931
31240
CALL
IDIV
;DIVIDE AND GET THE REMAINDER
1932
31260
XCHG
1PUT REMAINDER IN (DE)
1933
31280
MVI
A,2
;SET VALTYP TO "INTEGER" IN CASE RESULT OF
1934
31300
STA
VALTYP
, THE DIVISION WAS 32768
1935
31320
POP
PSW
1 GET THE SIGN OF (DE) BACK
1936
31340
JMP
INEGA>
INEGATE THE REMAINDER IF NECESSARY
1937
31360
PAGE
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 11
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
1938
31380
SUBTTL DOUBLE PRECISION ARITHMETIC ROUTINES
1939
31400
IFE
LENGTH-2,
1940
31420
COMMENT %
1941
31440
DOUBLE PRECISION ARITHMETIC CONVENTIONS
1942
31460
1943
31480
DOUBLE PRECISION NUMBERS ARE 8 BYTE QUANTITIES
1944
31500
THE LAST 4 BYTES IN MEMORY ARE IN THE SAME FORMAT AS SINGLE PRECISION NUMBERS
1945
31520
THE FIRST 4 BYTES ARE 32 MORE LOW ORDER BITS OF PRECISION
1946
31540
THE LOWEST ORDER BYTE COMES FIRST IN MEMORY
1947
31560
1948
31580
CALLING CONVENTIONS:
1949
31600
FOR ONE ARGUMENT FUNCTIONS:
1950
31620
THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
1951
31640
FOR TWO ARGUMENT OPERATIONS:
1952
31660
THE FIRST ARGUMENT IS IN ARG-7,6,5,4,3,2,1,0 (NOTE: ARGLO=ARG-7)
1953
31680
THE SECOND ARGUMENT IS IN THE FAC
1954
31700
THE RESULT IS LEFT IN THE FAC
1955
31720
VALTYP (COUBLE PRECISION)=10 OCTAL
1956
31740
%
1957
31760
1958
31780
1959
31800
BOUBLE PRECISION SUBTRACTION FAC:=ARG-FAC
1960
31820
;ALTERS ALL REGISTERS
1961
31840
DSUB:
CALL
NEG
;NEGATE THE SECOND ARGUMENT
1962
31860
;FALL INTO DADD
1963
31880
1964
31900
1965
31920
TOOUBLE PRECISION ADDITION
FAC:=ARG+FAC
1966
31940
;ALTERS ALL REGISTERS
1967
31960
DADD:
LXI
H, ARG
IGET POINTER TO EXPONENT OF FIRST ARGUMENT
1968
31980
MOV
A,M
;CHECK IF IT IS ZERO
1969
32000
ORA
A
1970
32020
RZ
IIT IS, RESULT IS ALREADY IN FAC
1971
32040
MOV
B,A
;SAVE EXPONENT FOR UNPACKING
1972
32060
DCX
H
;POINT TO HO AND SIGN
1973
32080
MOV
C,M
;GET HO AND SIGN FOR UNPACKING
1974
32100
LXI
D,FAC
;GET POINTER TO EXPONENT OF SECOND ARGUMENT
1975
32120
LDAX
0
;GET EXPONENT
1976
32140
ORA
A
;SEE IF IT IS ZERO
1977
32160
JZ
VMOVFA
;IT IS, MOVE ARG TO FAC AND WE ARE DONE
1978
32180
SUB
8
;SUBTRACT EXPONENTS TO GET SHIFT COUNT
1979
32200
JNC
DADD2
IPUT THE SMALLER NUMBER IN FAC
1980
32220
CMA
INEGATE SHIFT COUNT
1981
32240
INR
A
1982
32260
PUSH
PSW
;SAVE SHIFT COUNT
1983
32280
PUSH
B
;SAVE HO TO UNPACK LATER
1984
32300
MVI
C,10
;SWITCH FAC AND ARG, SET UP A COUNT
1985
32320
INX
H
;POINT TO ARG
1986
32340
DADD1:
LDAX
0
;GET A BYTE OF THE FAC
1987
32360
MOV
B,M
;GET A BYTE OF ARG
1988
32380
MOV
M,A
;PUT THE FAC BYTE IN ARG
1989
32400
MOV
A,B
;PUT THE ARG BYTE IN A
1990
32420
STAX
D
;PUT THE ARG BYTE IN FAC
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFR MACRO 47(113) 06:09 27-AUG-75 PAGE 11-1
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
1991
32440
DCX
D
;POINT TO THE NEXT LO BYTE OF FAC
1992
32460
DCX
H
;POINT TO THE NEXT LO BYTE OF ARG
1993
32480
DCR
C
IARE WE DONE?
1994
32500
JNZ
DADD1
INO, DO THE NEXT LO BYTE
1995
32520
POP
8
;GET THE HO BACK
1996
32540
POP
PSW
;GET THE SHIFT COUNT BACK
1997
32560
DADD2:
CPI
71
PARE WE WITHIN 56 BITS?
1998
32580
RNC
INO, ALL DONE
1999
32600
PUSH
PSW
;SAVE SHIFT COUNT
2000
32620
CALL
UNPACK
RUNPACK THE NUMBERS
2001
32640
MOV
B,A
;SAVE SUBTRACTION FLAG
2002
32660
MOV
A,C
;SAVE THE UNPACKED HO
2003
32680
STA
ARG-1
2004
32700
POP
PSW
;GET SHIFT COUNT
2005
32720
CALL
DSHFTR
;SHIFT FAC RIGHT THE RIGHT NUMBER OF TIMES
2006
32740
ORA
B
;GET SUBTRACTION FLAG, HERE A=0
2007
32760
JP
DADD3
;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
2008
32780
CALL
DADDAA
;SIGNS ARE THE SAME, ADD THE NUMBERS
2009
32800
JNC
DROUND
;ROUND THE RESULT IF NO CARRY
2010
32820
INR
M
IWE HAVE OVERFLOW, ADD ONE TO THE EXPONENT
2011
32840
JZ
OVERR
;CHECK FOR OVERFLOW
2012
32860
MVI
0,1
;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
2013
32880
CALL
DSHFRA
2014
32900
JMP
DROUND
,ROUND THE RESULT
2015
32920
DADD3:
XWD
1000,076
,"MVI A", SUBTRACT THE NUMBERS
2016
32940
SBB
M
;GET THE SUBTRACT INSTRUCTION IN A
2017
32960
CALL
DADDA
|SUBTRACT THE NUMBERS
2018
32980
INX
H
POINT TO THE UNPACKED SIGN
2019
33000
MOV
A,M
;COMPLEMENT IT, SINCE THE FAC WAS SMALLER
2020
33020
CMA
2021
33040
MOV
M,A
2022
33060
CC
DNEGR
INEGATE THE RESULT IF IT WAS NEATIVE
2023
33080
1FALL INTO DNORML
2024
33100
2025
33120
2026
33140
;NORMALIZE FAC
2027
33160
;ALTERS A,B,C,D,H,L
2028
33180
DNORML: XRA
A
;CLEAR SHIFT COUNT
2029
33200
DNORM1: MOV
B,A
;SAVE SHIFT COUNT
2030
33220
LDA
FAC-1
;GET HO
2031
33240
ORA
A
ISEE IF WE CAN SHIFT 8 LEFT
2032
33260
JNZ
DNORMS
I WE CAN'T, SEE IF NUMBER IS NORMALIZED
2033
33280
LXI
H,DFACLO-1
I WE CAN, GET POINTER TO LO
2034
33300
MVI
C,10
1SET UP A COUNT
2035
33320
DNORM2: MOV
D,M
;GET A BYTE OF FAC
2036
33340
MOV
M,A
IPUT IN BYTE FROM LAST LOCATION, THE FIRST
2037
33360
: TIME THROUGH A IS ZERO
2038
33380
MOV
A,O
;PUT THE CURRENT BYTE IN A FOR NEXT TIME
2039
33400
INX
H
;INCREMENT POINTER TO NEXT HIGHER ORDER
2040
33420
DCR
C
PARE WE DONE?
2041
33440
JNZ
DNORM2
INO, DO THE NEXT BYTE
2042
33460
MOV
A,B
;SUBTRACT 8 FROM SHIFT COUNT
2043
33480
SUI
10
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 11-2
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
2044
33500
CPI
300
;HAVE WE SHIFTED ALL BYTES TO ZERO?
2045
33520
JNZ
DNORM1
;NO, TRY TO SHIFT 8 MORE
2046
33540
JMP
ZERO
IYES, THE NUMBER IS ZERO
2047
33560
DNORM3: DCR
8
:DECREMENT SHIFT COUNT
2048
33580
LXI
H,DFACLO-1
;GET POINTER TO LO
2049
33600
CALL
DSHFLC
;SHIFT THE FAC LEFT
2050
33620
ORA
A
;SEE IF NUMBER IS NORMALIZED
2051
33640
DNORMS:
JP
DNORM3
1SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
2052
33660
MOV
A,B
;GET THE SHIFT COUNT
2053
33680
ORA
A
ISEE IF NO SHIFTING WAS DONE
2054
33700
JZ
DROUND
;NONE WAS, PROCEED TO ROUND THE NUMBER
2055
33720
LXI
H,FAC
;GET POINTER TO EXPONENT
2056
33740
ADD
M
;UPDATE IT
2057
33760
MOV
M,A
;SAVE UPDATED EXPONENT
2058
33780
JNC
ZERO
UNDERFLOW, THE RESULT IS ZERO
2059
33800
RZ
RESULT IS ALREADY ZERO, WE ARE DONE
2060
33820
FALL INTO DROUND AND ROUND THE RESULT
2061
33840
2062
33860
2063
33880
,ROUND FAC
2064
33900
;ALTERS A,B,H,L
2065
33920
DROUND: LDA
DFACLO-1
;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
2066
33940
DROUND: ORA
A
TENTRY FROM DDIV
2067
33960
CM
OROUNA
;ROUND UP IF NECESSARY
2068
33980
LXI
H,FAC+1
;GET POINTER TO UNPACKED SIGN
2069
34000
MOV
A,M
;GET SIGN
2070
34020
ANI
200
;ISOLATE SIGN BIT
2071
34040
DCX
H
;POINT TO HD
2072
34060
DCX
H
2073
34080
XRA
M
1PACK SIGN AND HO
2074
34100
MOV
M,A
;PUT PACKED SIGN AND HO IN FAC
2075
34120
RET
IWE ARE DONE
2076
34140
2077
34160
2078
34180
SUBROUTINE FOR ROUND: ADD ONE TO FAC
2079
34200
DROUNA: LXI
,OFACLO
;GET POINTER TO LO, ENTRY FROM DINT
2080
34220
MVI
8,7
1SET UP A COUNT
2081
34240
DRONA1: INR
M
;INCREMENT A BYTE
2082
34260
RNZ
RETURN IF THERE WAS NO CARRY
2083
34280
INX
H
;INCREMENT POINTER TO NEXT HIGHER ORDER
2084
34300
DCR
8
HAVE WE INCREMENTED ALL BYTES
2085
34320
JNZ
DRONA1
INO, TRY THE NEXT ONE
2086
34340
INR
M
EYES, INCREMENT THE EXPONENT
2087
34360
JZ
OVERR
;CHECK FOR OVERFLOW
2088
34380
DCX
H
;THE NUMBER OVERFLOWED ITS EXPONENT
2089
34400
MVI
M,200
;PUT 200 IN HO
2090
34420
RET
;ALL DONE
2091
34440
2092
34460
2093
34480
;ADD OR SUBTRACT 2 DBL QUANTITIES
2094
34500
;ALTERS A,C,O,E,H,L
2095
34520
DADOD:
LXI
;ENTRY FROM DDIV
2096
34540
LXI
,ARGLO
ADD OR SUBTRACT FBUFFR+17 AND ARG
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 11-3
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
2097
34560
JMP
DADDS
;DO THE OPERATION
2098
34580
2099
34600
DADDAA: XWD
1000,076
1"MVI A", ENTRY FROM DADD, DMULT
2100
34620
ADC
M
;SETUP ADD INSTRUCTION FOR LOOP
2101
34640
DADDA: LXI
,ARGLO
;GET POINTER TO ARG, ENTRY FROM DADO
2102
34660
DADDFO: LXI
D,OFACLO
;GET POINTER TO FAC, ENTRY FROM FOUT
2103
34680
DADOS: MVI
C,7
;SET UP A COUNT
2104
34700
STA
DADDOP
;STORE THE ADD OR SUBTRACT INSTRUCTION
2105
34720
XRA
A
;CLEAR CARRY
2106
34740
DADDL:
LOAX
D
IGET A BYTE FROM RESULT NUMBER
2107
34760
DADDOP: NOP
;THIS IS EITHER "ADC
M" OR "SBB
M"
2108
34780
STAX
D
;SAVE THE CHANGED BYTE
2109
34800
INX
D
;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
2110
34820
INX
H
2111
34840
DCR
C
BARE WE DONE?
2112
34860
JNZ
DADDL
INO, DO THE NEXT HIGHER ORDER BYTE
2113
34880
RET
;ALL DONE
o
2114
34900
2115
34920
2116
34940
INEGATE SIGNED NUMBER IN FAC
2117
34960
,THIS IS USED BY DADD, DINT
2118
34980
FALTERS A,B,C,H,L
2119
35000
DNEGR:
MOV
A,M
;COMPLEMENT SIGN OF FAC
2120
35020
CMA
;USE THE UNPACKED SIGN BYTE
2121
35040
MOV
M,A
;SAVE THE NEW SIGN
2122
35060
LXI
H,DFACLO-1
;GET POINTER TO LO
2123
35080
MVI
8,10
ISET UP A COUNT
2124
35100
XRA
A
;CLEAR CARRY AND GET A ZERO
2125
35120
MOV
C,A
;SAVE ZERO IN C
2126
35140
ONEGR1: MOV
A,C
;GET A ZERO
2127
35160
S88
M
INEGATE THE BYTE OF FAC
2128
35180
MOV
M,A
;UPDATE FAC
2129
35200
INX
H
;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2130
35220
DCR
8
;ARE WE DONE?
2131
35240
JNZ
ONEGR1
INO, NEGATE THE NEXT BYTE
2132
35260
RET
FALL DONE
2133
35280
2134
35300
2135
35320
;SHIFT DBL FAC RIGHT ONE
2136
35340
IA . SHIFT COUNT
2137
35360
;ALTERS A,C,O,E,H,L
2138
35380
DSHFTR: LXI
H,DFACLO.1
IGET POINTER TO LO
2139
35400
MVI
M,0
PUT ZERO IN EXTRA LO ORDER BYTE
2140
35420
DSHFR1: SUI
10
;SEE IF WE CAN SHIFT 8 RIGHT
2141
35440
JC
DSHFR3
;WE CAN'T, CHECK IF WE ARE DONE
2142
35460
DSHFRM: LXI
H,FAC-1
IENTRY FROM DMULT, GET POINTER TO HO
2143
35480
MVI
E,0
;SHIFT A ZERO INTO THE HO
2144
35500
MVI
0,10
;SET UP A COUNT
2145
35520
DSHFR2: MOV
C,M
;SAVE A BYTE OF FAC
2146
35540
MOV
M,E
;PUT THE LAST BYTE IN ITS PLACE
2147
35560
MOV
E,C
;SET UP E FOR NEXT TIME THROUGH THE LOOP
2148
35580
DCX
H
;POINT TO NEXT LOWER ORDER BYTE
2149
35600
DCR
D
IARE WE DONE?
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 11-4
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
2150
35620
JNZ
DSHFR2
INO, DO THE NEXT BYTE
2151
35640
JMP
DSHFR1
IYES, SEE IF WE CAN SHIFT OVER 8 MORE
2152
35660
DSHFR3: ADI
11
;CORRECT SHIFT COUNT
2153
35680
MOV
D,
;SAVE SHIFT COUNT IN D
2154
35700
DSHFR4: XRA
A
;CLEAR CARRY
2155
35720
DCR
D
;ARE WE DONE?
2156
35740
R2
EYES
2157
35760
DSHFRA: LXI
H,FAC-1
INO, GET POINTER TO LO, ENTRY FROM DADD, DMULT
2158
35780
MVI
E,10
;SET UP A COUNT, ROTATE FAC ONE LEFT
2159
35800
DSHFRS: MOV
A,M
;GET A BYTE OF THE FAC
2160
35820
RAR
;ROTATE IT LEFT
2161
35840
MOV
M,A
1PUT THE UPDATED BYTE BACK
2162
35860
DCX
H
;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
2163
35880
DCR
E
PARE WE DONE?
2164
35900
JNZ
DSHFR5
INO, ROTATE THE NEXT LOWER ORDER BYTE
2165
35920
JMP
DSHFR4
IYES, SEE IF WE ARE DONE SHIFTING
2166
35940
2167
35960
2168
35980
;ROTATE FAC LEFT ONE
2169
36000
;ALTERS A,C,H,L
2170
36020
DSHFLC: MVI
C,10
;SET UP A COUNT
2171
36040
DSHFTL: MOV
A,M
;GET A BYTE OF FAC
2172
36060
RAL
IROTATE IT LEFT ONE
2173
36080
MDV
M,
;UPDATE BYTE IN FAC
2174
36100
INX
H
;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
2175
36120
DCR
C
;ARE WE DONE?
2176
36140
JNZ
DSHFTL
INO, ROTATE THE NEXT BYTE
2177
36160
RET
;ALL DONE
2178
36180
2179
36200
2180
36220
;DOUBLE PRECISION MULTIPLICATION
FAC:=ARG*FAC
2181
36240
;ALTERS ALL REGISTERS
2182
36260
DMULT:
FSIGN
;CHECK IF WE ARE MULTIPLYING BY ZERO
2183
36280
RZ
EYES, ALL DONE, THE FAC IS ZERO
2184
36300
CALL
MULDVA
;ADD EXPONENTS AND TAKE CARE OF SIGNS
2185
36320
CALL
DMULDV
IZERO FAC AND PUT FAC IN FBUFFR
2186
36340
MOV
M,C
;PUT UNPACKED HO IN ARG
2187
36360
LXI
,ARGLO
;GET POINTER TO LO OF ARG
2188
36380
MVI
8,7
;SET UP A COUNT
2189
36400
DMULT2: LDAX
D
;GET THE BYTE OF ARG TO MULTIPLY BY
2190
36420
INX
D
;INCREMENT POINTER TO NEXT HIGHER BYTE
2191
36440
ORA
A
;CHECK IF WE ARE MULTIPLYING BY ZERO
2192
36460
PUSH
D
;SAVE POINTER TO ARG
2193
36480
JZ
DMULT5
,WE ARE
2194
36500
MVI
C,10
;SET UP A COUNT
2195
36520
DMULT3: PUSH
B
;SAVE COUNTERS
2196
36540
RAR
;ROTATE MULTIPLIER RIGHT
2197
36560
MOV
B,A
;SAVE IT
2198
36580
CC
DADDAA
;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
2199
36600
MVI
0,1
;ROTATE PRODUCT RIGHT ONE
2200
36620
CALL
OSHFRA
2201
36640
MOV
A,B
;GET MULTIPLIER IN A
2202
36660
POP
8
IGET COUNTERS BACK
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 17(113) 06:09 27-AUG-75 PAGE 11.5
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
2203
36680
DCR
C
1ARE WE DONE WITH THIS BYTE OF ARG?
2204
36700
JNZ
DMULT3
INO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
2205
2206
36720
DMULT4: POP
D
EYES, GET POINTER INTO ARG BACK
2207
36740
DCR
B
BARE WE DONE?
2208
36760
JNZ
DMULT2
INO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
2209
36780
JMP
NORMAL
;ALL DONE, NORMALIZE AND ROUND RESULT
2210
36800
DMULTS: CALL
DSHFRM
;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
2211
36820
JMP
DMULT4
; MULTIPLYIING BY ZERO
2212
36840
2213
36860
2214
36880
;CONSTANT FOR DIVIO, DDIV10
2215
36900
OTEN:
000
, 1000
2216
36920
000
2217
36940
000
2218
36960
000
2219
36980
FTEN:
000
, 10.0
2220
37000
000
2221
37020
040
2222
37040
204
2223
37060
2224
37080
;DOUBLE PRECISION DIVIDE FAC BY 10
2225
37100
BALTERS ALL REGISTERS
2226
37120
DDIV10: CALL
VMOVAF
;SAVE THE FAC IN ARG
2227
37140
LXI
H,DTEN
IGET POINTER TO A DOUBLE PRECISION 10
2228
37160
CALL
VMOVFM
;MOVE TEN INTO THE FAC
2229
37180
1FALL INTO DDIV AND DIVIDE BY TEN
2230
37200
2231
37220
2232
37240
BOUBLE PRECISION DIVISION
FAC:=ARG/FAC
2233
37260
BALTERS ALL REGISTERS
2234
37280
DDIV:
FSIGN
CHECK FOR DIVISION BY ZERO
2235
37300
JZ
DV0ERR
IDON'T LET HIM DO IT
2236
37320
CALL
MULDVS
;SUBTRACT EXPONENTS AND CHECK SIGNS
2237
37340
INR
M
PADD TWO TO EXPONENT TO CORRECT SCALING
2238
37360
INR
M
2239
37380
CALL
DMULDV
IZERO FAC AND PUT FAC IN FBUFFR
2240
37400
LXI
H,ARG
;GET POINTER TO THE EXTRA HO BYTE WE WILL USE
2241
37420
MOV
M,C
;ZERO IT
2242
37440
MVI
8,0
IZERO FLAG TO SEE WHEN WE START DIVIDING
2243
37460
DDIVI:
XWD
1000,076
,"MVI A", SUBTRACT FBUFFR FROM ARG
2244
37480
SBB
M
,GET SUBTRACT INSTRUCTION
2245
37500
CALL
DADDO
100 THE SUBTRACTION
2246
37520
LDAX
D
;SUBTRACT FROM EXTRA HO BYTE
2247
37540
SBB
C
;HERE C=0
2248
37560
CMC
;CARRY#1 IF SUBTRACTION WAS GOOD
2249
37580
JC
DDIV2
;WAS IT OK?
2250
37600
XWD
1000,076
,"MVI A" NO, ADD FBUFFR BACK IN
2251
37620
ADC
M
;GET ADD INSTRUCTION
2252
37640
CALL
DADDO
100 THE ADDITION
2253
37660
XRA
A
;CLEAR CARRY
2254
37680
XWD
1000,332
,"JC" OVER NEXT TWO BYTES
2255
37700
DDIV2:
STAX
D
;STORE THE NEW HIGHEST ORDER BYTE
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOF MACRO 47(113) 06:09 27-AUG-75 PAGE 11-6
F4
MAC
23-AUG-64 06:08
DOUBLE PRECISION ARITHMETIC ROUTINES
2256
37720
INR
8
;INCREMENT FLAG TO SHOW WE COULD DIVIDE
2257
37740
LDA
FAC-1
;CHECK IF WE ARE DONE DIVIDING
2258
37760
INR
A
ISET SIGN FLAG WITHOUT AFFECTING CARRY
2259
37780
DCR
A
2260
37800
RAR
;PUT CARRY IN MSB FOR DROUND
2261
37820
JM
DROUND
IWE ARE DONE, WE HAVE 57 BITS OF ACCURACY
2262
37840
RAL
IGET OLD CARRY BACK WHERE IT BELONGS
2263
37860
LXI
H,OFACLO
;GET POINTER TO LO OF FAC
2264
37880
MVI
C,7
;SET UP A COUNT, SHIFT FAC LEFT ONE
2265
37900
CALL
DSHFTL
;SHIFT IN THE NEXT BIT IN THE QUOTIENT
2266
37920
LXI
ARGLO
;GET POINTER TO LO IN ARG
2267
37940
CALL
DSHFLC
;SHIFT DIVIDEND ONE LEFT
2268
37960
MOV
A,B
;IS THIS THE FIRST TIME AND WAS THE
2269
37980
ORA
A
, SUBTRACTION NOT GOOD? (B WILL GET
2270
38000
JNZ
DDIVI
; CHANGED ON THE FIRST OR SECOND SUBTRACTION)
2271
38020
LXI
H,FAC
EYES, SUBTRACT ONE FROM EXPONENT TO CORRECT
2272
38040
DCR
M
; SCALING
2273
38060
JNZ
DDIVI
;CONTINUE DIVIDING IF NO OVERFLOW
2274
38080
JMP
OVERR
,WE HAVE OVERFLOW11
2275
38100
2276
38120
2277
38140
;TRANSFER FAC TO FBUFFR FOR DMULT AND DDIV
2278
38160
TALTERS A,B,C,D,E,H,L
2279
38180
DMULDV: MOV
A,C
;PUT UNPACKED HO BACK IN ARG
2280
38200
STA
ARG-1
2281
38220
DCX
H
;POINT TO HO OF FAC
2282
38240
LXI
D,FBUFFR+"023
;POINT TO END OF FBUFFR
2283
38260
MVI
8,7
;SET UP A COUNT
2284
38280
MVI
C,0
,GET A ZERO TO FILL FAC WITH
2285
38300
DMLDV1: MOV
A,M
,GET A BYTE FROM FAC
2286
38320
STAX
D
;PUT IT IN FBUFFR
2287
38340
MOV
M,C
1PUT A ZERO IN FAC
2288
38360
DCX
D
;POINT TO NEXT BYTE IN FBUFFR
2289
38380
DCX
H
POINT TO NEXT LOWER ORDER BYTE IN FAC
2290
38400
DCR
B
BARE WE DONE?
2291
38420
JNZ
DMLDV1
INO, TRANSFER THE NEXT BYTE
2292
38440
RET
;ALL DONE
2293
38460
2294
38480
2295
38500
;DOUBLE PRECISION MULTIPLY THE FAC BY 10
2296
38520
BALTERS ALL REGISTERS
2297
38540
DMUL10: CALL
VMOVAF
;SAVE THE FAC IN ARG
2298
38560
;VMOVAF EXITS WITH (DE)=FAC+1
2299
38580
XCHG
IGET THE POINTER INTO THE FAC IN (HL)
2300
38600
DCX
H
;POINT TO THE EXPONENT
2301
38620
MOV
A,M
IGET THE EXPONENT
2302
38640
ADI
2
;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
2303
38660
JC
OVERR
;CHECK FOR OVERFLOW
2304
38680
MOV
M,A
;SAVE THE NEW EXPONENT
2305
38700
PUSH
H
;SAVE POINTER TO FAC
2306
38720
CALL
DADD
;ADD IN THE ORIGINAL FAC TO GET 5 TIMES FAC
2307
38740
POP
H
1GET THE POINTER TO FAC BACK
2308
38760
INR
M
;ADD ONE TO EXPONENT TO GET 10 TIMES FAC