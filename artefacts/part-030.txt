
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE
9
F4
MAC
23-AUG-64 06:08
GREATEST INTEGER FUNCTION
1524
23820
SUBTTL GREATEST INTEGER FUNCTION
1525
23840
1QUICK GREATEST INTEGER FUNCTION
1526
23860
;LEAVES (FAC) IN C,D,E (SIGNED)
1527
23880
ASSUMES FAC .LT. 2"23 # 8388608
1528
23900
ASSUMES THE EXPONENT OF FAC IS IN A
1529
23920
;ALTERS A,B,C,D,E
1530
001372' 001000
000107
23940
QINT:
MOV
B,A
IZERO B,C,D,E IN CASE THE NUMBER IS ZERO
1531
001373' 001000
000117
23960
MOV
C,A
1532
001374 001000
000127
23980
MOV
D,A
1533
001375' 001000
000137
24000
MOV
E,A
1534
001376 001000
000267
24020
ORA
A
1SET CONDITION CODES
1535
001377 001000 000310
24040
RZ
,IT IS ZERO, WE ARE DONE
1536
1537
24080
THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS. TO HANDLE THIS, IF THE
1538
24100
;NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
1539
24120
;SUBTARCT ONE. THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
1540
24140
IMANTISSA RIGHT. THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE, so, IF WE
1541
24160
;HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
1542
24180
IZERO. so THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E. IF THE
1543
24200
;NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
1544
24220
;RIGHT
OF THE BINARY POINT. so THE NET EFFECT IS THAT WE GET THE ABSOLUTE
1545
24240
;VALUE OF (FAC) IN C,D,E. C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
1546
24260
INEGATIVE so THE RESULT WILL BE SIGNED.
1547
001400 001000
000345
24280
PUSH
H
;SAVE (HL)
1548
001401 001000
000315
24300
CALL
MOVRF
;GET NUMBER IN THE REGISTERS
1549
001402' 000000
001240*
1550
001403 000000
001342'
1551
001404 001000
000315
24320
CALL
UNPACK
JUNPACK THE NUMBER
1552
001405' 000000
001272'
1553 001406 000000
001402
1554 001407 001000
000256
24340
XRA
M
IGET SIGN OF NUMBER
1555 001410* 001000
000147
24360
MOV
H,A
;DON'T LOSE IT
1556 001411 001000
000374
24380
CM
QINTA
;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1557 001412' 000000
001436
1558 001413 000000
001405'
1559 001414 001000
000076
24400
MVI
A,230
ISEE HOW MANY WE HAVE TO SHIFT TO CHANGE
1560 001415' 000000
000230
1561 001416 001000
000220
24420
SUB
B
, NUMBER TO AN INTEGER
1562 001417 001000
000315
24440
CALL
SHIFTR
;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
1563 001420° 000000
000334
1564 001421 000000
001412'
1565 001422' 001000
000174
24460
MOV
A,H
IGET SIGN
1566 001425' 001000
000027
24480
RAL
PUT SIGN IN CARRY so IT WILL NOT BE CHANGED
1567 001424* 001000
000334
24500
CC
ROUNDA
I IF NUMBER WAS NEGATIVE, ADD ONE
1568 001425' 000000
000255'
1569 001426 000000
001420
1570 0014279 001000
000006
24520
MVI
8,0
;FORGET THE BITS WE SHIFTED OUT
1571 001430' 000000
000000
1572 001431 001000
000334
24540
CC
NEGR
;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
1573 001432' 000000
000310
1574 001433' 000000
001425'
1575
24560
, WANT A SIGNED MANTISSA
1576 001434 001000 000341
24580
POP
H
IGET OLD (HL) BACK
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 7(113) 06:09 27-AUG-75 PAGE 9-1
F4
MAC
23-AUG-64 06:08
GREATEST INTEGER FUNCTION
1577 001435 001000 000311
24600
RET
FALL DONE
1578
1579 001436 001000 000033
24640
QINTA:
DCX
D
;SUBTRACT ONE FROM C,D,E
1580 001437 001000 000172
24660
MOV
A,D
,WE HAVE TO SUBTRACT ONE FROM C IF
1581 001440 001000 000243
24680
ANA
E
: D AND E ARE BOTH ALL ONES
1582
001441 001000 000074
24700
INR
A
;SEE IF BOTH WERE -1
1583
001442' 001000 000300
24720
RNZ
;THEY WERE NOT, WE ARE DONE
1584
24740
IFN
LENGTH-2,
1585
001443 001000 000015
24760
DCR
C>
;THEY WERE, SUBTRACT ONE FROM C
1586
24780
IFE
LENGTH-2,<
1587
24800
DCXBRT: DCX
B>
;THIS IS FOR BILL. C WILL NEVER BE ZERO
1588
24820
; (THE MSB WILL ALWAYS BE ONE) so "DCX B"
1589
24840
, AND "DCR
C" ARE FUNCTIONALLY EQUIVALENT
1590
001444* 001000 000311
24860
RET
PALL DONE
1591
1592
1593
24920
;GREATEST INTEGER FUNCTION
1594
24940
;ALTERS A,B,C,O,E,H,L
1595
24960
IFE
LENGTH-2,
1596
24980
INTENC: CPI
4
;SEE WHAT KIND OF NUMBER WE HAVE
1597
25000
RC
;IT IS AN INTEGER, ALL DONE
1598
25020
JNZ
DINT
;CONVERT THE DOUBLE PRECISION NUMBER
1599
25040
CALL
CONIS>
;TRY TO CONVERT THE NUMBER TO AN INTEGER
1600
25060
;IF WE CAN'T, WE WILL RETURN HERE TO GIVE A
1601
25080
; SINGLE PRECISION RESULT
1602
001445 001000
000041
25100
INT:
LXI
H,FAC
;GET EXPONENT
1603
001446 000000
001156*
1604 001447 000000 001432'
1605 001450 001000 000176
25120
MOV
A,M
1606 001451 001000 000376
25140
CPI
230
ISEE IF NUMBER HAS ANY FRACTIONAL BITS
1607 001452' 000000 000230
1608
25160
IFN
EXTENC,<
;THE ONLY GUY WHO NEEDS THIS DOESN'T CARE
1609 001453' 001000 000072
25180
LDA
FACLO>
, ABOUT THE SIGN
1610 001454 000000 001255*
1611 001455' 000000 001446
1612 001456 001000 000320
25200
RNC
;IT DOES NOT
1613
25220
IFN
EXTENC,
1614 001457 001000 000176
25240
MOV
A,M>
;GET EXPONENT BACK
1615 001460 001000 000315
25260
CALL
QINT
IIT DOES, SHIFT THEM OUT
1616 001461 000000 001372'
1617 001462 000000 001454
1618 001463 001000 000066
25280
MVI
M,230
;CHANGE EXPONENT SO IT WILL BE CORRECT
1619 001464° 000000 000230
1620
25300
; AFTER NORMALIZATION
1621
25320
IFN
EXTENC,
1622 001465' 001000 000173
25340
MOV
A,E
;GET LO
1623 001466 001000 000365
25360
PUSH
PSW>
;SAVE IT
1624 001467 001000 000171
25380
MOV
A,C
;NEGATE NUMBER IF IT IS NEGATIVE
1625 001470 001000 000027
25400
RAL
;PUT SIGN IN CARRY
1626
25420
IFE
EXTENC,<
1627
25440
JMP
FADFLT>
REFLOAT NUMBER
1628
25460
IFN
EXTENC,<
1629
001471 001000 000315
25480
CALL
FADFLT
;REFLOAT NUMBER
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 9-2
F4
MAC
23-AUG-64 06:08
GREATEST INTEGER FUNCTION
1630 001472' 000000 060143
1631 001473 000000 001461
1632
001474 001000 000361
25500
POPPRT: POP
PSW
;GET LO BACK
1633
001475' 001000 000311
25520
RET>
TALL DONE
1634
1635
1636
25580
IFE
LENGTH=2,
1637
25600
;GREATEST INTEGER FUNCTION FOR DOUBLE PRECISION NUMBERS
1638
25620
BALTERS A,8,C,D,E,H,L
1639
25640
DINT:
LXI
H,FAC
;GET POINTER TO FAC
1640
25660
MOV
A,M
;GET EXPONENT
1641
25680
CPI
220
ICAN WE CONVERT IT TO AN INTEGER?
1642
25700
JC
FROINT
, THEN DO so
1643
25720
JNZ
DINT2
;CHECK FOR -32768
1644
25740
MOV
C,A
;SAVE EXPONENT IN C
1645
25760
DCX
H
;GET POINTER TO SIGN AND HO
1646
25780
MOV
A,M
;GET SIGN AND HO
1647
25800
XRI
200
;CHECK IF IT IS 200
1648
25820
MVI
8,6
ISET UP A COUNT TO CHECK IF THE REST OF
1649
25840
DINTI:
DCX
H
, THE NUMBER IS ZERO, POINT TO NEXT BYTE
1650
25860
ORA
M
;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
1651
25880
OCR
8
IARE WE DONE?
1652
25900
JNZ
DINTI
INO, CHECK THE NEXT LOWER ORDER BYTE
1653
25920
ORA
A
;IS A NOW ZERO?
1654
25940
LXI
H,200*400+SCODE
;GET -32768 JUST IN CASE
1655
25960
JZ
CONISS
iA IS ZERO so WE HAVE 32768
1656
25980
MOV
A,C
;GET EXPONENT
1657
26000
DINT2:
CPI
270
;ARE THERE ANY FRACTIONAL BITS?
1658
26020
RNC
INO, THE NUMBER IS ALREADY AN INTEGER
1659
26040
DINTFO:
PUSH
PSW
,ENTRY FROM FOUT, CARRY IS ZERO IF WE COME
1660
26060
, HERE FROM FOUT
1661
26080
CALL
MOVRF
;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
1662
26100
CALL
UNPACK
JUNPACK IT
1663
26120
XRA
M
;GET ITS SIGN BACK
1664
26140
DCX
H
1SET THE EXPONENT TO NORMALIZE CORRECTLY
1665
26160
MVI
M,270
1666
26180
PUSH
PSW
ISAVE THE SIGN
1667
26200
CM
DINTA
;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1668
26220
MVI
A,270
IGET HOW MANY BITS WE HAVE TO SHIFT OUT
1669
26240
SUB
8
1670
26260
CALL
DSHFTR
ISHIFT THEM OUT!!
1671
26280
POP
PSW
IGET THE SIGN BACK
1672
26300
CM
DROUNA
I IF NUMBER WAS NEGATIVE, ADD ONE
1673
26320
XRA
A
IPUT A ZERO IN THE EXTRA LO BYTE so WHEN
1674
26340
STA
OFACLO-1
, WE NORMALIZE, WE WILL SHIFT IN ZEROS
1675
26360
POP
PSW
;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE,
1676
26380
RNC
; JUST RETURN
1677
26400
JMP
ONORML
IRE-FLOAT THE INTEGER
1678
26420
1679
26440
DINTA: LXI
H,DFACLO
SUBTRACT ONE FROM FAC, GET POINTER TO LO
1680
26460
DINTAI: MOV
A,M
IGET A BYTE OF FAC
1681
26480
DCR
M
SUBTRACT ONE FROM IT
1682
26500
ORA
A
;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 9-3
F4
MAC
23-AUG-64 06:08
GREATEST INTEGER FUNCTION
1683
26520
INX
H
;INCREMENT POINTER TO NEXT BYTE
1684
26540
JZ
DINTAI
;CONTINUE IF NECESSARY
1685
26560
RET>
;ALL DONE
1686
26580
PAGE
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 10
F4
MAC
23-AUG-64 06:08
INTEGER ARITHMETIC ROUTINES
1687
26600
SUBTTL
INTEGER ARITHMETIC ROUTINES
1688
26620
IFN
MULDIM&<LENGTH-2>,
1689
26640
;TWO BYTE UNSIGNED INTEGER MULTIPLY
1690
26660
, (HL):=(BC)*(D)
1691
26680
TA, O,E,H,L ARE CHANGED
1692 001476 001000 000041
26700
DMULT: LXI
H,SCODE
IZERO PRODUCT REGISTERS
1693 001477* 000000 001153*
1694 001500 000000 001472'
1695 001501 001000
000170
26720
MOV
A,8
;CHECK IF (BC) IS ZERO
1696 001502' 001000 000261
26740
ORA
C
;IF so, JUST RETURN, (HL) IS ALREADY ZERO
1697 001503 001000
000310
26760
RZ
;THIS IS DONE FOR SPEED
1698 001504 001000
000076
26780
MVI
A,20
1SET UP A COUNT
1699 001505* 000000
000020
1700 001506 001000
000051
26800
DMULT1: DAD
H
;ROTATE (HL) LEFT ONE
1701 001507 001000
000332
26820
JC
BSERR##
;CHECK FOR OVERFLOW, IF so,
1702 001510 000000
000000*
1703 001511* 000000
001477
1704 001512 001000
000353
26840
XCHG
: BAD SUBSCRIPT (BS) ERROR
1705 001513 001000
000051
26860
DAD
H
BROTATE (DE) LEFT ONE
1706 001514 001000
000353
26880
XCHG
1707 001515* 001000
000322
26900
JNC
DMULT2
JADD IN (BC) IF HO WAS 1
1708 001516* 000000
001524
1709 001517 000000
001510
1710 001520 001000
000011
26920
DAD
8
1711 001521 001000
000332
26940
JC
BSERR
CHECK FOR OVERFLOW
1712 001522' 000000
001510*
1713 001523* 000000
001516
1714 001524 001000
000075
26960
DMULT2: DCR
A
;SEE IF DONE
1715
001525' 001000
000302
26980
JNZ
OMULT1
1716 001526 000000
001506
1717 001527 000000 001522'
1718
001530
001000
000311
27000
RET>
TALL DONE
1719
1720
1721
27060
IFE
LENGTH-2,<
1722
27080
COMMENT %
1723
27100
INTEGER ARITHMETIC CONVENTIONS
1724
27120
1725
27140
INTEGER VARIABLES ARE 2 BYTE, SIGNED NUMBERS
1726
27160
THE LO BYTE COMES FIRST IN MEMORY
1727
27180
1728
27200
CALLING CONVENTIONS:
1729
27220
FOR ONE ARGUMENT FUNCTIONS:
1730
27240
THE ARGUMENT IS IN (HL), THE RESULT IS LEFT IN (HL)
1731
27260
FOR TWO ARGUMENT OPERATIONS:
1732
27280
THE FIRST ARGUMENT IS IN (DE)
1733
27300
THE SECOND ARGUMENT IS IN (HL)
1734
27320
THE RESULT IS LEFT IN (HL)
1735
27340
IF OVERFLOW OCCURS, THE ARGUMENTS ARE CONVERTED TO SINGLE PRECISION
1736
27360
WHEN INTEGERS ARE STORED IN THE FAC, THEY ARE STORED AT FACL0+0,1
1737
27380
VALTYP (INTEGER)=2
1738
27400
%
1739
27420
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 10-1
F4
MAC
23-AUG-64 06:08
INTEGER ARITHMETIC ROUTINES
1740
27440
1741
27460
INTEGER SUBTRTACTION
(HL):=(DE)=(HL)
1742
27480
;ALTERS A,B,C,O,E,H,L
1743
27500
ISUB:
MOV
A,H
TEXTEND THE SIGN OF (HL) TO B
1744
27520
RAL
IGET SIGN IN CARRY
1745
27540
SBB
A
1746
27560
MOV
B,A
1747
27580
CALL
INEGHL
INEGATE (HL)
1748
27600
MOV
A,C
;GET A ZERO
1749
27620
SBB
B
INEGATE SIGN
1750
27640
JMP
IADDS
IGO ADD THE NUMBERS
1751
27660
1752
27680
1753
27700
INTEGER ADDITION
(HL):=(DE)+(HL)
1754
27720
;ALTERS A,B,C,D,E,M,L
1755
27740
IADD:
MOV
A,H
;EXTEND THE SIGN OF (HL) TO B
1756
27760
RAL
;GET SIGN IN CARRY
1757
27780
388
A
1758
27800
IADDS:
MOV
B,A
SAVE THE SIGN
1759
27820
PUSH
H
;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
1760
27840
MOV
A,D
:EXTEND THE SIGN OF (DE) TO A
1761
27860
RAL
IGET SIGN IN CARRY
1762
27880
SBB
A
1763
27900
DAD
0
;ADD THE TWO LO'S
1764
27920
ADC
8
PADD THE EXTRA HO
1765
27940
RRC
IIF THE LSB OF A IS DIFFERENT FROM THE MSB OF
1766
27960
XRA
H
i H, THEN OVERFLOW OCCURED
1767
27980
JP
POPPRT
NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
1768
28000
i ARE DONE
1769
28020
PUSH
B
1 OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
1770
28040
XCHG
;GET (DE) IN (HL)
1771
28060
CALL
CONSIH
IFLOAT IT
1772
28080
POP
PSW
;GET SIGN OF (HL) IN A
1773
28100
POP
H
;GET OLD (HL) BACK
1774
28120
CALL
PUSHF
;PUT FIRST ARGUMENT ON STACK
1775
28140
XCHG
;PUT SECOND ARGUMENT IN (DE) FOR FLOATR
1776
28160
CALL
INEGAD
;FLOAT IT
1777
28180
POPR
;GET FIRST ARGUMENT OFF STACK
1778
28200
JMP
FADD
;ADD THE TWO NUMBERS USING SINGLE PRECISION
1779
28220
1780
28240
1781
28260
,INTEGER MULTIPLICATION
(HL) #: (DE)*(HL)
1782
28280
;ALTERS A, ,B,C,O,E,H,L
1783
28300
IMULT:
PUSH
H
;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
1784
28320
PUSH
D
;SAVE FIRST ARGUMENT
1785
28340
CALL
IMULOV
;FIX UP THE SIGNS
1786
28360
PUSH
B
;SAVE THE SIGN OF THE RESULT
1787
28380
MOV
B,H
;COPY SECOND ARGUMENT INTO (BC)
1788
28400
MOV
C,L
1789
28420
LXI
H,SCODE
IZERO (HL), THAT IS WHERE THE PRODUCT GOES
1790
28440
MVI
A,20
1SET UP A COUNT
1791
28460
IMULT1: DAD
H
ROTATE PRODUCT LEFT ONE
1792
28480
JC
IMULTS
;CHECK FOR OVERLFOW
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 10-2
F4
MAC
23-AUG-64 06:08
INTEGER ARITHMETIC ROUTINES
1793
28500
XCHG
;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
1794
28520
DAD
H
, WE ADD IN (BC) OR NOT
1795
28540
XCHG
1796
28560
JNC
IMULT2
1DON'T ADD IN ANYTHING
1797
28580
DAD
8
;ADD IN (BC)
1798
28600
JC
IMULTS
;CHECK FOR OVERLFOW
1799
28620
IMULT2: DCR
A
;ARE WE DONE?
1800
28640
JNZ
IMULT1
INO, DO IT AGAIN
1801
28660
POP
B
TWE ARE DONE, GET SIGN OF RESULT
1802
28680
POP
D
IGET ORIGINAL FIRST ARGUMENT
1803
28700
IMLOIV: MOV
A,H
SENTRY FROM IDIV, IS RESULT ,GE, 32768?
1804
28720
ORA
A
1805
28740
JM
IMULT3
;IT IS, CHECK FOR SPECIAL CASE OF -32768
1806
28760
POP
D
;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
1807
28780
MOV
A,B
;GET THE SIGN OF RESULT IN A
1808
28800
JMP
INEGA
INEGATE THE RESULT IF NECESSARY
1809
28820
IMULT3: XRI
200
IIS RESULT 327687
1810
28840
ORA
;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
1811
28860
JZ
IMULT4
; MUST BE 32768, IT CANNOT BE GREATER
1812
28880
XCHG
IIT IS ,GT. 32768, WE HAVE OVERFLOW
1813
28900
XWD
1000,001
1"LXI BH OVER NEXT 2 BYTES
1814
28920
IMULTS: POP
B
IGET SIGN OF RESULT OFF STACK
1815
28940
POP
H
;GET THE ORIGINAL FIRST ARGUMENT
1816
28960
CALL
CONSIH
IFLOAT IT
1817
28980
POP
H
1GET THE ORIGINAL SECOND ARGUMENT
1818
29000
CALL
PUSHF
;SAVE FLOATED FIRST ARUMENT
1819
29020
CALL
CONSIH
;FLOAT SECOND ARGUMENT
1820
29040
FMULTT: POPR
;GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
1821
1822
29060
JMP
FMULT
MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
1823
29080
IMULT4: MOV
A,B
IIS RESULT +32768 OR -327687
1824
29100
ORA
A
;GET ITS SIGN
1825
29120
POP
8
IDISCARD ORIGINAL SECOND ARGUMENT
1826
29140
RM
;THE RESULT SHOULD BE NEGATIVE, IT IS OK
1827
29160
PUSH
D
;IT IS POSITIVE, SAVE REMAINDER FOR MOD
1828
29180
CALL
CONSIH
;FLOAT -32768
1829
29200
POP
D
;GET MOD'S REMAINDER BACK
1830
29220
JMP
NEG
;NEGATE -32768 TO GET 32768, WE ARE DONE
1831
29240
1832
29260
1833
29280
:INTEGER DIVISION
(HL):=(DE)/(HL)
1834
29300
IREMAINDER IS IN (DE), QUOTIENT IN (HL)
1835
29320
;ALTERS A,B,C,O,E,H,L
1836
29340
IDIV:
MOV
A,H
;CHECK FOR DIVISION BY ZERO
1837
29360
ORA
L
1838
29380
JZ
DVDERR
;WE HAVE DIVISION BY ZERO11
1839
29400
CALL
IMULDV
IFIX UP THE SIGNS
1840
29420
PUSH
8
ISAVE THE SIGN OF THE RESULT
1841
29440
XCHG
;GET DENOMINATOR IN (HL)
1842
29460
CALL
INEGHL
;NEGATE IT
1843
29480
MOV
B,H
ISAVE NEGATED DENOMINATOR IN (BC)
1844
29500
MOV
C,L
1845
29520
LXI
H,SCODE
IZERO WHERE WE DO THE SUBTRACTION
MATHPK FOR BASIC MCS 8080 GATES/ALLEN/DAVIDOFF MACRO 47(113) 06:09 27-AUG-75 PAGE 10-3
F4
MAC
23-AUG-64 06:08
INTEGER ARITHMETIC ROUTINES
1846
29540
MVI
A,21
;SET UP A COUNT
1847
29560
PUSH
PSW
;SAVE IT
1848
29580
ORA
A
;CLEAR CARRY
1849
29600
JMP
IDIV3
;GO DIVIDE
1850
29620
IDIVI:
PUSH
PSW
;SAVE COUNT
1851
29640
PUSH
H
;SAVE (HL) I.E. CURRENT NUMERATOR
1852
29660
DAD
8
;SUBTRACT DENOMINATOR
1853
29680
JNC
IDIV2
;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
1854
29700
POP
PSW
;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
1855
29720
STC
;NEXT BIT IN QUOTIENT IS A ONE
1856
29740
XWD
1000,076
,"MVI A" OVER NEXT BYTE
1857
29760
IDIV2:
POP
H
;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
1858
29780
IDIV3:
MOV
A,E
;SHIFT IN THE NEXT QUOTIENT BIT
1859
29800
RAL
1860
29820
MOV
E,A
1861
29840
MOV
A,D
1SHIFT THE HO
1862
29860
RAL
1863
29880
MOV
D,A
1864
29900
MOV
A,L
;SHIFT IN THE NEXT BIT OF THE NUMERATOR
1865
29920
RAL
1866
29940
MOV
L.A
1867
29960
MOV
A,H
100 THE HO
1868
29980
RAL
1869
30000
MOV
H,A
;SAVE THE HD
1870
30020
POP
PSW
;GET COUNT BACK
1871
30040
DCR
A
1ARE WE DONE?
1872
30060
JNZ
IDIVI
;NO, DIVIDE AGAIN
1873
30080
XCHG
;GET QUOTIENT IN (HL), REMAINDER IN (DE)
1874
30100
POP
B
IGET SIGN OF RESULT
1875
30120
PUSH
D
;SAVE REMAINDER so STACK WILL BE ALRIGHT
1876
30140
JMP
IMLDIV
CHECK FOR SPECIAL CASE OF 32768
1877
30160
1878
30180
1879
30200
IGET READY TO MULTIPLY OR DIVIDE
1880
30220
;ALTERS A,B,C,O,E,H,L
1881
30240
IMULOV: MOV
A,H
;GET SIGN OF RESULT
1882
30260
XRA
D
1883
30280
MOV
B,A
ISAVE IT IN 8
1884
30300
CALL
INEGH
INEGATE SECOND ARGUMENT IF NECESARY
1885
30320
XCHG
;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
1886
30340
, ARGUMENT IF NECESSARY
1887
30360
1888
30380
1889
30400
INEGATE H,L
1890
30420
;ALTERS A,C,H,L
1891
30440
INEGH:
MOV
A,H
;GET SIGN OF (HL)
1892
30460
INEGA:
ORA
A
;SET CONDITION CODES
1893
30480
RP
,WE DON'T HAVE TO NEGATE, IT IS POSITIVE
1894
30500
INEGHL:
XRA
;CLEAR A
1895
30520
MOV
C,A
;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
1896
30540
SUB
INEGATE LO
1897
30560
MOV
L.A
;SAVE IT
1898
30580
MOV
A,C
;GET A ZERO BACK