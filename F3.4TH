   1 SEARCH   MCS808                            ;THE UNIVERSAL FILE
   2 SUBTTL   COMMON FILE
   3 SALL     
   4          LENGTH==2                         ;0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
   5          REALIO==1
   6          CASSW==0                          ;CASSETTE SWITCH (CSAVE,CLOAD)
   7          PURE==0                           ;ON FOR PURE CODE
   8          LPTSW==0 
   9          OSKFUN==0                         ;ON TO READ/WRITE
  10          CONSSW==0
  11 
  12          CLMWID==^D14                      ;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
  13          RAMBOT=^O20000                    ;BOTTOM LOCATION OF RAM FOR PURE SWITCH
  14          CONTRW==1                         ;ALLOW ^O
  15 IFE      REALIO,< 
  16          LPTSW==0                          ;SIMULATOR DEFAULTS
  17          CASSW==0 
  18          CONSSW==0
  19          DSKFUN==0
  20          CONTRW==0>
  21 
  22 IFE      LENGTH,< 
  23          EXTFNC==0                         ;ON MEANS EXTENDED FUNCTIONS
  24          MULDIM==0                         ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
  25          STRING==0                         ;ON MEANS STRINGS ALLOWED
  26          CASSW==0 
  27          LPTSW==0 
  28          DSFFUN==0
  29          CONSSW==0
  30          CONTRW==0>
  31 
  32 IFE      LENGTH-1,<
  33          EXTFNC==1
  34          MULDIM==1
  35          STRING==1>
  36 
  37 IFE      LENGTH-2,<
  38          EXTFNC==1
  39          MULDIM==1
  40          STRING==1>
  41 
  42 DEFINE   SYNCHK(A),<RST 1        
  43          A>       
  44 DEFINE   CHRGET,<RST 2>       
  45 DEFINE   OUTCHR,<RST 3>       
  46 DEFINE   COMPAR,<RST 4>       
  47 DEFINE   FSIGN,<RST 5>       
  48 DEFINE   PUSHM,<RST 6>       
  49 DEFINE   PUSHEM,<PUSHM
  50          PUSHM>   
  51 DEFINE   ACRLF,<  
  52          ^D13     
  53 IFN      STRING,<^D10>>
  54 DEFINE   PUSHR,<  
  55          PUSH     D        
  56          PUSH     B>       
  57 DEFINE   POPR,<   
  58          POP      B        
  59          POP      D>       
  60 DEFINE   MOVRI    (B,C,D,E),<
  61          XWD      ^O1000,^O001             ;;"LXI B"
  62          EXP      C        
  63          EXP      B        
  64          XWD      ^O1000,^O021             ;;"LXI D"
  65          EXP      E        
  66          EXP      D>       
  67 
  68          IF1,<    
  69 IFE      LENGTH,<PRINTX /SMALL/>
  70 IFE      LENGTH-1,<PRINTX /MEDIUM/>
  71 IFE      LENGTH-2,<PRINTX /BIG/>
  72 IFE      REALIO,<PRINTX /SIMULATE/>
  73 IFN      REALIO,<PRINTX /ON MACHINE/>
  74 IFN      CASSW,<PRINTX /CASSETTE/>
  75 IFN      PURE,<PRINTX /PURE/>
  76 IFN      LPTSW,<PRINTX /LPT/>
  77 IFN      DSKFUN,<PRINTX /DISK/>
  78 IFN      CONSSW,<PRINTX /CONSOLE/>>
  79 PAGE     
  80 SUBTTL   VERSION 3.0 -- MORE FEATURES TO GO
  81 TITLE    BASIC MCS 8080 GATES/ALLEN/DAVIDOFF
  82 IFNDEF   LENGTH,<PRINTX !!! MUST HAVE COM !!!
  83          END>     
  84          MCSSIM(START)
  85 COMMENT *
  86
  87 --------- ---- -- ---- ----- --- ---- -----
  88 COPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN
  89 --------- ---- -- ---- ----- --- ---- -----
  90
  91
  92 ORIGINALLY WRITTEN ON THE POP-10 FROM
  93 FEBRUARY 9 TO APRIL 9
  94
  95 BILL GATES WROTE THE RUNTIME STUFF.
  96 PAUL ALLEN WROTE THE NON-RUNTIME STUFF.
  97 MONTE DAVIDOFF WROTE THE MATH PACKAGE.
  98
  99 THINGS TO DO:
 100     GOSUB / INPUT BUG (BUF SMASH)
 101     PRINT PUNCTUATION MANDATORY
 102     MULTIPLE LET
 103     RESTART AT 0 SHOULD GO THROUGH STKINI
 104     USER DEFINED FUNCTIONS(MULTI-ARG,MULTI-LINE,STRINGS)
 105     MAKE STACK BOUNDARY STUFF EXACT
 106     PUNCH,RENUMBER,,,
 107     INLINE CONSTANT CONVERSION -- MAKE IT WORK
 108          *        
 109 RADIX    10                                ;THROUGHOUT THE NON-MATH PACKAGE ROUTINES
 110          .P==0                             ;FOR SIMULATOR FIXUPS
 111          NUMLEV==17+LENGTH*2               ;NUMBER OF STACK LEVELS RESERVED
 112                                            ;WITH AN EXPLICIT CALL TO GETSTK
 113          LPTLEN==72                        ;WIDTH OF LINE-PRINTER
 114          LINLEN==72                        ;TELETYPE LINE LENGTH
 115          BUFLEN==72                        ;INPUT BUFFER SIZE
 116          STRSIZ==4
 117 IFE      LENGTH-2,<STRSIZ==3>
 118          NUMTMP==3                         ;NUMBER OF STRING TEMPORARIES
 119 IFE      LENGTH-2,<NUMTMP=5>
 120          CR==13   
 121          CONTW=15                          ;CHARACTER TO SUPRESS OUTPUT
 122          ODONE==128                        ;BIT FOR OUTPUT DONE
 123          IDONE==1                          ;BIT FOR INPUT DONE
 124          TTOCHN==1                         ;TELETYPE OUTPUT CHANNEL
 125          TTICHN==1                         ;TELETYPE INPUT CHANNEL
 126          LISTEN==0                         ;ON MEANS LISTEN FOR C
 127          FUNCTS==1                         ;ON MEANS USER FUNCTIONS ALLOWED
 128                                            ;! CANNOT BE ON WITH LENGTH=0 (SUBFLG)
 129 IFN      REALIO,< 
 130          LISTEN==1>
 131 IFE      LENGTH,< 
 132          FUNCTS==0>
 133 
 134 
 135 INTERNAL .C1,BUF,READY,REASON,SNERR,OMERR,REPINI
 136 INTERNAL STREND,CURLIN,DV0ERR,ERROV
 137 IFN      REALIO,< 
 138 INTERNAL CNLCA1,CNLCA2,CNLCA3>
 139 IFN      EXTFNC,<INTERNAL ATNFIX,COSFIX,SINFIX,TANFIX
 140 EXTERNAL FPWR,EXP>
 141 EXTERNAL QINT,ZERO,MOVE,FOUT,FIN,FCOMP,FADD,PUSHF,INT,INIT
 142 EXTERNAL MOVFR,MOVRF,MOVRM,INPRT,LINPRT
 143 EXTERNAL MOVFM,MOVMF,TSTACK,FLOATRI,FADDS
 144 INTERNAL ILLFUN,FAC,FACLO,TXTTAB,STROUT,SCRTCH
 145 EXTERNAL INRART,NEG,FLOAT
 146 INTERNAL OUTDO,STROUI
 147 INTERNAL STKTOP,ERROR,FCERR
 148 IFN      STRING,< 
 149 INTERNAL VALTYP,TEMPPT
 150 INTERNAL TEMPST,STRLIT
 151 IFN      LENGTH-2,<
 152 INTERNAL TMERR>   
 153 INTERNAL MEMSIZ,FRETOP
 154 EXTERNAL SIGNS>   
 155 INTERNAL FBUFFR,MINUTK,PLUSTK,CRDO,LINGET,INTXT,QINLIN
 156 IFN      MULDIM,<INTERNAL BSERR>   
 157 IFN      MULDIM,<EXTERNAL UMULT>   
 158 IFE      LENGTH,<INTERNAL RNDFIX,SQRFIX,SINFIX>
 159 INTERNAL SIGN     
 160 EXTERNAL SIGNC,POPHRT
 161 IFN      CONTRW,< 
 162 INTERNAL CNTWFL>  
 163 IFN      LPTSW,<  
 164 INTERNAL LPTPOS,PRTFLG>
 165 IFE      LENGTH-2,<
 166 EXTERNAL CONSIH,VMOVFA,VMOVAF,ISIGN,FPWRQ,CONIA,GETBCD,VSIGN
 167 EXTERNAL VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,PUFOUT,OCXBRT,IADD
 168 EXTERNAL ISUB,IMULT,IDIV,ICOMP,INEG,DADD,DSUB,DMULT,ODIV,OCOMP,VINT
 169 EXTERNAL TMERR,VMOVE,VALINT,VALSNG,FRCSTR,CHKSTR,MAKINT
 170 INTERNAL DFACLO,ARG,ARGLO,VALTYP,ERRTM,TEMP2,TEMP3,GETYPE>
 171 PAGE     
 172 SUBTTL   SOME EXPLANATION
 173 
 174 COMMENT *
 175
 176 ALTAIR BASIC CONFIGURES MEMORY AS FOLLOWS
 177
 178 LOW LOCATIONS
 179
 180     RST SUBROUTINES
 181
 182     0   STARTUP
 183         INITIALLY A JMP TO THE INITIALIZATION CODE
 184         BUT CHANGED TO A JMP TO READY.
 185         RESTARTING THE MACHINE AT 0 DURING PROGRAM
 186         EXECUTION CAN LEAVE THINGS MESSED UP.
 187
 188     1   SYNCHK
 189         A CHECK IS MADE TO MAKE SURE THE
 190         CHARACTER POINTER POINTS AT A SPECIFIC
 191         CHARACTER. IF NOT THE "SYNTAX ERROR"
 192         ROUTINE IS CALLED. IF SO,
 193         THE CHRGET RST IS DROPPED INTO SO
 194         THE CHARACTER AFTER THE MATCHED
 195         ONE WILL BE PUT IN [A] AND
 196         THE CONDITION CODES WILL REFLECT THIS
 197         EXAMPLE: SYNCHK THENTK (THE MATCH CHARACTER IS
 198         GIVEN IN THE LOCATION AFTER THE RST)
 199         WOULD CHECK TO MAKE SURE [H,L] POINTED TO A THENTK
 200         AND IF SO FETCH THE NEXT CHARACTER INTO [A],
 201         IF NOT, A "SYNTAX ERROR" WOULD BE GIVEN.
 202
 203     2   CHRGET
 204         USING [H,L] AS THE TEXT POINTER
 205         THE TEXT POINTER IS INCREMENTED
 206         AND THE NEXT CHARACTER IS FETCHED INTO [A]
 207         IF THE CHARACTER IS IT IS SKIPPED
 208         OVER AND THE NEXT CHARACTER IS FETCHED.
 209         THE STATEMENT TERMINATORS ":" AND 0
 210         LEAVE THE ZERO FLAG SET.
 211         THE NUMERICS "0" THROUGH "9" LEAVE THE CARRY
 212         FLAG SET. THE CURRENT CHARACTER CAN BE
 213         REFETCHED INTO [A] BY DOING A MOV A,M.
 214         IF THE CONDITION CODES MUST BE SET UP AGAIN
 215         DCX H,CHRGET WILL WORK. IT IS VERY DIFFICULT
 216         TO REEXAMINE THE CHARACTER BEFORE THE CURRENT
 217         ONE SINCE SPACES MAY BE IN-BETWEEN.
 218         DCX H,DCX H,CHRGET WILL NOT ALWAYS WORK.
 219
 220     3   OUTCHR
 221         THE CHARACTER IN [A] IS PRINTED ON
 222         THE USER'S TERMINAL. [A] AND THE
 223         CONDITION CODES ARE PRESERVED.
 224
 225     4   COMPAR
 226         [D,E] AND [H,L] ARE COMPARED AS UNSIGNED
 227         DOUBLE-BYTE INTEGERS. CARRY IS SET IF
 228         [H,L] IS LESS THAN [D,E]. ZERO IS SET IF THEY
 229         ARE EQUAL. [A] IS SMASHED. THE ONLY DEFINITE
 230         THING THAT CAN BE SAID ABOUT [A] ON RETURN
 231         IS THAT IF THE ZERO FLAG IS SET, [A] WILL
 232         EQUAL 0.
 233
 234     5   FSIGN
 235         THE FAC (FLOATING ACCUMULATOR)
 236         WHICH IS USED TO STORE NUMERIC RESULTS
 237         IS CHECKED TO SEE WHAT SIGN ITS
 238         VALUE HAS.
 239
 240     6   PUSHM
 241         A DOUBLE BYTE QUANTITY POINTED
 242         TO BY [H,L] IS PUSHED ONTO THE
 243         STACK. [B,C] IS SET EQUAL TO THE
 244         VALUE PUSHED. [H,L] IS INCREMENTED BY TWO.
 245
 246     7   IN THE 4K VERSION RST 7 IS UNUSED AND THE LOCATIONS
 247         ASSOCIATED WITH IT ARE USED TO CONTINUE
 248         THE CODE FOR RS1 6. IN THE 8K A JMP IS MADE
 249         AROUND THE FIRST THREE RST 7 LOCATIONS
 250         DURING RST 6 EXECUTION. RST 7 INITIALLY
 251         CONTAINS A RET, BUT THE USER CAN CHANGE IT TO
 252         A JMP TO AN INTERRUPT SERVICE ROUTINE.
 253
 254     FUNCTION DISPATCH ADDRESSES
 255         FUNDSP CONTAINS THE ADDRESSES OF THE
 256         FUNCTION ROUTINES IN THE ORDER OF THE
 257         FUNCTION NAMES IN THE CRUNCH LIST.
 258         THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
 259         ARE AT THE END. SEE THE EXPLANATION AT ISFUN.
 260
 261     THE OPERATOR TABLE
 262         THE OPTAB TABLE CONTAINS AN OPERATORS PRECEDENCE
 263         FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
 264         THE OPERATION. THE INDEX INTO THE
 265         OPERATOR TABLE IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
 266         OF THE LOWEST NUMBERED OPERATOR. THE ORDER
 267         OF OPERATORS IN THE CRUNCH LIST AND IN OPTAB IS IDENTICAL.
 268         THE PRECEDENCES ARE ARBITRARY,EXCEP1 FOR THEIR
 269         COMPARATIVE SIZES. NOTE THAT THE PRECEDENCE FOR
 270         UNARY OPERATORS SUCH AS NOT AND NEGATION ARE
 271         SETUP SPECIALLY WITHOUT USING A TABLE.
 272
 273     THE RESERVED WORD OR CRUNCH LIST
 274         WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
 275         IT IS STORED IN BUF. AS SOON AS THE WHOLE LINE
 276         HAS BEEN TYPED IN (INLIN RETURNS) CRUNCH IS
 277         CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
 278         CRUNCH VALUES. THIS REDUCES THE SIZE OF THE
 279         PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
 280         TABLE DISPATCHES TO PERFORM FUNCTIONS, STATEMENTS,
 281         AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
 282         NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
 283         WHEN A MATCH IS FOUND BETWEEN A STRING
 284         OF CHARACTERS AND A WORD IN THE CRUNCH LIST
 285         THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
 286         THE INPUT LINE AND A RESERVED WORD TOKEN IS PUT
 287         IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
 288         TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
 289         IN THE CRUNCH LIST.
 290
 291     STATEMENT DISPATCH ADDRESSES
 292         WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
 293         CHARACTER OF THE STATEMENT IS EXAMINED
 294         TO SEE IF IT IS LESS THAN THE RESERVED
 295         WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
 296         IF SO, THE "LET" CODE IS CALLED TO
 297         TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
 298         OTHERWISE A CHECK IS MADE TO MAKE SURE THE
 299         RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
 300         STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
 301         TO DISPATCH TO IS FETCHED FROM STMDSP (THE STATEMENT
 302         DISPATCH TABLE) USING THE RESERVED WORD
 303         NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
 304         THE TABLE.
 305
 306     ERROR MESSAGES
 307         WHEN AN ERROR CONDITION IS DETECTED
 308         [E] MUST BE SET UP TO INDICATE WHICH ERROR
 309         MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
 310         TO ERROR. THE STACK WILL BE RESET AND ALL
 311         PROGRAM CONTEXT WILL BE LOST, VARIABLES
 312         VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
 313         ONLY THE VALUE OF [E] IS IMPORTANT WHEN
 314         THE BRANCH IS MADE TO ERROR. [E] IS USED AS AN
 315         INDEX INTO ERRTAB WHICH GIVES THE TWO
 316         CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
 317         USER'S TERMINAL.
 318
 319     IMPURE STORAGE
 320         ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
 321         THE FLOATING ACCUMULATOR,AN ANYTHING ELSE THAT
 322         IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
 323         IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
 324         IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
 325         IS OFTEN DEPENDED UPON.
 326
 327     TEXTUAL MESSAGES
 328         CONSTANT MESSAGES ARE STORED HERE. UNLESS
 329         THE CODE TO CHECK IF A STRING MUST BE COPIED
 330         IS CHANGED THESE STRINGS MUST BE STORED ABOVE
 331         DSCTMP, OR ELSE THEY WILL BE COPIED BEFORE
 332         THEY ARE PRINTED.
 333
 334     FNDFOR
 335         MOST SMALL ROUTINES ARE FAIRLY SIMPLE
 336         AND ARE DOCUMENTED IN PLACE. FNDFOR IS
 337         USED FOR FINDING "FOR" ENTRIES ON
 338         THE STACK. WHENEVER A "FOR" IS EXECUTED AN
 339         18 BYTE ENTRY IS PUSHED ONTO THE STACK.
 340         BEFORE THIS IS DONE, HOWEVER, A CHECK
 341         MUST BE MADE TO SEE IF THERE
 342         ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
 343         FOR THE SAME LOOP VARIABLE, IF SO, THAT "FOR" ENTRY
 344         AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
 345         ARE ELIMINATED FROM THE STACK, THIS IS SO A
 346         PROGRAM THAT JUMPS OUT OF THE MIDDLE
 347         OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
 348         AND AGAIN WON'T USE UP 18 BYTES OF STACK
 349         SPACE EVERY TIME. THE "NEXT" CODE ALSO
 350         CALLS FNDFOR TO SEARCH FOR A "FOR" ENTRY WITH
 351         THE LOOP VARIABLE IN
 352         THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
 353         THE STACK IS RESET, IF NO MATCH IS FOUND A
 354         "NEXT WITHOUT FOR" ERROR OCCURS. GOSUB EXECUTION
 355         ALSO PUTS A 6 BYTE ENTRY ON STACK
 356         WHEN A RETURN IS EXECUTED FNDFOR IS
 357         CALLED WITH A VARIABLE POINTER THAT CAN'T
 358         BE MATCHED. WHEN "FNDFOR" HAS RUN
 359         THROUGH ALL THE "FOR" ENTRIES ON THE STACK
 360         IT RETURNS AND THE RETURN CODE MAKES
 361         SURE THE ENTRY THAT WAS STOPPED
 362         ON IS A GOSUB ENTRY. THIS ASSURES THAT
 363         IF YOU GOSUB TO A SECTION OF CODE
 364         IN WHICH A FOR LOOP IS ENTERED BUT NEVER
 365         EXITED THE RETURN WILL STILL BE
 366         ABLE TO FIND THE MOST RECENT
 367         GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
 368         "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
 369         THE GOSUB ENTRY.
 370
 371     NON-RUNTIME STUFF
 372         THE CODE TO INPUT A LINE, CRUNCH IT,GIVE ERRORS,
 373         FIND A SPECIFIC LINE IN THE PROGRAM,
 374         PERFORM A "NEW", "CLEAR", AND "LIST" ARE
 375         ALL IN THIS AREA. GIVEN THE EXPLANATION OF
 376         PROGRAM STORAGE GIVEN BELOW THESE ARE
 377         ALL STRAIGHTFORWARD.
 378
 379     NEWSTT
 380         WHENEVER A STATEMENT FINISHES EXECUTION IT
 381         DOES A "RET" WHICH TAKES
 382         EXECUTION BACK TO NEWSTT. STATEMENTS THAT
 383         CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
 384         MUST GET RID OF THE RETURN ADDRESS OF NEWSTT AND
 385         JMP TO NEWSTT WHEN DONE. NEWSTT ALWAYS
 386         CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
 387         NAME BEFORE DISPATCHING. WHEN RETURNING
 388         BACK TO NEWSTT THE ONLY THING THAT
 389         MUST BE SET UP IS THE TEXT POINTER IN
 390         [H,L]. NEWSTT WILL CHECK TO MAKE SURE
 391         [H,L] IS POINTING TO A STATEMENT TERMINATOR.
 392         IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
 393         IT IS PROPERLY FORMATTED (I.E. "NEW") IT CAN
 394         SIMPLY DO A "RNZ" FTER READING ALL OF
 395         ITS ARGUMENTS. SINCE THE ZERO FLAG
 396         BEING OFF INDICATES THERE IS NOT
 397         A STATEMENT TERMINATOR NEWSTT WILL
 398         DO THE JMP TO THE "SYNTAX ERROR"
 399         ROUTINE. IF A STATEMENT SHOULD BE STARTED
 400         OVER IT CAN DO LHLD TEMP,RE SINCE THE [H,L]
 401         AT NEWSTT IS ALWAYS STORED IN TEMP. OF COURSE
 402         CARE MUST BE TAKEN THAT NO ROUTINE
 403         THAT SMASHES TEMP HAS BEEN CALLED.
 404         THE ^C CODE STORES TEMP IN OLDTXT AND CURLIN (THE
 405         CURRENT LINE NUMBER) IN OLDLIN SINCE THE ^C CHECK
 406         IS MADE BEFORE THE STATEMENT POINTED TO IS
 407         EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
 408         IN [H,L] WHICH POINTS AT THEIR TERMINATING
 409         CHARACTER IN OLDTXT,
 410
 411     STATEMENT CODE
 412         THE INDIVIDUAL STATEMENT CODE COMES
 413         NEXT. THE APPROACH USED IN EXECUTING EACH
 414         STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
 415         ITSELF.
 416
 417     FRMEVL, THE FORMULA EVALUATOR
 418         GIVEN AN [H,L] POINTING TO THE STARTING
 419         CHARACTER OF A FORMULA FRMEVL
 420         EVALUATES THE FORMULA AND LEAVES
 421         THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
 422         [H,L] IS RETURNED POINTING TO THE FIRST CHARACTER
 423         THAT COULD NOT BE INTERPRETED AS PART OF THE
 424         FORMULA. THE ALGORITHM USES THE STACK
 425         TO STORE TEMPORARY RESULTS:
 426
 427         0. PUT A DUMMY PRECEDENCE OF ZERO ON
 428            THE STACK.
 429         1. READ LEXEME (CONSTANT,FUNCTION,
 430            VARIABLE,FORMUL IN PARENS)
 431            AND TAKE THE LAST PRECEDENCE VALUE
 432            OFF THE STACK.
 433         2. SEE IF THE NEXT CHARACTER IS AN OPERATOR
 434            IF THIS MAY CAUSE
 435            OPERATOR APPLICATION OR AN ACTUAL
 436            RETURN FROM FRMEVL.
 437         3. IF IT IS, SEE WHAT PRECEDENCE IT HAS
 438            AND COMPARE IT TO THE PRECEDENCE
 439            OF THE LAST OPERATOR ON THE STACK
 440         4. IF OR LESS REMEMBER THE TEXT
 441            POINTER AT THE START OF THIS OPERATOR
 442            AND DO A RETURN TO CAUSE
 443            APPLICATION OF THE LAST OPERATOR.
 444            EVENTUALLY RETURN TO STEP 2
 445            BY RETURNING TO RETAOP.
 446         5. IF GREATER PUT THE LAST PRECEDENCE
 447            BACK ON, SAVE THE CURRENT
 448            TEMPORARY RESULT, OPERATOR ADDRESS
 449            AND PRECEDENCE AND RETURN TO STEP 1.
 450
 451         RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
 452         A COMMON ROUTINE. SPECIAL
 453         CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F"
 454
 455     EVAL -- THE ROUTINE TO READ A LEXEME
 456         EVAL CHECKS FOR THE DIFFERENT TYPES OF
 457         ENTITIES IT IS SUPPOSED TO DETECT.
 458         LEADING PLUSES ARE IGNORED,
 459         DIGITS AND "." CAUSE FIN (FLOATING INPUT)
 460         TO BE CALLED. FUNCTION NAMES CAUSE THE
 461         FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
 462         AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
 463         NAMES CAUSE PTRGET TO BE CALLED TO GET A POINTER
 464         TO THE VALUE, AND THEN THE VALUE IS PUT INTO
 465         THE FAC. AN OPEN PARENTHESIS CAUSES FRMEVL
 466         TO BE CALLED (RECURSIVELY), AND THE ")" TO
 467         BE CHECKED FOR. UNARY OPERATORS (NOT AND
 468         NEGATION) PUT THEIR PRECEDENCE ON THE STACK
 469         AND ENTER FORMULA EVALUATION AT STEP 1, SO
 470         THAT EVERYTHING UP TO AN OPERATOR GREATER THAN
 471         THEIR PRECEDENCE OR THE END OF THE FORMULA
 472         WILL BE EVALUATED. WHEN FRMEVL DOES A RETURN
 473         BECAUSE IT SEES AN OPERATOR OF HIGHER PRECEDENCE
 474         IT DOES NOT PASS THE TEXT POINTER IN [H,L], SO
 475         AFTER THE UNARY OPERATION HAS BEEN PERFORMED
 476         ON THE FAC THE TEXT POINTER MUST BE FETCHED FROM
 477         A TEMPORARY LOCATION THAT FRMEVL USES AND
 478         A RETURN BACK TO FRMEVL DONE.
 479
 480     DIMENSION AND VARIABLE SEARCHING
 481         SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
 482         ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
 483         EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
 484         FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
 485         NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
 486         BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
 487         GIVE ITS VALUE. (VARTAB) GIVES THE FIRST LOCATION
 488         WHERE A SIMPLE VARIABLE NAME IS FOUND AND [ARYTAB]
 489         GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
 490         VARIABLES, A "FOR" ENTRY HAS A TEXT POINTER
 491         AND A POINTER TO A VARIABLE VALUE SO NEITHER
 492         THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
 493         MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK.
 494         USER FINED FUNCTION VALUES ALSO CONTAIN
 495         POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
 496         FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
 497         ARE MOVED. ADDING A SIMPLE VARIABLE
 498         ADDING SIX TO ARYTAB AND STREND, BLOCK TRANSFERING
 499         THE ARRAY VARIABLES UP BY SIX AND MAKING SURE THE
 500         NEW [STREND] IS NOT TO CLOSE TO THE STACK.
 501         THIS MOVEMENT OF ARRAY VARIABLES MEANS
 502         THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
 503         NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
 504         WHY ARRAY VARIABLES ARE NOT ALLOWED "FOR"
 505         LOOP VARIABLES, SETING UP ANEW ARRAY VARIABLE
 506         MERELY INVOLVES BUILDING THE DESCRIPTOR,
 507         UPDATING STREND, AND MAKING SURE THERE IS
 508         STILL ENOUGH ROOM BETWEEN STREND AND THE
 509         STACK, WITHOUT MULTIPLE DIMENSIONS THE FORMAT
 510         OF AN ARRAY VARIABLE IS SIMPLY:
 511             SECOND CHARACTER
 512             FIRST CHARACTER
 513             NUMBER OF BYTES USED BY VALUES
 514             VALUES
 515         THE FORMAT WHEN MULTIPLY DIMENSIONED VARIABLES
 516         ARE ALLOWED IS DESCRIBED IN THE "MULDIM" CODE.
 517         PTRGET, THE ROUTINE WHICH RETURNS A POINTER
 518         TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
 519         "DIMFLG" WHICH INDICATED WHETHER "DIM" CALLED PTRGET
 520         OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
 521         QUESTION SHOULD BE FOUND, AND THE INDEX INDICATES
 522         HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
 523         BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
 524         SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
 525         ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS SUBFLG
 526         WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
 527         ALLOWED IN THE CURRENT CONTEXT. IF SUBFLG IS NON-ZERO
 528         THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
 529         WILL NOT BE SCANNED BY PTRGET, AND PTRGET WILL RETURN
 530         WITH A TEXT POINTER POINTING TO THE "(", IF
 531         THERE WAS ONE.
 532     STRINGS
 533         IN THE VARIABLE TABLE STRINGS ARE STORED JUST LIKE
 534         NUMERIC VARIABLES. SIMPLE STRINGS HAVE FOUR VALUE
 535         BYTES WHICH ARE INITIALIZED TO ALL ZEROS (WHICH
 536         REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
 537         IN HANDLING IS THAT WHEN PTRGET SEES A "$" AFTER THE
 538         NAME OF A VARIABLE, PTRGET SETS VALTYP TO ONE AND TURNS
 539         ON THE MSB (MOST-SIGNIFIGANT-BITY OF THE VALUE OF
 540         THE FIRST CHARACTER OF THE VARIABLE NAME.
 541         HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
 542         THAT THE SEARCH ROUTINE WILL NOT MATCH
 543         'A' WITH 'AS' OR 'AS' WITH 'A'. THE MEANING OF
 544         THE FOUR VALUE BYTES ARE:
 545             LOW
 546                 LENGTH OF THE STRING
 547                 UNUSED
 548                 LOW 8 BITS
 549                 HIGH 8 BITS OF THE ADDRESS
 550                     OF THE CHARACTERS IN THE
 551                     STRING IF LENGTH. NE.
 552                     MEANINGLESS OTHERWISE.
 553             HIGH
 554         THE VALUE OF A STRING VARIABLE (THESE 4 BYTES)
 555         IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
 556         IT FROM THE ACTUAL STRING DATA. WHENEVER A
 557         STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
 558         PART OF AN INPUT STRING, OR AS PART OF DATA, STRLIT
 559         IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
 560         THE STRING. IF THE STRING CONSTANT IS IN BUF (WHICH
 561         IT WILL BE IF THE STRING IS BEING "INPUT", OR THE
 562         STRING IS PART OF SOME FORMULA IN A DIRECT STATEMENT)
 563         THE VALUE IS COPIED INTO STRING SPACE SINCE BUF
 564         IS ALWAYS CHANGING, "STRCPY" IS USED TO COPY
 565         STRINGS.
 566
 567         STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
 568         ALWAYS RETURN THEIR VALUES IN STRING SPACE.
 569         ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
 570         THROUGH A "READ" OR ASSIGNMENT STATEMENT
 571         WILL NOT USE ANY STRING SPACE SINCE
 572         THE STRING DESCRIPTOR WILL POINT INTO THE
 573         PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
 574         WHEN A STRING VALUE IS IN BUF, OR IT IS IN STRING
 575         SPACE AND THERE IS AN ACTIVE POINTER TO IT.
 576         THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
 577         STRING DATA IN STRING SPACE. FS=CHR$(7)
 578         WILL USE ONE BYTE OF STRING SPACE TO STORE THE
 579         NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
 580         THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
 581         THE ONLY POINTER AT THE NEW STRING IS A
 582         TEMPORARY DESCRIPTOR CREATED BY FRMEVL WHICH WILL
 583         GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
 584         IT IS THE NATURE OF GARBAGE COLLECTION THAT
 585         DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
 586         AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
 587         MUST PROCEED AS FOLLOWS:
 588             1) FIGURE OUT THE LENGTH OF THEIR RESULT
 589             2) CALL GETSPA TO FIND SPACE FOR THEIR
 590                RESULT. THE ARGUMENTS TO THE FUNCTION
 591                OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
 592                MAY BE INVOKED. THE ONLY THING THAT CAN
 593                BE SAVED DURING THE CALL TO GETSPA IS A POINTER
 594                TO THE DESCRIPTORS OF THE ARGUMENTS.
 595             3) CONSTRUCT THE RESULT DESCRIPTOR IN DSCTMP.
 596                GETSPA RETURNS THE LOCATION OF THE AVAILABLE
 597                SPACE.
 598             4) CREATE THE NEW VALUE BY COPYING PARTS
 599                OF THE ARGUMENTS OR WHATEVER.
 600             5) FREE UP THE ARGUMENTS BY CALLING FRETMP.
 601             6) JUMP TO PUTNEW TO GET THE DESCRIPTOR IN
 602                OSCTMP TRANSFERRED INTO A NEW STRING TEMPORARY.
 603
 604         THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
 605         COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
 606         SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
 607         USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
 608
 609         INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
 610         FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
 611         BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
 612         VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
 613         STORED IN THE FAC, AND IT IS THIS POINTER
 614         THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
 615         STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
 616         AWAY SINCE GETSPA MAY FORCE
 617         GARBAGE COLLECTION AND THE ARGUMENT STRINGS
 618         MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
 619         WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
 620         THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
 621         DSCTMP SINCE STRING TEMPORARIES ARE ALLOCATED
 622         (PUTNEW) AND DEALLOATED (FRETMP) IN A FIFO ORDERING
 623         (I.E. A STACK) SO THE NEW TEMPORARY CANNOT
 624         BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
 625         TO BUILD A RESULT IN A TEMPORARY AFTER
 626         FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
 627         IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
 628         TOO SOON BY THE NEW RESULT.
 629
 630         STRING SPACE IS ALLOCATED AT THE VERY TOP
 631         OF MEMORY. MEMSIZ POINTS BEYOND THE LAST LOCATION OF
 632         STRING SPACE. STRING ARE STORED IN HIGH LOCATIONS
 633         FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA)
 634         FRETOP, WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
 635         TO GIVE THE HIGHEST LOCATION IN STRING SPACE
 636         THAT IS NOT IN USE. THE RESULT IS THAT
 637         FRETOP GETS SMALLER AND SMALLER, UNTIL SOME
 638         ALLOCATION WOULD MAKE (FRETOP) LESS THAN OR EQUAL TO
 639         (STKTOP). THIS MEANS STRING SPACE HAS RUN INTO THE
 640         STACK AND THAT GARBAGE COLLECTION MUST BE CALLED.
 641
 642         GARBAGE COLLECTION:
 643             0. MINPTR=[STKTOP] [FRETOP]=[MEMSIZ]
 644             1. REMMIN=0
 645             2. FOR EACH STRING DESCRIPTOR
 646                (TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
 647                IF THE STRING IS NOT NULL AND ITS POINTER IS
 648                .GT.MINPTR AND .LT.FRETOP,
 649                MINPTR=THIS STRING DESCRIPTORS POINTER
 650                REMMIN=POINTER AT THIS STRING DESCRIPTOR
 651                END
 652             3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING)
 653                BLOCK TRANSFER THE STRING DATA POINTED
 654                TO IN THE STRING DESCRIPTOR POINTED TO BY REMMIN
 655                SO THAT THE LAST BYTE OF STRING DATA IS AT
 656                [FRETOP], UPDATE FRETOP SO THAT IT
 657                POINTS TO THE LOCATION JUST BELOW THE ONE
 658                THE STRING DATA WAS MOVED INTO. UPDATE
 659                THE POINTER IN THE DESCRIPTOR SO IT POINTS
 660                TO THE NEW LOCATION OF THE STRING DATA,
 661                GO TO STEP 1.
 662
 663         AFTER CALLING GARBAGE COLLECTION GETSPA AGAIN CHECKS
 664         TO SEE IF [A] CHARACTERS ARE AVAILABLE BETWEEN
 665         [STKTOP] AND [FRETOP] , IF NOT AN "OUT OF STRING"
 666         ERROR IS INVOKED.
 667
 668     MATH PACKAGE
 669         THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
 670         FLOATING OUTPUT (FOUT) FLOATING COMPARE (FCOMP)
 671         ... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
 672         THE FORMATS, CONVENTIONS AND ENTRY POINTS ARE ALL
 673         DESCRIBED IN THE MATH PACKAGE ITSELF.
 674
 675     INIT -- THE INITIALIZATION ROUTINE
 676         INITIALIZATION FIRST LOOKS AT THE SWITCH REGISTER
 677         TO SEE WHAT TYPE OF I/O SHOULD BE DONE.
 678         ANY NON-STANDARD I/O CAUSES LOCATIONS IN
 679         TO BE CHANGED. THEN THE AMOUNT OF MEMORY,
 680         TERMINAL WIDTH, AND WHICH FUNCTIONS TO BE RETAINED
 681         ARE ASCERTAINED FROM THE USER, A ZERO IS PUT DOWN
 682         AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
 683         AND TXTTAB IS SET UP TO POINT AT THE NEXT LOCATION,
 684         THIS DETERMINES WHERE PROGRAM STORAGE WILL START. THE
 685         HIGHEST MEMORY LOCATION MINUS THE AMOUNT OF DEFAULTED
 686         STRING SPACE (50) GIVES THE FIRST LOCATION USED BY THE
 687         STACK. SPECIAL CHECKS ARE MADE TO MAKE SURE
 688         ALL QUESTIONS IN INIT ARE ANSWERED REASONABLY, SINCE
 689         ONCE INIT FINISHES THE LOCATIONS IT USES ARE
 690         USED FOR PROGRAM STORAGE. THE LAST THING INIT DOES IS
 691         CHANGE LOCATION ZERO TO BE A JUMP TO READY INSTEAD
 692         OF INIT. ONCE THIS IS DONE THERE IS NO WAY TO RESTART
 693         INIT.
 694
 695     STORAGE
 696                    A ZERO.
 697         [TXTTAB]   POINTER TO NEXT LINE'S POINTER
 698                    LINE # OF THIS LINE (2 BYTES)
 699                    CHARACTERS ON THIS LINE
 700                    ZERO
 701                    POINTER AT NEXT LINE'S POINTER
 702                    (POINTED TO BY THE ABOVE POINTER)
 703                    ... REPEATS ...
 704         LAST LINE: POINTER AT ZERO POINTER
 705                    LINE # OF THIS LINE
 706                    CHARACTERS ON THIS LINE
 707                    ZERO
 708                    DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER)
 709         [VARTAB]   SIMPLE VARIABLES. 6 BYTES PER VALUE.
 710                    2 BYTES GIVE THE NAME, 4 BYTES THE VALUE
 711                    ... REPEATS ...
 712         [ARYTAB]   ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
 713                    LENGTH, VALUE (EXTRA IF MULDIM ON)
 714                    ... REPEATS ...
 715         [STREND]   FREE SPACE
 716                    ... REPEATS ...
 717                    MOST RECENT STACK ENTRY
 718                    ... REPEATS ...
 719         [STKTOP]   FIRST STACK ENTRY
 720                    FREE STRING SPACE
 721                    ... REPEATS ...
 722         [FRETOP]   STRING SPACE IN USE
 723                    ... REPEATS ...... REPEATS ...
 724         [MEMSIZ]   HIGHEST MACHINE LOCATION
 725                    UNUSED EXCEPT BY THE VAL FUNCTION.
 726 HIGH LOCATIONS
 727
 728          *        
 729 PAGE     
 730 SUBTTL   RST ROUTINES
 731 RELOC    0        
 732 START:   DI                                ;DISENABLE INTERRUPTS
 733          JMP      INIT                     ;INIT IS THE INTIALIZE ROUTINE
 734 
 735 
 736                                            ;IT SETS UP CERTAIN
 737                                            ;LOCATIONS DELETES FUNCTIONS IF
 738                                            ;DESIRED AND
 739                                            ;CHANGES THIS TO JMP READY
 740 IFN      LENGTH-2,<
 741          ADR(DEINT)                        ;STORE HERE THE ROUTINE
 742                                            ;TO TURN THE FAC INTO
 743                                            ;A TWO-BYTE SIGNED INTEGER
 744          ADR(GIVABF)>                      ;STORE HERE THE ADDRESS
 745                                            ;OF THE ROUTINE TO CONVERT [A,B]
 746                                            ;TO A FLOATING POINT NUMBER IN THE FAC
 747 IFE      LENGTH-2,<
 748          ADR(FRCINT)                       ;TURN FAC INTO AN INTEGER IN [H,L]
 749 
 750          ADR(MAKINT)>                      ;TURN [H,L] INTO A VALUE IN THE FAC
 751 
 752                                            ;SET VALTYP FOR INTEGER
 753 RELOC    8        
 754 ; 
 755 ; SYNCHK LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
 756 ; IS A SPECIFIC THING (CONTAINED IN THE LOCATION AFTER THE CALL)
 757 ; IF NOT IT CALLS THE SYNTAX ERROR ROUTINE, OTHERWISE IT GOBBLES
 758 ; THE NEXT CHARACTER AND RETURNS. (BY FALLING INTO CHRGET)
 759 ; 
 760 ; ALL REGISTERS ARE PRESERVED EXCEPT [A]=NEW CHAR
 761 ; AND [H,L] ENDS UP POINTING AT THE CHARACTER AFTER THE ONE
 762 ; WHICH WAS CHECKED.
 763 ; 
 764          MOV      A,M                      ;GET THE CURRENT CHARACTER
 765          XTHL                              ;GET CALL ADDRESS INTO [H,L]
 766                                            ;PUT TEXT POINTER ON STACK
 767          CMP      M                        ;SEE IF [A] #CURRENT CHARACTER
 768                                            ;IS THE RIGHT THING.
 769          INX      H                        ;FIX RETURN ADDRESS.
 770          XTHL                              ;PUT RETURN ADDRESS BACK AND RESTORE
 771                                            ;THE TEXT POINTER.
 772          JNZ      SNERR                    ;IF THE CHARACTER WASN'T RIGHT CALL
 773 
 774 
 775                                            ;THE 'SYNTAX ERROR' ROUTINE.
 776                                            ;OTHERWISE FALL THROUGH
 777                                            ;AND GET ANOTHER CHARACTER.
 778 
 779 ; CHRGET, USING [H,L] AS THE CURRENT TEXT POINTER FETCHES
 780 ; A NEW CHARACTER INTO [A] AFTER INCREMENTING [H,L]
 781 ; AND SETS CONDITION CODES ACCORDING TO WHATS IN [A]
 782 ;       C=     NUMERIC      ("0" THROUGH "9")
 783 ;       Z=     ":" OR END-OF-LINE (A 0)
 784 ; 
 785 ; ALL REGISTERS SAVED EXCEPT [A]=NEW CHAR
 786 ; [H,L]=[H,L]+1
 787 ; 
 788 RELOC    16       
 789 IFE      LENGTH,<CHRGTR:>
 790          INX      H                        ;UPDATE THE TEXT POINTER
 791          MOV      A,M                      ;GET NEW CHARACTER
 792          CPI      ":"                      ;MAKE ":" HAVE ZERO ON AND
 793 
 794                                            ;CARRY OFF
 795                                            ;ALL ALPHABETICS & RESERVED
 796                                            ;WORDS GET ZERO & CARRY OFF
 797          RNC                               ;.GT.":" GO BACK
 798          JMP      CHRCON                   ;NO ROOM FOR WHOLE ROUTINE
 799 
 800 
 801 ; 
 802 ; THIS RST ROUTINE OUTPUTS THE CHARACTER IN [A] USING PRTFLG (LPT OR TTY)
 803 ; CNTWFL (SUPRESS OUTPUT OR NOT), TTYPOS (PRINT HEAD POSITION),
 804 ; TIMING ETC.. NO REGISTERS OR CONDITION CODES ARE CHANGED.
 805 ; 
 806 RELOC    24       
 807 OUTDO:   PUSH     PSW      
 808 IFN      CONTRW,< 
 809          LDA      CNTWFL                   ;GET SUPPRESS FLAG
 810 
 811 
 812          ORA      A>                       ;SEE IF IT IS SET
 813 IFE      LENGTH!CONTRW!LPTSW,<
 814          LDA      TTYPOS>                  ;USE RST BYTES, [A]=TTYPOS
 815          JMP      OUTCON   
 816 
 817 
 818 ; 
 819 ; COMPAR COMPARES [H,L] WITH [D,E] UNSIGNED
 820 ; 
 821 ;       [H,L] LESS THAN [D,E] SET CARRY
 822 ;       [H,L] = [D,E] SET ZERO
 823 ; 
 824 ; [A] IS THE ONLY REGISTER USED
 825 ; 
 826 RELOC    32       
 827          MOV      A,H      
 828          SUB      D        
 829          RNZ      
 830          MOV      A,L      
 831          SUB      E        
 832          RET      
 833 
 834 NULCNT:  1                                 ;STORE HERE THE NUMBER OF NULLS
 835                                            ;TO PRINT AFTER CRLF
 836 TTYPOS:  BLOCK    1                        ;STORE TERMINAL POSITION HERE
 837 ; 
 838 ; THE FSIGN RST RETURNS A==1 IF FAC IS LESS THAN 0
 839 ;       A=0 IF FAC=0
 840 ;       A=1 IF FAC GREATER THAN ZERO
 841 ; THE CONDITION CODES REFLECT THE VALUE OF [A]
 842 ; AND NO OTHER REGISTERS ARE MODIFIED.
 843 ; THIS WORKS ONLY WHEN THE FAC IS A SINGLE OR DOUBLE PRECISION NUMBER
 844 ; THE 'VSIGN' ROUTINE IS MORE GENERAL SINCE
 845 ; IT WILL TAKE THE SIGN OF INTEGERS AS WELL
 846 ; AND GIVES "TMERR" ON STRINGS.
 847 ; 
 848 RELOC    40       
 849 SIGN:    LDA      FAC      
 850 
 851 
 852          ORA      A        
 853          JNZ      SIGNC    
 854 
 855 
 856          RET      
 857 ; 
 858 ; THIS IS THE PUSHM RST
 859 ; EFFECT IS:
 860 ;       MOV C,M
 861 ;       INX H
 862 ;       MOV B,M
 863 ;       INX H
 864 ;       PUSH B
 865 ; DIFFICULTY COMES IN BECAUSE OF THE
 866 ; RETURN ADDRESS.
 867 ; 
 868 RELOC    48       
 869          XTHL                              ;SWITCH [H,L] AND RETURN ADDRESS
 870          SHLD     PUSHMA+1                 ;FIXUP JUMP TO PLACE TO GO
 871 
 872 
 873          POP      H                        ;REGAIN [H,L]
 874 IFN      LENGTH,< 
 875          JMP      $CODE+59                 ;IN 8K ALLOW USER TO HAVE RST 7
 876 
 877 
 878                                            ;FOR INTERRUPT TRAPPING
 879 RELOC    56       
 880          RET                               ;INITIALLY NO INTERRUPT
 881                                            ;ROUTINE
 882          NOP      
 883          NOP>     
 884          MOV      C,M                      ;GRAB FROM MEMORY
 885          INX      H        
 886          MOV      B,14     
 887          INX      H        
 888          PUSH     B                        ;PUSH [B,0] ONTO THE STACK
 889                                            ;SINCE IT CONTAINS [M]
 890 PUSHMA:  JMP      PUSHMA                   ;RETURN ADDRESS STORED HERE
 891 
 892 
 893 
 894 PAGE     
 895 SUBTTL   DISPATCH TABLES, RESERVED WORDS, ERROR TEXT ... ALL CONSTANT
 896 
 897 FUNDSP:  ADR(SGN) 
 898 
 899 IFN      LENGTH-2,<
 900          ADR(INT))
 901 IFE      LENGTH-2,<
 902          ADR(VINT)>
 903 
 904          ADR(ABS) 
 905 
 906 USRLOC:  ADR(ILLFUN)                       ;INITIALLY NO USER ROUTINE
 907 
 908 IFN      LENGTH,<ADR(FRE)
 909 
 910          ADR(FNINP)
 911 
 912 IFN      LPTSW,<ADR(LPOS)>
 913          ADR(POS)>
 914 
 915 SQRFIX:  ADR(SQR) 
 916 
 917 RNDFIX:  ADR(RND) 
 918 
 919 IFN      EXTFNC,< 
 920          ADR(LOG) 
 921 
 922          ADR(EXP) 
 923 
 924 COSFIX:  ADR(COS) 
 925 
 926 SINFIX:  ADR(SIN) 
 927 
 928 IFN      EXTFNC,< 
 929 TANFIX:  ADR(TAN) 
 930 
 931 ATNFIX:  ADR(ATN) 
 932 
 933 IFN      LENGTH,< 
 934          ADR(PEEK)>
 935 
 936 IFN      DSKFUN,<ADR(DSKI$):
 937 IFN      STRING,< 
 938          ADR(LEN) 
 939 
 940          ADR(STR$)
 941 
 942          ADR(VAL) 
 943 
 944          ADR(ASC) 
 945 
 946          ADR(CHR$)
 947 
 948          ADR(LEFT$)
 949 
 950          ADR(RIGHT$)
 951 
 952          ADR(MID$)>
 953 
 954 
 955 DEFINE   ADRP(X),<ADR(X)>
 956 IFE      LENGTH-2,<
 957 DEFINE   ADRP(X),<>>
 958 OPTAB:   121                               ;OPERATOR TABLE CONTAINS
 959                                            ;PRECEDENCE FOLLOWED BY
 960                                            ;THE ROUTINE ADDRESS
 961          ADRP(FADDT)
 962          121      
 963          ADRP(FSUBT)
 964          123      
 965          ADRP(FMULTT)
 966          123      
 967          ADRP(FDIVT)
 968 IFN      EXTFNC,<127
 969          ADRP(FPWRT)>
 970 IFN      LENGTH,< 
 971          80       
 972          ADRP(AND)
 973          70       
 974          ADRP(OR)>
 975 
 976 ; 
 977 ; TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
 978 ; SIGNIFIGANT BIT ON
 979 ; THE LIST OF RESERVED WORDS
 980 ; 
 981          Q=128-1  
 982 DEFINE   DCI(A),<Q=Q+1
 983          XLIST    
 984          DC(A)    
 985          LIST>    
 986          ENDTK==Q 
 987          FORTK==Q 
 988          DATATK==Q
 989          GOTOTK==Q
 990          IFTK==Q  
 991          GOSUTK=Q 
 992          REMTK=Q  
 993 IFE      LENGTH-2,<
 994          ELSETK==Q
 995 IFN      DSKFUN,<DCI"DSKO$">
 996 IFN      LPTSW,<DCI"LPRINT">
 997 IFN      LENGTH,< 
 998          PRINTK==Q
 999 IFE      REALIO,< 
1000          DCI"DDT">
1001 IFN      LPTSW,<DCI"LLIST">
1002 IFN      CASSW,<DCI"CLOAD"
1003          DCI"CSAVE">
1004 IFN      CONSSW,<DCI"CONSOLE">
1005          SCRATK=Q 
1006 ; END OF COMMAND LIST
1007          "T"      
1008          "A"      
1009          "B"      
1010          "("+128  
1011          Q=Q+1    
1012          TABTK=Q  
1013          TOTK==Q  
1014 IFN      LENGTH,< 
1015          "S"      
1016          "P"      
1017          "C"      
1018          "("+128                           ;MACRO DOESNT LIKE ('S IN ARGUMENTS
1019          Q=Q+1    
1020          SPCTK==Q>
1021          FNTK==Q> 
1022          USINTK==Q>
1023          THENTK=Q 
1024 IFN      LENGTH,< 
1025          NOTTK==Q>
1026          STEPTK=Q 
1027          PLUSTK=Q 
1028          MINUTK=Q 
1029          LSTOPK==Q+1-PLUSTK                ;CRUNCH # OF HIGHEST OP+1-PLUSTK
1030          190                               ;A GREATER THAN SIGN
1031          Q=Q+1    
1032          GREATK=Q 
1033          EQULTK=Q 
1034          188      
1035          Q=Q+1                             ;A LESS THAN SIGN
1036          LESSTK=Q 
1037 ; 
1038 ; NOTE DANGER OF ONE RESERVED WORD BEING A PART
1039 ; OF ANOTHER
1040 ; IE . . IF 2 GREATER THAN F OR T=5 THEN...
1041 ; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
1042 ; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
1043 ; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
1044 ; ANOTHER EXAPMLE: IF T OR Q THEN ... "TO" IS CRUNCHED
1045 ; 
1046          ONEFUN=Q 
1047 IFN      PTSW,<DCI"LPOS">
1048          SQRTK==Q 
1049 IFN      EXTFNC,< 
1050          ATNTK==Q>
1051 IFN      LENGTH,< 
1052 IFN      <DCI"DSKI$">
1053 IFN      STRING,< 
1054          LASNUM==Q                         ;NUMBER OF LAST FUNCTION
1055                                            ;THAT TAKES ONE ARG
1056          0                                 ;MARKS END OF RESERVED WORD LIST
1057 
1058 STMDSP:  ADR(END) 
1059 
1060          ADR(FOR) 
1061 
1062          ADR(NEXT)
1063 
1064          ADR(DATA)
1065 
1066          ADR(INPUT)
1067 
1068          ADR(DIM) 
1069 
1070          ADR(READ)
1071 
1072          ADR(LET) 
1073 
1074          ADR(GOTO)
1075 
1076          ADR(RUN) 
1077 
1078          ADR(IF)  
1079 
1080          ADR(RESTORE)
1081 
1082          ADR(GOSUB)
1083 
1084          ADR(RETURN)
1085 
1086          ADR(REM) 
1087 
1088          ADR(STOP)
1089 
1090 IFE      LENGTH-2,<
1091          ADR(ELSE)
1092 
1093          ADR(TON) 
1094 
1095          ADR(TOFF)
1096 
1097          ADR(EDIT)>
1098 
1099 IFN      LENGTH,<ADR(FNOUT)
1100 
1101          ADR(ONGOTO)
1102 
1103          ADR(NULL)
1104 
1105          ADR(FNWAIT)>
1106 
1107 IFN      DSKFUN,<ADR(DSKO$)>
1108 IFN      LPTSW,<ADR(LPRINT)>
1109 IFN      LENGTH,< 
1110          ADR(POKE)>
1111 
1112          ADR(PRINT)
1113 
1114 IFN      FUNCTS,<ADR(DEF)>
1115 
1116 
1117 IFN      LENGTH,<ADR(CONT)>
1118 
1119 IFE      REALIO,<ADR(DDT)>
1120          ADR(LIST)
1121 
1122 IFN      LPTSW,<ADR(LLIST)>
1123 IFE      LENGTH-2,<ADR(DELETE)>
1124 
1125          ADR(CLEAR)
1126 
1127 IFN      CASSW,<ADR(CLOAD)
1128          ADR(CSAVE)>
1129 IFN      CONSSW,<ADR(CONSOLE)>
1130          ADR(SCRATH)
1131 
1132 
1133 IFE      LENGTH-2,<
1134 FRCTBL:  ADR(FRCDBL)
1135 
1136          ADR(FRCINT)
1137 
1138          ADR(FRCSNG)
1139 
1140 ; 
1141 ; THESE TABLES ARE USED AFTER THE DECISION HAS BEEN MADE
1142 ; TO APPLY AN OPERATOR AND ALL THE NECESSARY CONVERSION HAS
1143 ; BEEN DONE TO MATCH THE TWO ARGUMENT TYPES (APPLOP)
1144 ; 
1145 DBLDSP:  ADR(DADD)                         ;DOUBLE PRECISION ROUTINES
1146 
1147          ADR(DSUB)
1148 
1149          ADR(DMULT)
1150 
1151          ADR(DDIV)
1152 
1153          ADR(DCOMP)
1154 
1155 SNGDSP:  ADR(FADD)                         ;SINGLE PRECISION ROUTINES
1156 
1157          ADR(FSUB)
1158 
1159          ADR(FMULT)
1160 
1161          ADR(FDIV)
1162 
1163          ADR(FCOMP)
1164 
1165 INTDSP:  ADR(IADO)                         ;INTEGER ROUTINES
1166 
1167          ADR(ISUB)
1168 
1169          ADR(IMULT)
1170 
1171          ADR(IDIV)
1172 
1173          ADR(ICOMP)>
1174 
1175 
1176 
1177          Q==2     
1178 DEFINE   DCL(X),<>
1179 DEFINE   DCE(X),<Q=Q+2
1180          XLIST    
1181          DC(X)    
1182          LIST>    
1183 
1184 ERRTAB:  
1185 IFE      LENGTH-2,<
1186          0        
1187          Q=0      
1188 DEFINE   DCE(X),<>
1189 DEFINE   DCL(X),< 
1190          Q=Q+1    
1191          DC(X)    
1192          0>>      
1193          DCE"NF"
1194          DCL"NEXT WITHOUT FOR"
1195 
1196 
1197 
1198 
1199 
1200 
1201 
1202 
1203 
1204 
1205 
1206 
1207 
1208 
1209 
1210 
1211 
1212          ERRNF==Q 
1213          DCE"SN"
1214          DCL"SYNTAX ERROR"
1215 
1216 
1217 
1218 
1219 
1220 
1221 
1222 
1223 
1224 
1225 
1226 
1227 
1228          ERRSN==Q 
1229          DCE"RG"
1230          DCL"RETURN WITHOUT GOSUB"
1231 
1232 
1233 
1234 
1235 
1236 
1237 
1238 
1239 
1240 
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 
1252          ERRRG==Q 
1253          DCE"OD"
1254          DCL"OUT OF DATA"
1255 
1256 
1257 
1258 
1259 
1260 
1261 
1262 
1263 
1264 
1265 
1266 
1267          ERROD==Q 
1268          DCE"FC"
1269          DCL"ILLEGAL FUNCTION CALL"
1270 
1271 
1272 
1273 
1274 
1275 
1276 
1277 
1278 
1279 
1280 
1281 
1282 
1283 
1284 
1285 
1286 
1287 
1288 
1289 
1290 
1291 
1292          ERRFC==Q 
1293          DCE"OV"
1294          DCL"OVERFLOW"
1295 
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304          ERROV==Q 
1305          DCE"OM"
1306          DCL"OUT OF MEMORY"
1307 
1308 
1309 
1310 
1311 
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321          ERROM==Q 
1322          DCE"US"
1323          DCL"UNDEFINED STATEMENT"
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344          ERRUS==Q 
1345          DCE"BS"
1346          DCL"SUBSCRIPT OUT OF RANGE"
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370          ERRBS==Q 
1371          DCE"DD"
1372          DCL"REDIMENSIONED ARRAY"
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393          ERRDD==Q 
1394          DCE"/0"
1395          DCL"DIVISION BY ZERO"
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413          ERRDV0==Q
1414          DCE"ID"
1415          DCL"ILLEGAL DIRECT"
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431          ERRID==Q 
1432 IFN      STRING,< 
1433          DCE"TM"
1434          DCL"TYPE MISMATCH"
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449          ERRTM==Q 
1450          DCE"OS"
1451          DCL"OUT OF STRING SPACE"
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472          ERRSO==Q 
1473          DCE"LS"
1474          DCL"STRING TOO LONG"
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491          ERRLS==Q 
1492          DCE"ST"
1493          DCL"STRING FORMULA TOO COMPLEX"
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521          ERRST==Q>
1522 IFN      LENGTH,< 
1523          DCE"CN"
1524          DCL"CAN'T CONTINUE"
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540          ERRCN==Q>
1541 IFN      FUNCTS,< 
1542          DCE"UF"
1543          DCL"UNDEFINED USER FUNCTION"
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 
1553 
1554 
1555 
1556 
1557 
1558 
1559 
1560 
1561 
1562 
1563 
1564 
1565 
1566 
1567 
1568          ERRUF==Q>
1569 
1570 PAGE     
1571 SUBTTL   LOW SEGMENT -- RAM -- IE THIS STUFF IS NOT CONSTANT
1572 ; 
1573 ; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
1574 ; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
1575 ; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
1576 ; PROGRAM INSTRUCTIONS IN ROM.
1577 ; 
1578 
1579 BUFMIN:  44                                ;A COMMA (PRELOAD OR ROM)
1580                                            ;USED BY INPUT STATEMENT SINCE THE
1581                                            ;ONATA POINTER ALWAYS STARTS ON A
1582                                            ;COMMA OR TERMINATOR
1583 BUF:     BLOCK    BUFLEN                   ;TYPE IN STORED HERE
1584                                            ;DIRECT STATEMENTS EXECUTE OUT OF
1585                                            ;THERE. REMEMBER INPUT SMASHES BUF,
1586                                            ;MUST BE AT A LOWER ADDRESS
1587                                            ;THAN DSCTMP OR ASSIGMENT OF STRING
1588                                            ;VALUES IN DIRECT STATEMENTS WON'T COPY
1589                                            ;INTO STRING SPACE -- WHICH IT MUST
1590 IFN      LPTSW,<  
1591 LPTPOS:  BLOCK    1                        ;POSITION OF LPT PRINT HEAD
1592 PRTFLG:  BLOCK    1>                       ;WHETHER OUTPUT GOES TO LPT
1593                                            ;NON-ZERO MEANS SEND OUTPUT TO LPT
1594 IFN      CONTRW,< 
1595 CNTWFL:  BLOCK    1>                       ;SUPRESS OUTPUT FLAG
1596 DIMFLG:  BLOCK    1                        ;IN GETTING A POINTER TO A VARIABLE
1597                                            ;IT IS IMPORTANT TO REMEMBER WHETHER IT
1598                                            ;IS BEING DONE FOR "DIM" OR NOT
1599                                            ;DIMFLG AND VALTYP MUST BE
1600                                            ;CONSECUTIVE LOCATIONS
1601 IFN      STRING,< 
1602 VALTYP:  BLOCK    1                        ;THE TYPE INDICATOR
1603                                            ;IN THE 8K 0=NUMERIC 1=STRING
1604 OPRTYP:                                    ;USED TO STORE OPERATOR NUMBER
1605                                            ;IN THE EXTENDED MOMENTARILY BEFORE
1606                                            ;OPERATOR APPLICATION
1607 DORES:   BLOCK    1                        ;WHETHER CAN OR CANET CRUNCH RES'D WORDS
1608                                            ;TURNED ON IN THE 8K WHEN "DATA"
1609                                            ;BEING SCANNED BY CRUNCH SO UNQUOTED
1610                                            ;STRINGS WON'T BE CRUNCHED.
1611 MEMSIZ:  BLOCK    2                        ;HIGHEST LOCATION IN MEMORY
1612 TEMPPT:  BLOCK    2                        ;POINTER AT FIRST FREE TEMP DESCRIPTOR
1613                                            ;INITIALIZED TO POINT TO TEMPST
1614 TEMPST:  BLOCK    STRSIZ*NUMTMP            ;STORAGE FOR NUMTMP TEMP DESCRIPTORS
1615 DSCTMP:  BLOCK    STRSIZ                   ;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
1616 FRETOP:  BLOCK    2>                       ;TOP OF STRING FREE SPACE
1617 IFN      LENGTH!STRING,<
1618 TEMP3:   BLOCK    2>                       ;USED TO HOLD VARB # OF HIGH LOC FOUND
1619                                            ;IN GARBAGE COLLECTION
1620                                            ;AND USED MOMENTARILY BY FRMEVL
1621                                            ;USED IN EXTENDED BY FOUT
1622                                            ;ARRAY VARIABLE HANDLING TEMPORARY
1623 IFN      LENGTH,< 
1624 DATLIN:  BLOCK    2                        ;DATA LINE REMEMBER FOR ERRORS
1625 SUBFLG:  BLOCK    1>                       ;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED
1626                                            ;"FOR" AND USER-DEFINED FUNCTION
1627                                            ;POINTER FETCHING TURN
1628                                            ;THIS ON BEFORE CALLING PTRGET
1629                                            ;SO ARRAYS WON'T BE DETECTED.
1630                                            ;STKINI AND PTRGET CLEAR IT.
1631 FLGINP:  BLOCK    1                        ;FLAGS WHETHER WE ARE DOING INPUT
1632                                            ;OR A READ
1633 TEMP:    BLOCK    2                        ;TEMPORARY FOR STATEMENT CODE
1634                                            ;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C
1635                                            ;"LET" SAVES NUMBERIC VARIABLE
1636                                            ;POINTERS HERE FOR "FOR"
1637                                            ;"NEXT" SAVES ITS TEXT POINTER HERE
1638                                            ;CLEARC SAVE [H,L) HERE
1639 TEMP2:   BLOCK    2                        ;FORMULA EVALUATOR TEMP
1640                                            ;MUST BE PRESERVED BY OPERATORS
1641                                            ;USED IN EXTENDED BY FOUT
1642                                            ;ARRAY VARIABLE HANDLER TEMPORARY
1643 CURLIN:  BLOCK    2                        ;CURRENT LINE
1644                                            ;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
1645 IFN      LENGTH,< 
1646 OLDLIN:  BLOCK    2                        ;OLD LINE NUMBER
1647 OLDTXT:  BLOCK    2>                       ;OLD TEXT POINTER
1648                                            ;POINTS AT STATEMENT TO BE EXECUTED NEXT
1649 STKTOP:  BLOCK    2                        ;TOP LOCATION TO USE FOR THE STACK
1650                                            ;INITIALLY SET UP BY INIT
1651                                            ;ACCORDING TO MEMORY SIZE
1652                                            ;TO ALLOW FOR 50 BYTES OF STRING SPACE,
1653                                            ;CHANGED BY A CLEAR COMMAND WITH
1654                                            ;AN ARGUMENT.
1655 TXTTAB:  BLOCK    2                        ;POINTER TO BEGINNING OF TEXT
1656                                            ;DOESNET CHANGE AFTER BEING
1657                                            ;SETUP BY INIT.
1658 VARTAB:  BLOCK    2                        ;POINTER TO START OF SIMPLE
1659                                            ;VARIABLE SPACE
1660                                            ;UPDATED WHENEVER THE SIZE OF THE
1661                                            ;PROGRAM CHANGES, SET TO [TXTTAB]
1662                                            ;BY SCRATCH ("NEW")
1663 ARYTAB:  BLOCK    2                        ;POINTER TO BEGINNING OF ARRAY
1664                                            ;TABLE
1665                                            ;INCREMENTED BY 6 WHENEVER
1666                                            ;A NEW SIMPLE VARIABLE IS FOUND, AND
1667                                            ;SET TO [VARTAB] BY CLEARC.
1668 STREND:  BLOCK    2                        ;END OF STORAGE IN USE
1669                                            ;INCREASED WHENEVER A NEW ARRAY
1670                                            ;OR SIMPLE VARIABLE IS ENCOUNTERED
1671                                            ;SET TO [VARTAB] BY CLEARC.
1672 DATPTR:  BLOCK    2                        ;POINTER TO DATA. INITIALIZED TO POINT
1673                                            ;AT THE ZERO IN FRONT OF [TXTTAB]
1674 IFE      LENGTH-2,<
1675 TRCFLG:  BLOCK    1>                       ;0 MEANS NO TRACE IN PROGRESS
1676 
1677                                            ;THE FLOATING ACCUMULATOR
1678 IFE      LENGTH-2,<
1679          BLOCK    1                        ;[TEMPORARY LEAST SIGNIFICANT BYTE]
1680 DFACLO:  BLOCK    4>                       ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
1681 FACLO:   BLOCK    3                        ;[LOW ORDER OF MANTISSA]
1682                                            ;[MIDDLE ORDER OF MANTISSA]
1683                                            ;[HIGH ORDER OF MANTISSA]
1684 FAC:     BLOCK    2                        ;[EXPONENT]
1685                                            ;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
1686 IFE      LENGTH-2 <        
1687          BLOCK    1                        ;[TEMPORARY LEAST SIGNIFICANT BYTE]
1688 ARGLO:   BLOCK    7                        ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
1689 ARG: BLOCK 1> ; PRECISION]
1690 FBUFFR:  BLOCK    13                       ;BUFFER FOR FOUT
1691 IFE      LENGTH-2,<BLOCK 35-13>   
1692 PAGE     
1693 SUBTTL   TEXT CONSTANTS FOR PRINT OUT
1694 ; 
1695 ; NEEDED FOR MESSAGES IN ALL VERSIONS
1696 ; MUST BE STORED ABOVE DSCTMP OR ELSE STRLIT
1697 ; WILL COPY THEM BEFORE STRPRT PRINTS THEM. THIS IS BAD, SINCE IF THE
1698 ; USER IS OUT OF STRING SPACE
1699 ; ERRORS.
1700 ; 
1701 IFN      LENGTH-2,<
1702 ERR:     DC" ERROR"
1703          0>       
1704 INTXT:   DC" IN "
1705 
1706 
1707 
1708 
1709          0        
1710 REDDY:   ACRLF    
1711 
1712          DC"OK"
1713 
1714 
1715          ACRLF    
1716 
1717          0        
1718 IFN      LENGTH,< 
1719 BRKTXT:  ACRLF    
1720 
1721          DC"BREAK"
1722 
1723 
1724 
1725 
1726 
1727          0>       
1728 
1729 PAGE     
1730 SUBTTL   GENERAL STORAGE MANAGEMENT ROUTINES
1731 ; 
1732 ; FIND A FOR ENTRY ON THE STACK WITH THE VARIABLE POINTER
1733 ; PASSED IN [D,E].
1734 ; 
1735 FNDFOR:  LXI      H,4+$CODE                ;IGNORING EVERYONES "NEWSTT"
1736 
1737 
1738                                            ;AND THE RETURN ADDRESS OF THIS
1739          DAD      SP                       ;SUBROUTINE, SET [H,L]=SP
1740 LOOPER:  MOV      A,M                      ;SEE WHAT TYPE OF THING IS ON THE STACK
1741          INX      H        
1742          CPI      FORTK                    ;IS THIS STACK ENTRY A FOR?
1743 
1744          RNZ                               ;NO SO OK
1745 IFE      LENGTH,< 
1746          PUSHM                             ;GET VARIABLE NAME
1747          XTHL>    
1748 IFN      LENGTH,< 
1749          MOV      C,M      
1750          INX      H                        ;DO EQUIVALENT OF PUSHM / XTHL
1751          MOV      B,M      
1752          INX      H        
1753          PUSH     H                        ;PUT H ON
1754          MOV      L,C                      ;PUSH B / XTHL IS SLOWER
1755          MOV      H,B      
1756          MOV      A,D                      ;FOR THE "NEXT" STATMENT WITHOUT AN ARGUMENT
1757          ORA      E                        ;WE MATCH ON ANYTHING
1758          XCHG                              ;MAKE SURE WE RETURN [D,E]
1759          JZ       POPGOF                   ;POINTING TO THE VARIABLE
1760 
1761 
1762          XCHG>    
1763          COMPAR   
1764 POPGOF:  LXI      B,$CODE+13               ;TO WIPE OUT A FOR ENTRY
1765 
1766 
1767          POP      H        
1768          RZ                                ;IF FOR MATCHES GOOD
1769          DAD      B        
1770          JMP      LOOPER                   ;TRY THE NEXT ONE
1771 
1772 
1773 ; 
1774 ; THIS IS THE BLOCK TRANSFER ROUTINE
1775 ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
1776 ; 
1777 ; [H,L] = DESTINATION OF HIGH ADDRESS
1778 ; [D,E] = LOW ADDRESS TO BE TRANSFERRED
1779 ; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
1780 ; 
1781 ; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
1782 ; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND THE HIGHEST LOCATION -
1783 ; TRANSFERRED INTO
1784 ; 
1785 ; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
1786 ; 
1787 
1788 BLTU:    CALL     REASON                   ;CHECK DESTINATION TO MAKE
1789 
1790 
1791                                            ;SURE THE STACK WON'T BE OVERRUN
1792 BLTUC:   PUSH     B                        ;EXCHANGE [B,C] AND [H,L]
1793          XTHL     
1794          POP      B        
1795 BLTLOP:  COMPAR                            ;SEE IF WE ARE DONE
1796          MOV      A,M                      ;GET THE WORD TO TRANSFER
1797          STAX     B                        ;TRANSFER IT
1798          RZ       
1799          DCX      B        
1800          DCX      H                        ;BACKUP FOR NEXT GUY
1801          JMP      BLTLOP   
1802 
1803 
1804 ; 
1805 ; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
1806 ; OF LOCATIONS REMAIN AVAILABLE FOR THE
1807 ; STACK. THE CALL IS :
1808 ;       CALL    GETSTK
1809 ;       NUMBER OF 2 BYTE ENTRIES NECESSARY
1810 ; 
1811 ; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
1812 ; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
1813 ; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
1814 ; IT IS ALSO CALLED BY ROUTINES SUCH AS GOSUB AND FOR
1815 ; WHICH MAKE PERMANENT ENTRIES ON THE STACK
1816 ; 
1817 ; 
1818 ; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
1819 ; NUMLEY STACK LOCATIONS NEED NOT CALL THIS
1820 ; 
1821 GETSTK:  XTHL     
1822          MOV      C,M                      ;GET ARGUMENT INTO [C]
1823 
1824          INX      H        
1825          XTHL                              ;PUT BACK RETURN ADDRESS
1826          PUSH     H                        ;SAVE [H,L]
1827          LHLD     STREND   
1828 
1829 
1830          MVI      B,0      
1831 
1832          DAD      B        
1833          DAD      B                        ;SEE IF WE CAN HAVE THIS MANY
1834          CALL     REASON   
1835 
1836 
1837          POP      H                        ;RESTORE [H,L]
1838          RET      
1839 
1840 ; 
1841 ; [H,L]= SOME ADDRESS
1842 ; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
1843 ; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
1844 ; 
1845 
1846 REASON:  PUSH     D                        ;SAVE [D,E]
1847          XCHG                              ;PUT [H,L] IN [D,E]
1848          LXI      H,$CODE+65536-2*NUMLEV   ;SETUP OFFSET OF GUARANTEED
1849 
1850 
1851                                            ;LOCATIONS
1852          DAD      SP                       ;[H,L]=STACK POINTER + OFFSET
1853          COMPAR                            ;SEE IF THIS IS GT. ENTERING [H,L]
1854          XCHG                              ;RESTORE [H,L] FROM [D,E]
1855          POP      D                        ;GET [D,E] BACK
1856          RNC                               ;WAS OK?
1857 OMERR:   MVI      E,ERROM                  ;"OUT OF MEMORY"
1858 
1859 IFE      LENGTH,< 
1860          XWD      ^O1000,1>                ;"LXI B," OVER THE NEXT 2
1861 IFN      LENGTH,< 
1862          JMP      ERROR>   
1863 
1864 
1865 PAGE     
1866 SUBTTL   ERROR HANDLER, READY, COMPACTIFICATION, NEW, CLEAR, MAIN
1867 IFN      LENGTH,< 
1868 DATSNE:  LHLD     DATLIN                   ;GET DATA LINE
1869 
1870 
1871          SHLD     CURLIN>                  ;MAKE IT CURRENT LINE
1872 
1873 
1874 SNERR:   MVI      E,ERRSN                  ;"SYNTAX ERROR"
1875 
1876          XWD      ^O1000,1                 ;"LXI B," OVER THE NEXT 2
1877 DV0ERR:  MVI      E,ERRDV0                 ;DIVISION BY ZERO
1878 
1879 IFN      LENGTH,< 
1880          XWD      ^O1000,1                 ;SKIP NEXT TWO
1881 NFERR:   MVI      E,ERRNF>                 ;"NEXT WITHOUT FOR" ERROR
1882 
1883 ERROR:   CALL     STKINI                   ;RESET THE STACK AND FLAGS
1884 
1885 
1886 IFN      CONTRW,< 
1887          XRA      A        
1888          STA      CNTWFL>                  ;FORCE OUTPUT
1889 
1890 
1891          CALL     CRDO                     ;CRLF
1892 
1893 
1894          LXI      H,ERRTAB                 ;GET START OF ERROR TABLE
1895 
1896 
1897 IFE      LENGTH-2,<
1898 LEPSKP:  CALL     REM                      ;SKIP AN ERROR MESSAGE
1899 
1900 
1901          DCR      E                        ;DECREMENT ERROR COUNT
1902          INX      H                        ;SKIP OVER THIS ERROR MESSAGE
1903          JNZ      LEPSKP>                  ;SKIP SOME MORE
1904 
1905 
1906 IFN      LENGTH-2,<
1907          MOV      D,A                      ;GET ZERO INTO D
1908          MVI      A,"?"                    ;START OF ERROR MESSAGE
1909          OUTCHR                            ;TYPE IT
1910          DAD      D                        ;ADD IN ERROR CODE
1911          MOV      A,M                      ;GET FIRST ERROR CHARACTER
1912          OUTCHR                            ;TYPE IT
1913          CHRGET                            ;GET 2ND CHARACTER OF ERROR CODE
1914          OUTCHR                            ;TYPE IT
1915          LXI      H,ERR>                   ;GET POINTER TO " ERROR"
1916 ERRFIN:  CALL     STROUT                   ;TYPE IT
1917 
1918 
1919          LHLD     CURLIN                   ;CURRENT LINE #
1920 
1921 
1922          MOV      A,H                      ;SEE IF IN DIRECT MODE
1923          ANA      L        
1924          INR      A                        ;ZERO SAYS DIRECT MODE
1925          CNZ      INPRT                    ;PRINT LINE NUMBER IN [H,L]
1926 
1927 
1928 IFE      LENGTH,< 
1929          XWD      ^O1000,1                 ;"LXI B," OVER THE NEXT 2
1930 END:     
1931 STOP:    RNZ                               ;MAKE SURE HE TERMINATED IT
1932 STPEND:  POP      B                        ;GET RID OF "NEWSTT" RETURN ADDRESS
1933          ENDCON:> 
1934 IFE      LENGTH-2,<
1935 ; 
1936 ; FOR "LIST" COMMAND STOPPING
1937 ; 
1938          XWD      ^O1000,^O76              ;SKIP THE NEXT BYTE
1939 STPRDY:  POP      B>       
1940 READY:   IFN      LPTSW,<  
1941          CALL     FINLPT>                  ;PRINT ANY LEFT OVERS
1942 IFN      CONTRW,< 
1943          XRA      
1944          STA      CNTWFL>                  ;FORCE OUTPUT
1945 
1946 
1947          LXI      H,$CODE+65535
1948 
1949 
1950          SHLD     CURLIN                   ;SETUP CURLIN FOR DIRECT MODE
1951 
1952 
1953          LXI      H,REDDY                  ;"READY" CRLF CRLF
1954 
1955 
1956 REPINI:  CALL     INIT                     ;PRINT IT, REPLACED BY CALL STROUT
1957 
1958 
1959                                            ;BY THE INIT CODE. THIS IS HERE SO AFTER
1960                                            ;ERRORS DURING INIT, INIT IS RESTARTED
1961 MAIN:    CALL     INLIN                    ;GET A LINE FROM TTY
1962 
1963 
1964          CHRGET                            ;GET THE FIRST
1965          INR      A                        ;SEE IF 0 SAVING THE CARRY FLAG
1966          DCR      A        
1967          JZ       MAIN                     ;IF SO, A BLANK LINE WAS INPUT
1968 
1969 
1970          PUSH     PSW                      ;SAVE STATUS INDICATOR FOR 1ST CHARACTER
1971          CALL     LINGET                   ;READ IN A LINE #
1972 
1973 
1974          PUSH     D                        ;SAVE LINE #
1975          CALL     CRUNCH                   ;CRUNCH THE LINE DOWN
1976 
1977 
1978          MOV      B,A                      ;A=0 AFTER CRUNCH, [B,C]=CHAR COUNT FOR NODEL
1979          POP      D                        ;RESTORE LINE #
1980          POP      PSW                      ;WAS THERE A LINE #?
1981          JNC      GONE                     ;IF NOT ITS A DIRECT STATEMENT
1982 
1983 
1984          PUSH     D        
1985          PUSH     B                        ;SAVE LINE # AND CHARACTER COUNT
1986          CHRGET                            ;REMEMBER IF THIS LINE IS
1987          PUSH     PSW                      ;BLANK SO WE DON'T INSERT IT
1988          CALL     FNDLIN                   ;GET A POINTER TO THE LINE
1989 
1990 
1991          PUSH     B                        ;SAVE THE POINTER
1992 IFE      LENGTH-2,<
1993          CC       DEL>                     ;DELETE THE LINE
1994 
1995 
1996 IFN      LENGTH-2,<
1997          JNC      NODEL                    ;NO MATCH SO DON'T DELETE
1998          XCHG                              ;[D,E] NOW HAS THE POINTER TO THE LINE
1999                                            ;BEYOND THIS ONE
2000          LHLD     VARTAB                   ;COMPACTIFYING TO VARTAB
2001 MLOOP:   LDAX     D        
2002          STAX     B                        ;SHOVING DOWN TO ELIMINATE A LINE
2003          INX      B        
2004          INX      D        
2005          COMPAR   
2006          JNC      MLOOP                    ;DONE COMPACTIFYING?
2007          MOV      H,B      
2008          MOV      L,C      
2009          INX      H                        ;NEW VARTAB
2010          SHLD     VARTAB>  
2011 NODEL:   POP      D                        ;POP POINTER AT PLACE TO INSERT
2012          POP      PSW                      ;SEE IF THIS LINE HAD
2013                                            ;ANYTHING ON IT
2014          JZ       FINI                     ;IF NOT DON'T INSERT
2015 
2016 
2017          LHLD     VARTAB                   ;CURRENT END
2018 
2019 
2020          XTHL                              ;[H,L]=CHARACTER COUNT. VARTAB
2021                                            ;ONTO THE STACK
2022          POP      B                        ;[B,C]=OLD VARTAB
2023          DAD      B        
2024          PUSH     H                        ;SAVE NEW VARTAB
2025          CALL     BLTU     
2026 
2027 
2028          POP      H                        ;POP OFF VARTAB
2029          SHLD     VARTAB                   ;UPDATE VARTAB
2030 
2031 
2032          XCHG     
2033          MOV      M,H                      ;FOOL CHEAD WITH NON-ZERO LINK
2034          INX      H                        ;SO IT DOESN'T THINK
2035                                            ;THIS LINK IS THE
2036                                            ;END OF THE PROGRAM
2037          INX      H        
2038          POP      D                        ;GET LINE # OFF STACK
2039          MOV      M,E      
2040          INX      H                        ;PUT DOWN LINE #
2041          MOV      M,D      
2042          INX      H        
2043 
2044          LXI      D,BUF                    ;MOVE LINE FROM BUF TO PROGRAM AREA
2045 
2046 
2047 MLOOPR:  LDAX     D                        ;NOW TRANSFERING LINE
2048                                            ;IN FROM BUF
2049          MOV      M,A      
2050          INX      H        
2051          INX      D        
2052          ORA      A                        ;ZERO MARKS THE END
2053          JNZ      MLOOPR   
2054 
2055 
2056 FINI:    CALL     RUNC                     ;DO CLEAR & SET UP STACK
2057 
2058 
2059                                            ;FALSO SETS [H,L] TO (TXTTAB)-1
2060          INX      H        
2061 ; 
2062 ; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
2063 ; UP ALL THE LINKS. THE END OF EACH
2064 ; LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
2065 ; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
2066 ; 
2067 CHEAD:   MOV      D,H      
2068          MOV      E,L      
2069          MOV      A,M                      ;SEE IF END OF CHAIN
2070          INX      H                        ;BUMP POINTER
2071          ORA      M                        ;2ND BYTE
2072          JZ       MAIN                     ;DONE
2073 
2074 
2075          INX      H                        ;FIX H TO START OF TEXT
2076          INX      H        
2077          INX      H        
2078          XRA      A                        ;SEARCHING FOR A ZERO IN MEMORY
2079 CZLOOP:  CMP      M                        ;TO MARK THE END OF THIS LINE
2080          INX      H                        ;BUMP POINTER
2081          JNZ      CZLOOP                   ;END OF LINE
2082 
2083 
2084          XCHG                              ;SWITCH TEMP
2085          MOV      M,E                      ;DO FIRST BYTE OF FIXUP
2086          INX      H                        ;ADVANCE POINTER
2087          MOV      M,D                      ;2ND BYTE OF FIXUP
2088          XCHG                              ;AND BACK AGAIN
2089          JMP      CHEAD                    ;KEEP CHAINING TIL DONE
2090 
2091 
2092 IFE      LENGTH-2,<
2093 ; 
2094 ; SCNLIN SCANS A LINE RANGE OF
2095 ; THE FORM #-# OR # OR #- OR -# OR BLANK
2096 ; AND THEN FINDS THE FIRST LINE IN THE RANGE
2097 ; 
2098 SCNLIN:  LXI      D,$CODE                  ;ASSUME START LIST AT ZERO
2099 
2100 
2101          PUSH     D                        ;SAVE INITIAL ASSUMPTION
2102          JZ       ALLLST                   ;IF FINISHED, LIST IT ALL
2103 
2104 
2105          POP      D                        ;WE ARE GOING TO GRAB A #
2106          CALL     LINGET                   ;GET A LINE #. IF NONE, RETURNS ZERO
2107 
2108 
2109          PUSH     D                        ;SAVE FIRST
2110          JZ       ONELIN                   ;IF ONLY # THEN DONE.
2111 
2112 
2113          SYNCHK   MINUTK                   ;MUST BE A DASH,
2114 
2115 ALLLST:  LXI      D,$CODE+^D65529          ;ASSUME MAX END OF RANGE
2116 
2117 
2118          CNZ      LINGET                   ;GET THE END OF RANGE
2119 
2120 
2121          JNZ      SNERR                    ;MUST BE TERMINATOR
2122 
2123 
2124 ONELIN:  XCHG                              ;[H,L] = FINAL
2125          POP      D                        ;GET INITIAL IN [D,E]
2126          XTHL                              ;PUT MAX ON STACK, RETURN ADDR TO [H,L]
2127          PUSH     H>                       ;SAVE RETURN ADDRESS BACK
2128 ; 
2129 ; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
2130 ; WHOSE LINE # IS PASSED IN [D,E], [D,E] IS PRESERVED.
2131 ; THERE ARE THREE POSSIBLE RETURNS:
2132 ; 
2133 ;       1) ZERO FLAG SET. CARRY NOT SET. LINE NOT FOUND.
2134 ;          NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
2135 ;          [B,C POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
2136 ;          [H,L]=[B,C]
2137 ; 
2138 ;       2) ZERO, CARRY SET.
2139 ;          [B,C] POINTS TO THE LINK FIELD IN THE LINE
2140 ;          WHICH IS THE LINE SEARCHED FOR.
2141 ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
2142 ; 
2143 ;       3) NON-ZERO, CARRY NOT SET.
2144 ;          LINE NOT FOUND, [B,C] POINTS TO LINE IN PROGRAM
2145 ;          GREATER THAN ONE SEARCHED FOR.
2146 ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
2147 ; 
2148 FNDLIN:  LHLD     TXTTAB                   ;GET POINTER TO START OF TEXT
2149 
2150 
2151 LOOP:    MOV      B,H                      ;IF EXITING BECAUSE OF END OF PROGRAM,
2152                                            ;SET [B,C] TO POINT TO DOUBLE ZEROES.
2153          MOV      C,L      
2154          MOV      A,M                      ;GET WORD POINTER TO
2155          INX      H                        ;BUMP POINTER
2156          ORA      M                        ;GET 2ND BYTE
2157          DCX      H                        ;GO BACK
2158          RZ                                ;IF ZERO THEN DONE
2159          PUSH     B        
2160          PUSHM                             ;PUSH LINK
2161          PUSHM                             ;PUSH BINARY LINE #
2162          POP      H                        ;POP HERE
2163          COMPAR                            ;COMPARE [D,E) TO [H,L]
2164          POP      H                        ;GET LINK
2165          POP      B                        ;GET POINTER TO THIS LINE IN [B,C]
2166          CMC                               ;TURN CARRY ON
2167          RZ                                ;EQUAL RETURN
2168          CMC                               ;MAKE CARRY ZERO
2169          RNC                               ;NO MATCH RETURN (GREATER)
2170          JMP      LOOP                     ;KEEP LOOPING
2171 
2172 
2173 ; 
2174 ; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
2175 ; AS VARIABLE SPACE
2176 ; 
2177 SCRATH:  RNZ                               ;MAKE SURE THERE IS A TERMINATOR
2178 SCRTCH:  LHLD     TXTTAB   
2179 
2180 
2181 IFN      LENGTH-2,<
2182          XRA      A>       
2183 IFE      LENGTH-2,<
2184          CALL     TUFF>                    ;TURN OFF TRACE, SET [A]=0.
2185 
2186 
2187          MOV      M,A                      ;SAVE AT END OFF TEXT
2188          INX      H                        ;BUMP POINTER
2189          MOV      M,A                      ;SAVE ZERO
2190          INX      H                        ;BUMP POINTER
2191          SHLD     VARTAB                   ;NEW START OF VARIABLE
2192 
2193 
2194 IFE      LENGTH,< 
2195 RUN:     RNZ>                              ;CHECK FOR A TERMINATOR
2196 RUNC:    LHLD     TXTTAB                   ;POINT AT THE START OF TEXT
2197 
2198 
2199          DCX      H        
2200 ; 
2201 ; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
2202 ; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
2203 ; AND STREND (THE END OF ARRAY STORAGE), IT FALLS INTO STKINI
2204 ; WHICH RESETS THE STACK. [H,L] IS PRESERVED.
2205 ; 
2206 IFE      STRING,<CLEAR:>
2207 CLEARC:  SHLD     TEMP                     ;SAVE [H,L] IN TEMP
2208 
2209 
2210 IFN      STRING,< 
2211          LHLD     MEMSIZ   
2212 
2213 
2214          SHLD     FRETOP>                  ;FREE UP STRING SPACE
2215 
2216 
2217          CALL     RESTORE                  ;RESTORE DATA
2218 
2219 
2220          LHLD     VARTAB                   ;GET START OF VARIABLE SPACE
2221 
2222 
2223          SHLD     ARYTAB                   ;SAVE IN START OF ARRAY SPACE
2224 
2225 
2226          SHLD     STREND                   ;AND END OF VARIABLE STORAGE
2227 
2228 
2229 ; 
2230 ; STKINI RESETS THE STACK POINTER ELIMINATING
2231 ; GOSUB & FOR CONTEXT. STRING TEMPORARIES ARE FREED
2232 ; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
2233 ; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
2234 ; FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
2235 ; OF THE STACK. [A] AND [D,E] IS PRESERVED.
2236 ; 
2237 STKINI:  POP      B                        ;GET RETURN ADDRESS HERE
2238          LHLD     STKTOP                   ;[H,L] POINTER TO END OF MEMORY
2239 
2240 
2241          SPHL                              ;INITIALIZE STACK
2242 IFN      STRING,< 
2243          LXI      H,TEMPST 
2244 
2245 
2246          SHLD     TEMPPT>                  ;INITIALIZE STRING TEMPORARIES
2247 
2248 
2249          LXI      H,$CODE                  ;PUT ZERO (NON NEXT, FOR, GOSUB TOKEN)
2250 
2251 
2252          PUSH     H                        ;ON STACK
2253 IFN      LENGTH,<SHLD OLDTXT>              ;MAKE CONTINUING ILLEGAL
2254 
2255 
2256 IFN      LPTSW,<  
2257          CALL     FINLPT>  
2258          LHLD     TEMP                     ;GET SAVED [H,L]
2259 
2260 
2261 IFN      LENGTH,< 
2262 IFE      CONTRW,<XRA A>       
2263          STA      SUBFLG>                  ;ALLOW SUBSCRIPTS
2264 
2265 
2266          PUSH     B                        ;PUT RETURN ADDRESS BACK ON
2267          RET                               ;GO BACK
2268 
2269 QINLIN:  MVI      A,"?"                    ;GET A QMARK
2270 
2271          OUTCHR                            ;TYPE IT
2272          MVI      A," "                    ;SPACE
2273 
2274          OUTCHR                            ;TYPE IT TOO
2275 IFE      STRING,<CALL INLIN                ;IN THE NON-STRING VERSIONS ALL
2276                                            ;INPUT IS CRUNCHED
2277          INX      H>                       ;GET A LINE OF INPUT FROM TTY
2278 IFN      STRING,<JMP INLIN>                ;NO CRUNCHING IN THIS CASE
2279 
2280 
2281 ; 
2282 ; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
2283 ; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
2284 ; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
2285 ; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
2286 ; RESERVED WORD LIST IN THE SAME I
2287 ; ORDER THEY APPEAR IN IN STMDSP.
2288 ; 
2289 CRUNCH:  IFN      STRING,< 
2290          XRA      A        
2291          STA      DORES>                   ;ALLOW CRUNCHING
2292 
2293 
2294          MVI      C,5                      ;COUNT OF CHARS AT LEAST 5
2295 
2296          LXI      D,BUF                    ;SETUP DESTINATION POINTER
2297 
2298 
2299 KLOOP:   MOV      A,M                      ;GET CHARACTER FROM BUF
2300          CPI      " "                      ;IS IT A SPACE WE WANT TO SAVE
2301 
2302          JZ       STUFFH                   ;YES, STUFF IN DESTINATION LINE.
2303 
2304 
2305          MOV      B,A                      ;GET A CHARACTER FROM THE LINE
2306                                            ;SETUP B WITH A QUOTE IF IT IS A STRING
2307          CPI      34                       ;QUOTE SIGN?
2308 
2309          JZ       STRNG                    ;YES, GO TO SPECIAL STRING HANDLING
2310 
2311 
2312          ORA      A                        ;END OF LINE?
2313          JZ       CRDONE                   ;YES, DONE CRUNCHING
2314 
2315 
2316 IFN      STRING,< 
2317          LDA      DORES                    ;IN DATA STATEMENT AND NO CRUNCH?
2318 
2319 
2320          ORA      A        
2321          MOV      B,A                      ;INITIALIZE RESERVED WORD COUNT
2322          MOV      A,M                      ;GET THE CHARACTER AGAIN
2323          JNZ      STUFFH>                  ;IF NO CRUNCHING JUST STORE
2324 
2325 
2326                                            ;THE CHARACTER
2327 IFN      LENGTH,<                          ;NOT FOR 4K VERSION
2328          CPI      "?"                      ;A QMARK?
2329 
2330          MVI      A,PRINTK 
2331 
2332          JZ       STUFFH                   ;THEN USE A "PRINT" TOKEN
2333 
2334 
2335          MOV      A,M      
2336          CPI      "0"                      ;SKIP NUMERICS
2337 
2338          JC       MUSTCR                   ;SINCE CRUNCHING IS SLOW
2339 
2340 
2341          CPI      60                       ;":" ALSO PUT IN QUICKLY
2342 
2343          JC       STUFFH   
2344 
2345 
2346 MUSTCR:  >        
2347          PUSH     D                        ;SAVE STORE POINTER
2348 IFE      STRING,< 
2349          MVI      B,0>                     ;INIT RESERVED WORD COUNT
2350          LXI      D,RESLST-1               ;INIT TO RESERVED WORD LIST
2351 
2352 
2353          PUSH     H                        ;SAVE IN BUF POINTER
2354          XWD      ^O1000,^O76              ;"MVI" AROUND CHRGET
2355 NXTRES:  CHRGET                            ;GET CHAR FROM LINE
2356          INX      D                        ;BUMP DEPOSIT POINTER
2357 RESER:   LDAX     D                        ;GET A BYTE FROM RESERVED WORD LIST
2358          ANI      127                      ;GET RID OF SIGN BIT
2359 
2360          JZ       TABEND                   ;END OF RESERVED WORD TABLE
2361 
2362 
2363          CMP      M                        ;TWO CHARS THE SAME?
2364          JNZ      NTHIS                    ;NO, DIFFERENT
2365 
2366 
2367          LOAX     D                        ;GET RESERVED WORD BYTE
2368          ORA      A                        ;SET CONDITION CODES
2369          JP       NXTRES                   ;IF SIGN SET, RESERVED WORD FOUND
2370 
2371 
2372 FOUND:   POP      PSW                      ;TAKE OFF GARBAGE ORIG POINTER
2373          MOV      A,B                      ;GET RESERVED WORD #
2374          ORI      128                      ;SET MSB TO FLAG AS RESERVED WORD
2375 
2376          XWD      ^O1000,^O362             ;"JP" AROUND THE POP H AND MOV A,M
2377 TABEND:  POP      H                        ;GET BACK ORIG POINTER
2378          MOV      A,M                      ;GET BACK ORIG CHAR
2379          POP      D                        ;GET STUFF POINTER BACK
2380 IFE      LENGTH-2,<
2381          XCHG                              ;[H,L]=STUFF POINTER
2382          CPI      ELSETK                   ;HAVE TO PUT A HIDDEN
2383 
2384                                            ;COLON IN FRONT OF "ELSE"S
2385          MVI      M,":"                    ;STORE IT
2386 
2387          CZ       INXHRT##                 ;ADVANCE POINTER ON "ELSE"
2388 
2389 
2390                                            ;SO ONLY ON "ELSE" THE COLON IS NOT OVERWRITTEN
2391 
2392          XCHG>                             ;[D,E]=STUFF POINTER
2393 STUFFH:  INX      H                        ;ENTRY TO BUMP [H,L]
2394          STAX     D                        ;SAVE CHARACTER IN CRUNCHED LINE
2395          INX      D                        ;BUMP SAVE POINTER
2396          INR      C                        ;BUMP CRUNCHED CHARACTER COUNT
2397 IFN      STRING,< 
2398          SUI      ":"                      ;SEE IF IT IS A COLON
2399 
2400          JZ       COLIS                    ;IF SO ALLOW CRUNCHING AGAIN
2401 
2402 
2403          CPI      DATATK-":"
2404 
2405          JNZ      NODATT                   ;SEE IF IT IS A DATA TOKEN
2406 
2407 
2408 COLIS:   STA      DORES                    ;SETUP FLAG
2409 
2410 
2411 NODATT:  SUI      REMTK-":">
2412 
2413 IFE      STRING,<SUI REMTK>                ;WAS IT A REM STATEMENT
2414          JNZ      KLOOP                    ;KEEP LOOPING
2415 
2416 
2417          MOV      B,A                      ;REM DOESN'T STOP ON ":", ONLY ON A ZERO
2418 STR1:    MOV      A,M                      ;GET A CHAR
2419          ORA      A                        ;SET CONDITION CODES
2420          JZ       CRDONE                   ;IF END OF LINE THEN DONE
2421 
2422 
2423          CMP      B                        ;END OF GOBBLE
2424          JZ       STUFFH                   ;IF YES, DONE WITH STRING
2425 
2426 
2427 STRNG:   INX      H                        ;INCREMENT TEXT POINTER
2428          STAX     D                        ;STORE CHAR
2429          INR      C                        ;BUMP COUNT
2430          INX      D                        ;AND POINTER
2431          JMP      STR1                     ;KEEP LOOPING
2432 
2433 
2434 
2435 NTHIS:   POP      H                        ;RESTORE TEXT STRING
2436          PUSH     H                        ;AND SAVE IT BACK
2437          INR      B                        ;INCREMENT RESERVED WORD #
2438          XCHG                              ;RESLST POINTER INTO [H,L]
2439 NTHIS1:  ORA      M                        ;TEST BITS IN RESERVED WORD LIST
2440          INX      H        
2441          JP       NTHIS1                   ;SKIP MORE
2442 
2443 
2444          XCHG                              ;RESLST POINTER INTO [D,E]
2445                                            ;TEXT POINTER INTO [H,L]
2446          JMP      RESER                    ;DONE, MOVE TO NEXT RESERVED WORD
2447 
2448 
2449 CRDONE:  LXI      H,BUFMIN                 ;LEAVE WITH [H,L] POINTER TO START OF LINE
2450 
2451 
2452          STAX     D                        ;NEED THREE 0'S ON THE END
2453          INX      D                        ;ONE FOR END-OF-LINE
2454          STAX     D                        ;AND 2 FOR A ZERO LINK
2455          INX      D                        ;SINCE IF THIS IS A DIRECT STATEMENT
2456          STAX     D                        ;ITS END MUST LOOK LIKE THE END OF A PROGRAM
2457          RET                               ;END OF CRUNCHING
2458 ; 
2459 ; THIS IS THE LINE INPUT ROUTINE
2460 ; IT READS CHARACTERS INTO BUF USING AS THE
2461 ; CHARACTER DELETE CHARACTER AND @ AS THE LINE DELETE CHARACTER
2462 ; IF MORE THAN BUFLEN CHARACTER ARE TYPED, NO ECHOING
2463 ; IS DONE UNTIL A . OR CARRIAGE-RETURN IS TYPED.
2464 ; CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
2465 ; THE ROUTINE IS ENTERED AT INLIN
2466 ; 
2467 LINLIN:  DCR      B                        ;BACK ARROW SO DECREMENT COUNT
2468          DCX      H                        ;BACK UP POINTER
2469 IFN      REALIO,< 
2470          OUTCHR>  
2471          JNZ      INLINC                   ;NOT TOO MANY SO CONTINUE
2472 
2473 
2474 INLINN:  IFN      REALIO,< 
2475          OUTCHR>                           ;PRINT THE @, OR A SECOND IF THERE
2476                                            ;WERE TOO MANY
2477          CALL     CRDO                     ;TYPE A CRLF
2478 
2479 
2480 INLIN:   LXI      H,BUF    
2481 
2482 
2483          MVI      B,1                      ;CHARACTER COUNT
2484 
2485 INLINC:  CALL     INCHR                    ;GET A CHARACTER
2486 
2487 
2488 IFN      LENGTH,< 
2489          CPI      7                        ;IS IT BOB ALBRECHT RINGING THE BELL
2490 
2491          JZ       GOODCH>                  ;FOR SCHOOL KIDS?
2492 
2493 
2494          CPI      13                       ;IS IT A CARRIAGE RETURN?
2495 
2496          JZ       FININL                   ;IF SO FINISH UP
2497 
2498 
2499          CPI      32                       ;CHECK FOR FUNNY CHARACTERS
2500 
2501          JC       INLINC   
2502 
2503 
2504          CPI      125      
2505 
2506          JNC      INLINC                   ;BIG ONES BAD TOO
2507 
2508 
2509          CPI      "@"                      ;LINE DELETE?
2510 
2511          JZ       INLINN   
2512 
2513 
2514          CPI      "+"                      ;CHARACTER DELETE?
2515 
2516          JZ       LINLIN   
2517 
2518 
2519 GOODCH:  MOV      C,A      
2520          MOV      A,B      
2521          CPI      BUFLEN   
2522 
2523          MVI      A,7                      ;GET A BELL IN CASE LINE TOO LONG.
2524 
2525          JNC      OUTBEL                   ;LINE TOO LONG, RING BELL.
2526 
2527 
2528          MOV      A,C      
2529          MOV      M,C                      ;STORE THIS CHARACTER
2530          INX      H        
2531          INR      B        
2532 OUTBEL:  
2533 IFN      REALIO,< 
2534          OUTCHR>  
2535          JMP      INLINC   
2536 
2537 
2538 OUTCON:  
2539 IFN      CONTRW,< 
2540          JNZ      PPSWRT>                  ;NO, DO OUTPUT
2541 
2542 
2543 IFN      REALIO,<                          ;MITS I/O
2544 IFN      LPTSW,<  
2545          LDA      PRTFLG                   ;SEE IF WE WANT TO TALK TO LPT
2546          ORA      A                        ;TEST BITS
2547          JZ       TTYCHR                   ;IF ZERO THEN NOT
2548          POP      PSW                      ;GET CHARACTER WE WANT TO PRINT
2549          PUSH     PSW      
2550          CPI      13                       ;IS IT CARRIAGE RETURN?
2551          CZ       PRINTW                   ;FORCE OUT A LINE
2552          JC       PPSWRT                   ;IF FUNNY CONTROL CHARACTER (LF) DO NOTHING
2553          LDA      LPTPOS                   ;WHERE ARE WE?
2554          CPI      LPTLEN                   ;AT THE END?
2555          CNC      PRINTW                   ;YES, START OVER
2556          INR      A        
2557          STA      LPTPOS   
2558 LPTWAT:  IN       2        
2559          ANI      2        
2560          JZ       LPTWAT   
2561          POP      PSW      
2562          OUT      3                        ;SEND OUT CHAR
2563          RET      RETURN   
2564 PATLPT:  BLOCK    20       
2565 FINLPT:  XRA      A                        ;RESET PRINT FLAG SO OUTPUT
2566          STA      PRTFLG                   ;GOES TO THE TERMINAL
2567          LDA      LPTPOS                   ;SEE IF ANY LEFTOVERS MUST BE
2568          ORA      A                        ;FORCED OUT
2569          RZ                                ;BY LOOKING AT LPTPOS
2570 PRINTW:  IN       2                        ;MAKE SURE LAST PRINT
2571          ANI      2                        ;FINISHED BY TESTING DONE
2572          JZ       PRINTW                   ;BIT
2573 ; SEE IF BUFFER MUST BE EMPTIED
2574          LDA      LPTPOS   
2575          ORA      A                        ;CHARACTERS IN THE BUFFER?
2576          JNZ      PRINTR                   ;IF SO DON'T CLEAR THE BUFFER
2577          MVI      A,4                      ;OTHERWISE BUFFER MUST BE EMPTIED
2578          OUT      2                        ;CLEAR THE BUFFER
2579                                            ;TO PRINT A BLANK LINE
2580 PRINTR:  MVI      A,1                      ;TELL LPT TO PRINT
2581          OUT      2                        ;STATUS REG
2582          DCR      A                        ;[A]=0
2583          STA      LPTPOS                   ;RESET LINE PRINT POSITION
2584          RET>     
2585          TTYCHR:> 
2586 IFN      STRING,< 
2587          POP      PSW                      ;GET THE CHARACTER
2588          PUSH     PSW                      ;AND SAVE IT AGAIN
2589          CPI      32                       ;IS THIS A MEANINGFUL CHARACTER?
2590 
2591          JC       TRYOUT>                  ;IF IT'S A NON-PRINTING CHARACTER
2592 
2593 
2594                                            ;DON'T INCLUDE IT IN TTYPOS
2595 IFN      LENGTH!CONTRW!LPTSW,<
2596          LDA      TTYPOS>                  ;SEE IF PRINT HEAD IS AT THE END OF THE LINE
2597 
2598 
2599          CPI      LINLEN                   ;MODIFIED BY "TERMINAL WIDTH?" QUESTION IN INIT
2600 
2601 
2602          LINPT1==:.-1
2603          CZ       CRDO                     ;TYPE CRLF AND SET TTYPOS AND (A)= IF SO
2604 
2605 
2606          INR      A                        ;INCREMENT TTYPOS SINCE WE'RE
2607                                            ;GOING TO PRINT A CHARACTER.
2608          STA      TTYPOS                   ;STORE NEW PRINT HEAD POSITION
2609 
2610 
2611 TRYOUT:  
2612 IFN      REALIO,< 
2613 NOPRIN:  IN       0                        ;GET STATUS
2614 
2615          CNLCA1==.-1                       ;CONSOLE COMMAND CHANGE LOC
2616          ANI      ODONE                    ;0K TO SEND CHAR
2617 
2618          JNZ      NOPRIN>                  ;KEEP LOOPING
2619 
2620 
2621          POP      PSW                      ;GET CHARACTER BACK
2622          OUT      TTOCHN                   ;SEND OUT THE CHAR
2623 
2624          CNLCB1==.-1                       ;CONSOLE COMMAND CHANGE LOC
2625          RET                               ;RETURN FROM OUTCHR
2626 
2627 
2628 INCHR:   IFN      REALIO,< 
2629 TRYIN:   IN       0                        ;GET STATUS
2630 
2631          CNLCA2==.-1                       ;CONSOLE COMMAND CHANGE LOC
2632          ANI      IDONE                    ;TEST BIT
2633 
2634          JNZ      TRYIN>                   ;GO BACK & DO IT AGAIN
2635 
2636 
2637          IN       TTICHN                   ;GET A CHAR
2638 
2639          CNLCB2==.-1                       ;CONSOLE COMMAND CHANGE LOC
2640          ANI      127                      ;GET RID OF PARITY BIT
2641 
2642 IFN      CONTRW,< 
2643          CPI      CONTW                    ;IS IT SUPRESS OUTPUT?
2644 
2645          RNZ      
2646          LDA      CNTWFL   
2647 
2648 
2649          CMA                               ;COMPLEMENT ITS STATE
2650          STA      CNTWFL>                  ;SAVE BACK
2651 
2652 
2653          RET      
2654 PAGE     
2655 SUBTTL   THE "LIST" COMMAND
2656 
2657 IFN      LENGTH-2,<
2658 IFN      LPTSW,<  
2659 LLIST:   MVI      A,1                      ;GET NON ZERO VALUE
2660          STA      PRTFLG>                  ;SAVE IN I/O FLAG
2661 LIST:    CALL     LINGET                   ;GET LINE NUMBER INTO [D,E]
2662          RNZ                               ;MUST BE A TERMINATOR OR ERROR
2663          POP      B                        ;GET RID OF NEWSTI RETURN ADDR
2664          CALL     FNDLIN                   ;FIND LINE GREATER THAN OR EQUAL TO [D,E]
2665          PUSH     B                        ;SAVE START POINTER
2666 LIST4:   POP      H                        ;GET POINTER TO LINE
2667          PUSHM                             ;PUSH LINK
2668          POP      B                        ;TAKE OFF FOR A SECOND
2669          MOV      A,B                      ;SEE IF END OF CHAIN
2670          ORA      C        
2671          JZ       READY    
2672 IFN      LISTEN,< 
2673          CALL     ISCNTC>                  ;CHECK FOR CONTROL-C
2674          PUSH     B                        ;PUT BACK ON
2675          CALL     CRDO                     ;DO CRLF TO START OUT
2676          PUSHM                             ;PUSH LINE #
2677          XTHL                              ;GET LINE # INTO [H,L]
2678                                            ;AND WE WANT [H,L] ON THE STACK
2679          CALL     LINPRT                   ;PRINT AS INT WITOUT LEADING SPACE
2680          MVI      A," "    
2681 PRIT4:   POP      H                        ;RESTORE POINTER TO START OF TEXT
2682 PLOOP:   OUTCHR                            ;ALWAYS A SPACE AFTER THE LINE
2683          MOV      A,M                      ;GET A CHARACTER FROM LINE.
2684          ORA      A                        ;IS IT A RESERVED WORD
2685          INX      H                        ;INCREMENT POINTER INTO TEXT
2686          JZ       LIST4                    ;ZERO, END OF LINE, GET NEXT LINE
2687          JP       PLOOP                    ;REGULAR CHAR, JUST PRINT IT
2688          SUI      127                      ;GET RID OF SIGN BIT AND ADD ONE
2689          MOV      C,A                      ;GET RESERVED WORD # IN C
2690          PUSH     H                        ;SAVE CURRRENT POSIT
2691          LXI      D,RESLST                 ;GET RESLST POINTER.
2692 RESRCH:  PUSH     D                        ;SAVE
2693 
2694 RESCR1:  LDAX     D                        ;GET CHARACTER FROM RESLST
2695          INX      D                        ;BUMP RESLST POINTER
2696          ORA      A                        ;TEST BITS
2697          JP       RESCR1                   ;NOT AT END OF RESERVED WORD YET
2698          DCR      C                        ;DECREMENT CHAR
2699          POP      H                        ;POP START POINTER HERE
2700          JNZ      RESRCH                   ;NOT AT END OF RESLST YET.
2701                                            ;HERE WHEN FOUND RIGHT RESERVED WORD
2702 PRIT3:   MOV      A,M                      ;GET A CHARACTER FROM RESERVED WORD
2703          ORA      A                        ;SET CONDITION CODES
2704          JM       PRIT4    
2705          OUTCHR   
2706          INX      H                        ;BUMP RESLST POINTER
2707          JMP      PRIT3>                   ;PRINT THE REST
2708 
2709 
2710 PAGE     
2711 SUBTTL   "FOR" STATEMENT
2712 ; 
2713 ; NOTE:
2714 ; 
2715 ; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
2716 ; 
2717 ; 
2718 ; LOW ADDRESS
2719 ;       TOKEN (FORTK IN HIGH BYTE) 1 BYTE
2720 ;       A POINTER TO THE LOOP VARIABLE 2 BYTES
2721 ;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
2722 ;       THE STEP 4 BYTES
2723 ;       THE UPPER VALUE 4 BYTES
2724 ;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
2725 ;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
2726 ; HIGH ADDRESS
2727 ; 
2728 ; TOTAL 16 BYTES
2729 ; 
2730 
2731 FOR:     IFN      LENGTH,< 
2732          MVI      A,100    
2733 
2734          STA      SUBFLG>                  ;DONT RECOGNIZE SUBSCRIPTED VARIABLES
2735 
2736 
2737          CALL     LET                      ;READ THE VARIABLE AND ASSIGN IT
2738 
2739 
2740                                            ;THE CORRECT INTIAL VALUE
2741                                            ;AND STORE A POINTER
2742                                            ;TO THE VARIABLE IN (TEMP)
2743          XTHL                              ;SAVE TEXT PTR ON THE STACK
2744          CALL     FNDFOR                   ;MUST HAVE VARIABLE POINTER IN [D,E]
2745 
2746 
2747          POP      D                        ;[D,E]=TEXT POINTER
2748          JNZ      NOTOL                    ;IF NO MATCHING ENTRY, DON'T
2749 
2750 
2751                                            ;ELIMINATE ANYTHING
2752          DAD      B                        ;IN THE CASE OF "FOR"
2753                                            ;WE ELIMINATE THE MATCHING ENTRY
2754                                            ;AS WELL AS EVERYTHING AFTER IT
2755          SPHL                              ;DO THE ELIMINATION
2756                                            ;SINCE A MATCHING ENTRY WAS FOUND
2757 NOTOL:   XCHG                              ;[H,L]=TEXT POINTER
2758          CALL     GETSTK   
2759 
2760 
2761          8                                 ;MAKE SURE 16 BYTES ARE AVAILABLE
2762                                            ;OFF OF THE STACK
2763          PUSH     H                        ;REALLY SAVE THE TEXT POINTER
2764          CALL     DATA                     ;GET AN [H,L] THAT POINTS
2765 
2766 
2767                                            ;JUST BEYOND THE TERMINATOR
2768          XTHL                              ;PUT [H,L] POINTER 10 TERMINATOR ON THE STACK
2769                                            ;AND RESTORE [H,L] AS TEXT POINTER AT
2770                                            ;VARIABLE NAME
2771          PUSH     H                        ;PUSH THE TEXT POINTER ONTO THE STACK
2772          LHLD     CURLIN                   ;[H,L] GET THE CURRENT LINE #
2773 
2774 
2775          XTHL                              ;NOW THE CURRENT LINE # IS ON THE STACK AND
2776                                            ;[H,L] IS THE TEXT POINTER
2777 IFN      LENGTH-2,<
2778 IFN      STRING,<CALL CHKNUM>> 
2779          SYNCHK   TOTK                     ;"TO" IS NECESSARY
2780 
2781 IFN      LENGTH-2,<
2782          CALL     FRMNUM>                  ;READ FINAL VALUE
2783 IFE      LENGTH-2,<
2784          CALL     FRMEVL>  
2785 
2786 
2787          PUSH     H                        ;SAVE THE TEXT POINTER
2788 IFE      LENGTH-2,<
2789          CALL     FRCSNG>  
2790 
2791 
2792          CALL     MOVRF                    ;GET THE STUFF
2793 
2794 
2795          POP      H                        ;REGAIN TEXT POINTER
2796          PUSH     B                        ;OPPOSITE OF PUSHR
2797          PUSH     D                        ;SAVE THE SIGN OF THE INCREMENT
2798          LXI      B,$CODE+^O201*256
2799 
2800 
2801          MOV      D,C      
2802          MOV      E,D                      ;GET 1.0 IN THE REGISTERS
2803          MOV      A,M                      ;GET TERMINATING CHARACTER
2804          CPI      STEPTK                   ;DO WE HAVE "STEP" ?
2805 
2806          MVI      A,1                      ;SETUP DEFAULT SIGN
2807 
2808          JNZ      ONEON                    ;PUSH SOME CONSTANTS ON IF NOT
2809 
2810 
2811 IFN      LENGTH-2,<
2812 IFN      STRING,< 
2813          CHRGET   
2814          CALL     FRMNUM>>                 ;READ THE STEP
2815 IFE      <LENGTH-2>&STRING,<
2816          CALL     FRMCHK>                  ;DON'T NEED TO CHECK THE TYPE
2817 
2818 
2819          PUSH     H        
2820 IFE      LENGTH-2,<
2821          CALL     FRCSNG>  
2822 
2823 
2824          CALL     MOVRF                    ;SET UP THE REGISTERS
2825 
2826 
2827          POP      H        
2828          FSIGN                             ;GET THE SIGN OF THE INCREMENT
2829 ONEON:   PUSH     B                        ;PUT VALUE ON BACKWARDS
2830          PUSH     D                        ;OPPOSITE OF PUSHR
2831 IFORDN:  PUSH     PSW                      ;SAVE THE SIGN OF THE INCREMENT
2832          INX      SP                       ;A ONE BYTE ENTRY ONLY
2833          PUSH     H        
2834          LHLD     TEMP                     ;GET THE POINTER TO THE VARIABLE BACK
2835 
2836 
2837          XTHL                              ;PUT THE POINTER TO THE VARIABLE
2838                                            ;ONTO THE STACK AND RESTORE THE TEXT POINTER
2839 NXTCON:  MVI      B,FORTK                  ;PUT A 'FOR' TOKEN ONTO THE STACK
2840 
2841          PUSH     B        
2842          INX      SP                       ;THE "TOKEN" ONLY TAKES ONE BYTE OF
2843                                            ;STACK SPACE
2844 ; JMP NEWSTT ;ALL DONE
2845 PAGE     
2846 SUBTTL   NEW STATEMENT FETCHER
2847 ; 
2848 ; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]
2849 ; ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS
2850 ; LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO
2851 ; IT CAN MERELY DO A RETURN WHEN IT IS DONE.
2852 ; 
2853 NEWSTT:  
2854 IFN      LISTEN,< 
2855 IFN      LENGTH,< 
2856          IN       0                        ;CHECK FOR A CHARACTER WITHOUT
2857 
2858                                            ;DOING A "CALL" FOR SPEED
2859          CNLCA4==:.-1
2860          ANI      IDONE                    ;CHARACTER THERE?
2861 
2862          CZ       CNTCCN>                  ;SEE IF IT'S CONTROL-C
2863 
2864 
2865 IFE      LENGTH,< 
2866          CALL     ISCNTC   
2867 IFN      LENGTH,< 
2868          SHLD     TEMP>                    ;USED BY CONTINUE AND INPUT AND CLEAR
2869 
2870 
2871                                            ;TO REMEMBER HOW TO RESTART THIS
2872                                            ;STATEMENT
2873 IFN      LPTSW,<XRA A                      ;FORCE PRINT TO GO TO TTY AFTER LPRINT
2874          STA      PRTFLG>  
2875          MOV      A,M                      ;GET CURRENT CHARACTER
2876                                            ;WHICH TERMINATED THE LAST STATEMENT
2877          CPI      ":"                      ;IS IT A COLON?
2878 
2879          JZ       GONE     
2880 
2881 
2882          ORA      A        
2883          JNZ      SNERR                    ;MUST BE A ZERO
2884 
2885 
2886          INX      H        
2887          MOV      A,M                      ;CHECK POINTER TO SEE IF
2888                                            ;IT IS ZERO, IF SO WE ARE AT THE
2889                                            ;END OF THE PROGRAM
2890          INX      H        
2891          ORA      M                        ;OR IN HIGH PART
2892          INX      H        
2893          JZ       ENDCON                   ;RAN OFF THE END -- OK
2894 
2895 
2896          MOV      E,M      
2897          INX      H        
2898          MOV      D,M                      ;GET LINE # IN [0,E]
2899          XCHG                              ;[H,L]=LINE #
2900          SHLD     CURLIN                   ;SETUP CURLIN WITH THE CURRENT LINE #
2901 
2902 
2903 IFE      LENGTH-2,                         ;TRACE FEATURE
2904          LDA      TRCFLG                   ;SEE IF TRACE IS ON
2905 
2906 
2907          ORA      A                        ;NON-ZERO MEANS YES
2908          JZ       NOTTRC                   ;SKIP THIS PRINTING
2909 
2910 
2911          PUSH     D                        ;SAVE THE TEXT POINTER
2912          MVI      A,"C"                    ;FORMAT THE LINE NUMBER
2913 
2914          OUTCHR                            ;OUTPUT IT
2915          CALL     LINPRT                   ;PRINT THE LINE IN [H,L]
2916 
2917 
2918          MVI      A,"]"                    ;SOME MORE FORMATING
2919 
2920          OUTCHR   
2921          POP      D                        ;[D,E]=TEXT POINTER
2922          NOTTRC:> 
2923          XCHG                              ;RESTORE THE TEXT POINTER
2924 GONE:    CHRGET                            ;GET THE STATEMENT TYPE
2925          LXI      D,NEWSTT                 ;PUSH ON A RETURN ADDRESS OF NEWSTT
2926 
2927 
2928          PUSH     D                        ;STATEMENT
2929 GONE3:   RZ                                ;IF A TERMINATOR TRY AGAIN
2930                                            ;"IF" COMES HERE
2931 GONE2:   SUI      ENDTK                    ;"ON ... GOTO" AND "ON ... GOSUB" COME HERE
2932 
2933          JC       LET                      ;MUST BE A LET
2934 
2935 
2936          NUMCMD=SCRATK-ENDTK+1
2937          CPI      NUMCMD   
2938 
2939          JNC      SNERR                    ;SOME RESERVED WORD, BUT NOT
2940 
2941 
2942                                            ;A STATEMENT RESERVED WORD
2943          RLC                               ;MULTIPLY BY 2
2944          MOV      C,A      
2945          MVI      B,0      
2946 
2947          XCHG     
2948          LXI      H,STMDSP                 ;STATEMENT DISPATCH TABLE
2949 
2950 
2951          DAD      B                        ;ADD ON OFFSET
2952          MOV      C,M                      ;ONUSH THE ADDRESS TO GO TO ONTO
2953          INX      H                        ;THE STACK
2954          MOV      B,M                      ;PUSHM SAVES BYTES BUT NOT SPEED
2955          PUSH     B        
2956          XCHG                              ;RESTORE THE TEXT POINTER
2957 IFE      LENGTH,< 
2958          CHRGET                            ;EAT THE FIRST CHARACTER
2959          RET>                              ;GO DO THE STATEMENT
2960 IFN      LENGTH,< 
2961 CHRGTR:  INX      H                        ;DUPLICATION OF CHRGET RST FOR SPEED
2962          MOV      A,M                      ;SEE CHRGET RST FOR EXPLANATION
2963          CPI      
2964 
2965          RNC>     
2966 ; 
2967 ; CHRCON IS THE CONTINUATION OF THE CHRGET RST
2968 ; 
2969 CHRCON:  CPI                               ;MUST SKIP SPACES
2970 
2971          JZ       CHRGTR                   ;GET ANOTHER CHARACTER
2972 
2973 
2974          CPI      "0"                      ;ALL CHARACTERS GREATER THAN
2975 
2976                                            ;"9" HAVE RETURNED, SO SEE IF NUMERIC
2977          CMC                               ;MAKE NUMERICS HAVE CARRY ON
2978          INR      A                        ;SET ZERO IF [A]=0
2979          DCR      A        
2980          RET      
2981 PAGE     
2982 SUBTTL   RESTORE, STOP, END, LINGET, CHRCON
2983 
2984 RESTOR:  XCHG                              ;SAVE [H,L] IN [D,E]
2985          LHLD     TXTTAB   
2986 
2987 
2988          DCX      H                        ;INITIALIZE DATPTR TO (TXTTAB) -1
2989 RESFIN:  SHLD     DATPTR                   ;READ FINISHES COME TO RESFIN
2990 
2991 
2992          XCHG                              ;GET THE TEXT POINTER BACK
2993          RET      
2994 
2995 IFN      LISTEN,< 
2996 ISCNTC:  IN       0        
2997 
2998          CNLCA3==.-1                       ;CONSOLE COMMAND CHANGE LOC
2999          ANI      IDONE    
3000 
3001          RNZ                               ;IF NO CHARACTERS THEN NO ^C
3002 CNTCCN:  CALL     INCHR    
3003 
3004 
3005          CPI      3                        ;STOP CHARACTER IS ^C
3006 
3007 IFE      LENGTH,< 
3008          JMP      STOP>>   
3009 IFN      LENGTH,< 
3010 STOP:    RNZ                               ;RETURN IF NOT CONTROL-C AND MAKE
3011                                            ;SURE "STOP" STATEMENTS HAVE A TERMINATOR
3012          XWD      ^O1000,^O366             ;SETUP [A] AS A FLAG WHETHER
3013                                            ;TO TYPE THE BREAK MESSAGE
3014 END:     RNZ                               ;MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
3015          SHLD     TEMP                     ;SAVE FOR "CONTINUE"
3016 
3017 
3018 STPEND:  POP      B                        ;POP OFF NEWSTT ADDRESS
3019 ENDCON:  PUSH     PSW                      ;SAVE THE MESSAGE FLAG
3020                                            ;ZERO MEANS DON'T PRINT "BREAK"
3021          LHLD     CURLIN                   ;SAVE CURLIN
3022 
3023 
3024          MOV      A,L      
3025          ANA      H                        ;SEE IF IT WAS DIRECT
3026          INR      A        
3027          JZ       DIRIS                    ;IF NOT SET UP FOR CONTINUE
3028 
3029 
3030          SHLD     OLDLIN                   ;SAVE OLD LINE #
3031 
3032 
3033          LHLD     TEMP                     ;GET POINTER TO START OF STATEMENT
3034 
3035 
3036          SHLD     OLDTXT                   ;SAVE IT
3037 
3038 
3039 DIRIS:   
3040 IFN      CONTRW   
3041          XRA      A        
3042          STA      CNTWFL>                  ;FORCE OUTPUT
3043 
3044 
3045          POP      PSW                      ;GET BACK ^C FLAG
3046          LXI      H,BRKTXT                 ;"BREAK"
3047 
3048 
3049          JNZ      ERRFIN                   ;CALL STROUT AND FALL INTO READY
3050 
3051 
3052          JMP      READY>                   ;TYPE "READY"
3053 
3054 
3055 IFE      REALIO,< 
3056 DDT:     POP      B                        ;GET RID OF NEWSTT RETURN
3057          HRRZ     14,JOBDDT##
3058          JRST     0(14)>   
3059 
3060 IFN      LENGTH,< 
3061 CONT:    RNZ                               ;MAKE SURE THERE IS A TERMINATOR
3062          MVI      E,ERRCN  
3063 
3064          LHLD     OLDTXT                   ;A STORED TEXT POINTER OF
3065 
3066 
3067                                            ;ZERO IS SETUP BY STKINI
3068                                            ;AND INDICATES THERE IS NOTHING
3069                                            ;TO CONTINUE
3070          MOV      A,H                      ;"STOP", "END", TYPING CRLF
3071          ORA      L                        ;TO "INPUT" AND ^C SETUP OLDTXT
3072          JZ       ERROR    
3073 
3074 
3075          XCHG                              ;SAVE [H,L]
3076          LHLD     OLDLIN   
3077 
3078 
3079          SHLD     CURLIN                   ;SET UP OLD LINE # AS CURRENT LINE #
3080 
3081 
3082          XCHG                              ;RESTORE [H,L]
3083          RET>     
3084 IFN      LENGTH,< 
3085 NULL:    CALL     GETBYT   
3086 
3087 
3088          RNZ                               ;MAKE SURE THERE IS A TERMINATOR
3089          INR      A        
3090          CPI      LINLEN                   ;MAKE SURE THE NUMBER IS REASONABLE
3091 
3092                                            ;CRDO WON'T WORK IF IT ISN'T
3093          LINPT2==:.-1                      ;TERMINAL WIDTH CHANGE LOCATION
3094          JNC      FCERR                    ;"FUNCTION CALL" ERROR
3095 
3096 
3097          STA      NULCNT                   ;CHANGE NUMBER OF NULLS
3098 
3099 
3100          RET>     
3101 IFE      LENGTH-2,<
3102 TON:     XWD      ^O1000,^O76              ;"MVI A," NON-ZERO QUANTITY
3103 TOFF:    XRA      A                        ;MAKE [A]=0 FOR NO TRACE
3104          STA      TRCFLG                   ;UPDATE THE TRACE FLAG
3105 
3106 
3107          RET>     
3108 ; 
3109 ; TEST FOR A LETTER / CARRY ON=NOT A LETTER
3110 ;                     CARRY OFF=A LETTER
3111 ; 
3112 ISLET:   MOV      A,M      
3113          CPI      "A"      
3114 
3115          RC                                ;IF LESS THAN "A", RETURN EARLY
3116          CPI      91                       ;91="Z"+1
3117 
3118          CMC      
3119          RET      
3120 ; 
3121 ; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
3122 ; TURNS IT INTO A POSITIVE INTEGER
3123 ; LEAVING THE RESULT IN [D,E], NEGATIVE ARGUMENTS
3124 ; ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
3125 ; CHARACTER OF THE FORMULA ON RETURN.
3126 ; 
3127 IFN      LENGTH-2,<
3128 INTIDX:  CHRGET   
3129 INTID2:  CALL     FRMNUM   
3130 POSINT:  FSIGN    
3131          JM       FCERR                    ;IF NEGATIVE BLOW HIM OUT
3132 DEINT:   LDA      FAC                      ;SEE IF ARG GREATER THAN 32767
3133          CPI      144      
3134          JC       QINT     
3135 IFN      LENGTH,< 
3136          MOVRI    144,128,0,0              ;REGISTERS # FLOATING -32768
3137          CALL     FCOMP                    ;SEE IF FAC=REGISTERS
3138          MOV      D,C                      ;SETUP D=200 E=0 FOR -32768
3139          RZ>                               ;WAS -32768. [D,E] IS SET UP
3140 ILLFUN:  
3141 FCERR:   MVI      E,ERRFC                  ;TOO BIG. FUNCTION CALL ERROR
3142          JMP      ERROR>   
3143 IFE      LENGTH-2,<
3144 INTIDX:  CHRGET   
3145 INTID2:  CALL     FRMEVL                   ;EVALUATE A FORMULA
3146 
3147 
3148          PUSH     H                        ;SAVE THE TEXT POINTER -
3149          CALL     FRCINT                   ;CONVERT THE FAC TO AN INTEGER
3150 
3151          -        
3152          MOV      A,H                      ;SEE IF THE RESULT IS NEGATIVE
3153          ORA      A                        ;BY LOOKING AT [H]'S MSB
3154          JM       FCERR                    ;DON'T ALLOW NEGATIVE NUMBERS -
3155 
3156 
3157          XCHG                              ;RETURN THE INTEGER IN [D,E]
3158          POP      H                        ;RESTORE THE TEXT POINTER
3159          RET>     
3160 
3161 ; 
3162 ; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
3163 ; 
3164 ; LINE NUMBERS RANGE FROM 0 TO 65529
3165 ; 
3166 ; [D,E] IS SMASHED.
3167 ; 
3168 ; ANSWER RETURNED IN [D,E],
3169 ; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
3170 ; AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION
3171 ; CODES SET UP TO REFLECT ITS VALUE.
3172 ; 
3173 LINGET:  DCX      H        
3174 LINGT2:  LXI      D,$CODE                  ;ZERO ACCUMULATED LINE
3175 
3176 
3177 MORLIN:  CHRGET   
3178          RNC                               ;WAS IT A DIGIT
3179          PUSH     H        
3180          PUSH     PSW      
3181          LXI      H,$CODE+6552             ;SEE IF THE LINE # IS TOO BIG
3182 
3183 
3184          COMPAR   
3185          JC       SNERR                    ;YES, SYNTAX ERROR
3186 
3187 
3188          MOV      H,D                      ;SAVE [D,E]
3189          MOV      L,E      
3190          DAD      D        
3191          DAD      H        
3192          DAD      D        
3193          DAD      H                        ;PUTTING [D,E]*10 INTO [H,L]
3194          POP      PSW      
3195          SUI      "0"      
3196 
3197          MOV      E,A      
3198          MVI      D,0      
3199 
3200          DAD      D                        ;ADD THE NEW DIGIT
3201          XCHG     
3202          POP      H                        ;GET BACK TEXT POINTER
3203          JMP      MORLIN   
3204 
3205 
3206 IFN      LENGTH,< 
3207 CLEAR:   JZ       CLEARC                   ;IF NO FORMULA JUST CLEAR
3208 
3209 
3210          CALL     INTID2                   ;GET AN INTEGER INTO CD,E
3211 
3212 
3213          DCX      H        
3214          CHRGET                            ;SEE IF ITS THE END
3215          RNZ                               ;SHOULD FINISH THERE
3216          PUSH     H                        ;SAVE TXTPTR
3217          LHLD     MEMSIZ                   ;GET HIGHEST ADDRESS
3218 
3219 
3220          MOV      A,L                      ;SUBTRACT [H,L]-[D,E] INTO [D,E]
3221          SUB      E        
3222          MOV      E,A      
3223          MOV      A,H      
3224          SBB      D        
3225          MOV      D,A      
3226          JC       SNERR                    ;WANTED MORE THAN TOTAL!
3227 
3228 
3229          LHLD     VARTAB                   ;TOP LOCATION IN USE
3230 
3231 
3232          LXI      B,$CODE+40               ;LEAVE BREATHING ROOM
3233 
3234 
3235          DAD      B        
3236          COMPAR                            ;ROOM?
3237          JNC      OMERR                    ;NO, DON'T EVEN CLEAR
3238 
3239 
3240          XCHG                              ;NEW STACK LOCATION [H,L]
3241          SHLD     STKTOP                   ;SET UP NEW STACK LOCATION
3242 
3243 
3244          POP      H                        ;REGAIN THE TEXT POINTER
3245          JMP      CLEARC>                  ;GO CLEAR
3246 
3247 
3248 PAGE     
3249 SUBTTL   RUN, GOTO, GOSUB, RETURN
3250 IFN      LENGTH,< 
3251 RUN:     JZ       RUNC                     ;NO LINE # ARGUMENT
3252 
3253 
3254                                            ;CLEAN UP,SET [H,L]=[TXTTAB]-1 AND
3255                                            ;RETURN TO NEWSTT
3256          CALL     CLEARC                   ;CLEAN UP -- RESET THE STACK
3257 
3258 
3259                                            ;DATPTR, VARIABLES ...
3260                                            ;[H,L] IS THE ONLY THING PRESERVED
3261          LXI      B,NEWSTT 
3262 
3263 
3264          JMP      RUNC2>                   ;PUT "NEWSTT" ON AND FALL INTO "GOTO"
3265 
3266 
3267 ; 
3268 ; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
3269 ; 
3270 ; LOW ADDRESS
3271 ; 
3272 ;       A TOKEN EQUAL TO GOSUTK 1 BYTE
3273 ;       THE LINE # OF THE THE GOSUB STATEMENT 2 BYTES
3274 ;       A POINTER INTO THE TEXT OF THE GOSUB 2 BYTES
3275 ; 
3276 ; HIGH ADDRESS
3277 
3278 ; TOTAL 5 BYTES
3279 ; 
3280 GOSUB:   CALL     GETSTK                   ;MAKE SURE THERE IS ROOM
3281 
3282 
3283          3        
3284          POP      B                        ;POP OFF RETURN ADDRESS OF "NEWSTT"
3285          PUSH     H                        ;REALLY PUSH THE TEXT POINTER
3286          PUSH     H                        ;SAVE TEXT POINTER
3287          LHLD     CURLIN                   ;GET THE CURRENT LINE #
3288 
3289 
3290          XTHL                              ;PUT CURLIN ON THE STACK AND H,L]=TEXT PTR
3291          MVI      D,GOSUTK                 ;LEAVE A GOSUB TOKEN
3292 
3293                                            ;ON THE STACK
3294          PUSH     D        
3296 RUNC2:   PUSH     B                        ;RESTORE RETURN ADDRESS
3295          INX      SP                       ;THE GOSUB TOKEN TAKES ONLY ONE BYTE
3297                                            ;OF "NEWSTT"
3298 ; 
3299 ; IN THE 4K VERSION WE START AT THE BEGINNING
3300 ; AND SEARCH. IN THE 8K WE START WHERE WE
3301 ; ARE IF WE ARE GOING TO A FORWARD LOCATION.
3302 ; 
3303 GOTO:    CALL     LINGET                   ;PICK UP THE LINE
3304 
3305 
3306                                            ;AND PUT IT IN [D,E]
3307 IFE      LENGTH,<RNZ                       ;SHOULD END WITH A LINE
3308                                            ;TERMINATOR -- BLOW HIM UP
3309                                            ;IF IT DOESN'T
3310                                            ;(ON GOTO MAKES THIS WRONG
3311                                            ;IN OTHER VERSONS)
3312          CALL     FNDLIN>  
3313 IFN      LENGTH,< 
3314          CALL     REM                      ;SKIP TO THE END OF THIS LINE
3315 
3316 
3317          PUSH     H                        ;SAVE THE POINTER
3318          LHLD     CURLIN                   ;GET THE CURRENT LINE #
3319 
3320 
3321          COMPAR                            ;[D,E] CONTAINS WHERE WE ARE GOING
3322                                            ;[H,L] CONTAINS THE CURRENT LINE#
3323                                            ;SO COMPARING THEM TELL US WHETHER TO
3324                                            ;START SEARCHING FROM WHERE WE ARE OR
3325                                            ;TO START SEARCHING FROM THE BEGINNING
3326                                            ;OF TXTTAB
3327          POP      H                        ;[H,L]=CURRENT POINTER
3328          INX      H                        ;POINT AT THE LINK BEYOND IT
3329          CC       LOOP                     ;SEARCH FROM THIS POINT
3330 
3331 
3332          CNC      FNDLIN>                  ;SEARCH FROM THE BEGINNING -- ACTUALLY
3333 
3334 
3335                                            ;SEARCH AGAIN IF ABOVE SEARCH FAILED
3336          MOV      H,B      
3337          MOV      L,C      
3338          DCX      H        
3339          RC                                ;IF A MATCH WE ARE DONE
3340 USERR:   MVI      E,ERRUS  
3341 
3342          JMP      ERROR                    ;C=MATCH, SO IF NO MATCH WE
3343 
3344 
3345                                            ;GIVE A "US" ERROR
3346 ; 
3347 ; SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
3348 ; "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
3349 ; AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
3350 ; ENTRY
3351 ; 
3352 RETURN:  RNZ                               ;BLOW HIM UP IF THERE ISN'T A TERMINATOR
3353          MVI      D,255                    ;MAKE SURE THIS VARIABLE POINTER
3354 
3355                                            ;IN [D,E] NEVER GETS MATCHED
3356          CALL     FNDFOR                   ;GO PAST ALL THE "FOR" ENTRIES
3357 
3358 
3359          SPHL                              ;UPDATE THE STACK
3360          CPI      GOSUTK   
3361 
3362          MVI      E,ERRRG                  ;ERROR ERRRG IS "RETURN WITHOUT GOSUB"
3363 
3364          JNZ      ERROR    
3365 
3366 
3367          POP      H                        ;GET LINE # "GOSUB" WAS FROM
3368          SHLD     CURLIN                   ;PUT IT INTO CURLIN
3369 
3370 
3371          LXI      H,NEWSTT 
3372 
3373 
3374          XTHL                              ;PUT RETURN ADDRESS OF "NEWSTT"
3375                                            ;BACK ONTO THE STACK. GET TEXT POINTER
3376                                            ;FROM "GOSUB"
3377                                            ;SKIP OVER SOME CHARACTERS
3378                                            ;SINCE WHEN "GOSUB" STUCK THE TEXT POINTER
3379                                            ;ONTO THE STACK THE LINE # ARGUMENT HADN'T
3380                                            ;BEEN READ IN YET.
3381 
3382 
3383 IFN      STRING,< 
3384 DATA:    XWD      ^O1000,1                 ;"LXI B," TO PICK UP ":" INTO C AND SKIP
3385                                            ;"DATA" TERMINATES ON ":"
3386                                            ;AND 0. ":" ONLY APPLIES IF
3387                                            ;QUOTES HAVE MATCHED UP
3388 IFE      LENGTH-2,<ELSE:>                  ;EXECUTED "ELSE"S ARE SKIPPED
3389 ; 
3390 ; NOTE: REM MUST PRESERVE [D,E] BECAUSE OF "GO TO" AND ERROR
3391 ; 
3392 REM:     XWD      ^O1000,^O16              ;"MVI C," THE ONLY TERMINATOR IS 0
3393          XWD      ^O1000,0                 ;NO-OPERATION
3394                                            ;"DATA" ACTUALLY EXECUTES THIS 0
3395          MVI      B,0                      ;INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
3396 
3397 EXCHQT:  MOV      A,C                      ;WHEN A QUOTE IS SEEN THE SECOND
3398          MOV      C,B                      ;TERMINATOR IS TRADED, SO IN "DATA"
3399          MOV      B,A                      ;COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
3400 REMER:   MOV      A,M                      ;GET THE CHARACTER
3401          ORA      A                        ;ZERO IS ALWAYS A TERMINATOR
3402          RZ       
3403          CMP      B                        ;TEST FOR THE OTHER TERMINATOR
3404          RZ       
3405          INX      H        
3406          CPI      34                       ;IS IT A QUOTE?
3407 
3408          JZ       EXCHQT                   ;IF SO TIME TO TRADE
3409 
3410 
3411 IFE      LENGTH-2,<
3412 ; 
3413 ; WHEN AN "IF" TAKES A FALSE BRANCH IT MUST FIND THE APPROPRIATE "ELSE"
3414 ; TO START EXECUTION AT. "DATA" COUNTS THE NUMBER OF "IF"S
3415 ; IT SEES SO THAT THE "ELSE" CODE CAN MATCH "ELSE"S WITH
3416 ; "IF"S. THE COUNT IS KEPT IN [D]
3417 ; 
3418          SUI      IFTK                     ;IS IT AN "IF"
3419 
3420          JNZ      REMER                    ;IF NOT, CONTINUE ON
3421 
3422 
3423          CMP      B                        ;SINCE "REM" CAN'T SMASH
3424                                            ;[D,E] WE HAVE TO BE CAREFUL
3425                                            ;SO ONLY IF B DOESN'T EQUAL
3426                                            ;ZERO WE INCREMENT D. (THE "IF" COUNT)
3427          ADC      D                        ;CARRY ON IF [B] NOT ZERO .
3428          MOV      D,A>                     ;UPDATE [D]
3429          JMP      REMER>   
3430 
3431 
3432 ; 
3433 ; WITHOUT STRINGS THERE IS NO NEED TO WATCH QUOTATIONS -
3434 ; SO [B] IS SET UP AS THE SECONDARY TERMINATOR
3435 ; AND A SCAN IS MADE FOR [B] OR ZERO
3436 ; 
3437 IFE      STRING,< 
3438 DATA:    XWD      ^O1000,1                 ;MAKE [C] AND SKIP
3439          ":"      -        
3440 REM:     XWD      ^O1000,16                ;MAKE [C]=0
3441          XWD      ^O1000,0                 ;ZERO AND NO-OPERATION
3442 LOOPDR:  MOV      A,M      
3443          ORA      A                        ;ALWAYS STOP ON ZERO
3444          RZ       
3445          CMP      C                        ;CHECK FOR ":" IN DATA
3446          RZ       
3447          INX      H                        ;LOOK AT NEXT CHARACTER
3448          JMP      LOOPDR>  
3449 PAGE     
3450 SUBTTL   "LET"
3451 LET:     CALL     PTRGET                   ;GET THE POINTER TO THE VARIABLE
3452 
3453 
3454                                            ;NAMED IN TEXT AND PUT .
3455                                            ;IT ON THE STACK. [H,L] REMAINS
3456                                            ;THE TEXT POINTER AND A, PSW ARE SETUP
3457                                            ;AS THE TERMINATING CHARACTER,
3458          SYNCHK   EQULTK                   ;CHECK FOR "="
3459 
3460 REDINP:  
3461 IFN      STRING,< 
3462          LDA      VALTYP   
3463 
3464 
3465          PUSH     PSW>     
3466          PUSH     D        
3467          CALL     FRMEVL                   ;GET THE VALUE OF THE FORMULA
3468 
3469 
3470                                            ;INTO FAC
3471          XTHL                              ;[H,L]=POINTER TO VARIABLE
3472                                            ;TEXT POINTER TO ON TOP OF STACK
3473          SHLD     TEMP                     ;SAVE VARIABLE POINTER FOR "FOR"
3474 
3475 
3476 IFN      STRING,< 
3477          POP      D                        ;GET TEXT POINTER OFF
3478          POP      PSW                      ;GET THE VALTYP OF THE .
3479                                            ;VARIABLE INTO [A]
3480          PUSH     D                        ;RESAVE THE TEXT-POINTER
3481 IFE      LENGTH-2,<
3482          CPI      3                        ;SEE IF ITS A STRING
3483 
3484 INPCOM:  PUSH     H                        ;SAVE THE POINTER AT THE VALUE POSITION .
3485          JNZ      COPNUM                   ;NUMERIC, SO FORCE IT AND COPY
3486 
3487 
3488          CALL     CHKSTR>                  ;MAKE SURE THE FORMULA WAS A STRING
3489 
3490 
3491 IFN      LENGTH-2,<
3492          RAR                               ;CARRY SET FOR STRING OFF
3493                                            ;FOR NUMERIC
3494          CALL     CHKVAL                   ;MAKE SURE VALTYP MATCHES CARRY
3495                                            ;AND SET THE ZERO FLAG
3496                                            ;ON A NUMERIC VALTYP
3497          JZ       COPNUM                   ;IF A NUMBER COPY
3498 INPCOM:  PUSH     H>                       ;SAVE POINTER AT VARIABLE
3499          LHLD     FACLO                    ;GET POINTER TO THE DESCRIPTOR OF THE RESULT
3500 
3501 
3502          PUSH     H                        ;SAVE THE POINTER AT THE DESCRIPTOR
3503          INX      H        
3504          INX      H        
3505          PUSHM    
3506          POP      D        
3507          LHLD     STKTOP                   ;SEE IF IT POINTS INTO STRING SPACE
3508 
3509 
3510          COMPAR                            ;IF NOT DON'T COPY
3511          POP      D                        ;GET BACK THE POINTER AT THE DESCRIPTOR
3512          JNC      DNTCPY                   ;DON'T COPY LITERALS
3513 
3514 
3515          LHLD     VARTAB                   ;NOW, SEE IF ITS A VARIABLE
3516 
3517 
3518          COMPAR                            ;BY SEEING IF THE DESCRIPTOR
3519          MOV      L,E      
3520          MOV      H,D      
3521          CC       STRCPY                   ;IS BEYOND [VARTAB], IF SO COPY
3522 
3523 
3524 DNTCPY:  LDAX     D                        ;GET THE LENGTH AND SAVE IT
3525          PUSH     PSW                      ;SINCE WE ARE GOING TO SET IT TO
3526                                            ;0 SO FRETMP DOESN'T UPDATE FRETOP
3527          XRA      A                        ;SET IT TO 0 -- ELIMINATING NULL
3528                                            ;STRING IN FRETMP IS HARMLESS
3529          STAX     D                        ;PUT 0 IN THE LENGTH FIELD
3530          CALL     FRETMP                   ;FREE IT UP
3531 
3532 
3533          POP      PSW                      ;GET LENGTH BACK
3534          MOV      M,A                      ;REPLACE IT ( FRETMP RETURNS [D,E] IN [H,L] )
3535          XCHG                              ;PUT THE DESCRIPTOR POINTER BACK IN [D,E]
3536          POP      H                        ;GET THE PLACE OF THE NEW VARIABLE
3537 IFN      LENGTH-2,<
3538          CALL     MOVE>                    ;COPY THE DESCRIPTOR
3539 IFE      LENGTH-2,<
3540          CALL     VMOVE>   
3541 
3542 
3543          POP      H                        ;GET THE TEXT POINTER BACK
3544          RET>     
3545 COPNUM:  
3546 IFE      LENGTH-2,<
3547          ANI      6                        ;SETUP DISPATCH TO FORCE
3548 
3549                                            ;FORMULA TYPE TO CONFORM
3550                                            ;TO THE VARIABLE ITS BEING ASSIGNED TO
3551          LXI      H,FRCTBL                 ;TABLE OF FORCE ROUTINES
3552 
3553 
3554          MOV      C,A                      ;[B,C]=TWO BYTE OFFSET
3555          MVI      B,0      
3556 
3557          DAD      B        
3558          MOV      A,M                      ;[H,L]=ADDRESS TO GO TO
3559          INX      H        
3560          MOV      H,M      
3561          MOV      L,A      
3562          LXI      B,PUTVAL                 ;RETURN TO PUTVAL
3563 
3564 
3565          PUSH     B        
3566          PCHL                              ;DISPATCH TO FORCE
3567 PUTVAL:  POP      H                        ;GET THE POINTER OF WHERE TO STORE
3568                                            ;THE VALUE
3569          PUSH     H                        ;SAVE IT BACK
3570          CALL     VMOVMF>                  ;MOVE THE VALUE IN
3571 
3572 
3573 IFN      LENGTH-2,<
3574          PUSH     H                        ;SAVE THE VARIABLE POINTER FOR "FOR"
3575          CALL     MOVMF>                   ;TRANSFER THE VALUE
3576          POP      D                        ;"FOR" WANTS VARIABLE POINTER IN
3577                                            ;[D,E] FOR FNDFOR
3578          POP      H                        ;GET THE TEXT POINTER
3579          RET      
3580 PAGE     
3581 SUBTTL   ON GOTO CODE
3582 IFN      LENGTH,< 
3583 
3584 ONGOTO:  CALL     GETBYT                   ;GET VALUE INTO [E]
3585 
3586 
3587          MOV      A,M                      ;GET THE TERMINATOR BACK
3588          MOV      B,A                      ;SAVE THIS CHARACTER FOR LATER
3589          CPI      GOSUTK                   ;AN "ON GOSUB" PERHAPS?
3590 
3591          JZ       ISGOSU                   ;YES, SOME FEATURE USE
3592 
3593 
3594          SYNCHK   GOTOTK                   ;OTHERWISE MUST BE "GOTO"
3595 
3596          DCX      H                        ;BACK UP CHARACTER POINTER
3597 ISGOSU:  MOV      C,E                      ;GET COUNT INTO (C)
3598 LOOPON:  DCR      C                        ;SEE IF ENOUGH SKIPS
3599          MOV      A,B                      ;PUT DISPATCH CHARACTER IN PLACE
3600          JZ       GONE2                    ;IF DONE, GO OFF
3601 
3602 
3603          CALL     LINGT2                   ;SKIP OVER A LINE #
3604 
3605 
3606          CPI      44                       ;A COMMA
3607 
3608          RNZ                               ;IF A COMMA DOESN'T DELIMIT THE END OF
3609                                            ;THE LAST LINE # MUST BE THE END OF THE LINE
3610          JMP      LOOPON>                  ;CONTINUE GOBBLING LINE #S
3611 
3612 
3613 
3614 PAGE     
3615 SUBTTL   IF ... THEN CODE
3616 IF:      CALL     FRMEVL                   ;EVALUATE A FORMULA
3617 
3618 
3619 IFE      LENGTH,< 
3620 IFN      STRING,< 
3621          LDA      VALTYP                   ;GET VALUE TYPE INTO [A]
3622          PUSH     PSW>>                    ;SAVE THE VALUE TYPE ON THE STACK
3623          MOV      A,M                      ;GET TERMINATING CHARACTER OF FORMULA
3624 IFE      LENGTH,< 
3625          CALL     PUSHF                    ;ONTO THE STACK
3626          MVI      D,0                      ;KEEPS RELATIONAL OPERATOR MEMORIES
3627                                            ;LESS THAN =4
3628                                            ;EQUAL     =2
3629                                            ;GREATER THAN =1
3630 LOOPIF:  SUI      GREATK                   ;CHECK FOR A RELATIONAL OPERATOR
3631          JC       ENDREL                   ;NOPE
3632          NUMREL=LESSTK-GREATK+1            ;NUMBER OF RELATIONAL OPERATORS
3633          CPI      NUMREL                   ;IS THIS ONE OF THEM?
3634          JNC      ENDREL                   ;NO SEE WHAT WE HAVE
3635          CPI      1                        ;SETUP BITS BY MAPPING
3636          RAL                               ;0 TO 1, 1 TO 2 AND 2 TO 4
3637          ORA      D                        ;FOR WITH EARLIER BITS
3638          MOV      D,A                      ;STORE NEW BITS
3639          CHRGET                            ;GET NEW CHARACTER
3640          JMP      LOOPIF                   ;SEE IF RELATIONAL
3641 ENDREL:  MOV      A,D                      ;GET REALTIONAL MEMORIES
3642          ORA      A                        ;SEE IF THERE ARE ANY
3643          JZ       SNERR                    ;NO RELATIONAL OPERATORS:
3644          PUSH     PSW                      ;SAVE RELATIONAL MEMORIES
3645          CALL     FRMEVL>                  ;PICK UP FIRST NON-RELATIONAL
3646                                            ;CHARACTER AGAIN AND INTERPRET FORMULA
3647                                            ;ANSWER LEFT IN FAC
3648 IFE      LENGTH-2,<CPI 44                  ;A COMMA?
3649 
3650          CZ       CHRGTR>                  ;IF SO SKIP IT
3651 
3652 
3653 IFN      LENGTH,< 
3654          CPI      GOTOTK                   ;ALLOW "GOTO" AS WELL
3655 
3656          JZ       OKGOTO>  
3657 
3658 
3659          SYNCHK   THENTK                   ;MUST HAVE A THEN
3660 
3661          DCX      H        
3662 OKGOTO:  
3663 IFE      LENGTH,< 
3664          POP      PSW      
3665          POPR                              ;POP OFF NUMBER
3666 IFN      STRING   
3667          XTHL>                             ;COMPARE FORMULA TYPES
3668 IFE      STRING,<PUSH H>                   ;SAVE THE TEXT POINTER
3669          PUSH     PSW                      ;RESAVE RELATIONAL MEMORIES
3670 IFN      STRING,< 
3671          LDA      VALTYP                   ;GET VALUE TYPE
3672          CMP      H                        ;[H] HAS OLD VALTYP ARE THEY =?
3673          JNZ      TMERR                    ;IF NOT ITS A TYPE ERROR
3674          ORA      A                        ;SEE WHAT TYPE IT WAS
3675          JZ       NUMCMP                   ;ZERO MEANS IT WAS NUMERIC
3676          CALL     STRCMP                   ;MUST BE STRING, SO STRING COMPARE
3677          JMP      SKPNCM>                  ;SKIP OVER NUMERIC COMPARE
3678 NUMCMP:  CALL     FCOMP                    ;COMPARE THE 2 SIDE OF THE RELATION STATEMENT
3679 SKPNCM:  INR      A                        ;BUILD RELATIONAL BITS
3680          RAL                               ;LESS=4 EQUAL=2 GREATER=1
3681                                            ;SINCE CARRY IS ON ONLY IN
3682                                            ;377 CASE (FCOMP & STRCMP)
3683          POP      B                        ;POP OFF WHAT RELATIONAL OPERATOR WAS
3684          ANA      B>                       ;SEE IF WE MATCHED
3685 IFN      LENGTH,< 
3686 IFE      LENGTH-2,<
3687          CALL     VSIGN##> 
3688 
3689 
3690 IFN      LENGTH-2,<
3691          FSIGN>>                           ;0=FALSE ALL OTHERS=TRUE
3692 IFE      LENGTH,< 
3693          POP      H>                       ;POP OFF TEXT POINTER
3694 IFE      LENGTH-2,<
3695          JZ       FALSIF>                  ;HANDLE POSSIBLE "ELSE"
3696 
3697 
3698 IFN      LENGTH-2,<
3699          JZ       REM>                     ;IF TEST FAILED -- JUST SKIP REST OF THE LINE
3700 DOCOND:  CHRGET                            ;PICK UP THE FIRST LINE # CHARACTER
3701          JC       GOTO                     ;LINE NUMBER MEANS "GOTO"
3702 
3703 
3704          JMP      GONE3                    ;INTERPRET NEW STATEMENT
3705 
3706 
3707 IFE      LENGTH-2,<
3708 ; 
3709 ; "ELSE" HANDLER. HERE ON FALSE "IF" CONDITION
3710 ; 
3711 FALSIF:  MVI      D,1                      ;NUMBER OF "ELSE"S THAT MUST -
3712 
3713                                            ;BE SEEN. "DATA" INCREMENTS THIS
3714                                            ;COUNT EVERY TIME AN "IF" IS SEEN
3715 SKPMRF:  CALL     DATA                     ;SKIP A STATEMENT
3716 
3717 
3718                                            ;":" IS STUCK IN FRONT OF "ELSE"S
3719                                            ;SO THAT "DATA" WILL STOP BEFORE "ELSE" CLAUSES
3720 
3721          ORA      A                        ;END OF LINE?
3722          RZ                                ;IF SO, NO "ELSE" CLAUSE
3723          CHRGET                            ;SEE IF WE HIT AN "ELSE"
3724          CPI      ELSETK   
3725 
3726          JNZ      SKPMRF                   ;NO, STILL IN THE "THEN" CLAUSE
3727 
3728 
3729          DCR      0                        ;DECREMENT THE NUMBER OF "ELSE"S THAT
3730                                            ;MUST BE SEEN
3731          JNZ      SKPMRF                   ;SKIP MORE IF HAVEN'T SEEN
3732 
3733 
3734                                            ;ENOUGH
3735          JMP      DOCOND>                  ;FOUND THE RIGHT "ELSE" -- GO EXECUTE
3736 
3737 
3738 
3739 PAGE     
3740 SUBTTL   PRINT CODE
3741 
3742 IFN      LPTSW,<  
3743 LPRINT:  MVI      A,1                      ;SAY NON ZERO
3744          STA      PRTFLG>                  ;SAVE AWAY
3745 NEWCHR:  DCX      H        
3746 MORPR:   CHRGET                            ;GET ANOTHER CHARACTER
3747 PRINT:   JZ       CRDO                     ;IF WE SEE A TERMINATOR
3748 
3749 
3750                                            ;GO TYPE A CRLF
3751 PRINTC:  RZ                                ;HERE AFTER SEEING TAB(X) OR , OR ;
3752                                            ;IN WHICH CASE A TERMINATOR DOES NOT
3753                                            ;MEAN WE SHOULD TYPE A CRLF
3754                                            ;BUT JUST RETURN
3755 IFE      STRING,< 
3756          CPI      34                       ;A TERMINATING QUOTE?
3757          CZ       STROUI   
3758          JZ       NEWCHR>                  ;A QUOTATION -- JUST PRINT IT
3759          CPI      TABTK    
3760 
3761          JZ       TABER                    ;THE TAB FUNCTION?
3762 
3763 
3764 IFN      LENGTH,< 
3765          CPI      SPCTK    
3766 
3767          JZ       TABER>                   ;THE SPC FUNCTION?
3768 
3769 
3770          PUSH     H                        ;SAVE THE TEXT POINTER
3771          CPI      44       
3772 
3773          JZ       COMPRT                   ;IS IT A COMMA?
3774 
3775 
3776          CPI      59                       ;IS IT A ";"
3777 
3778          JZ       NOTABR   
3779 
3780 
3781          POP      B                        ;GET RID OF OLD TEXT POINTER
3782          CALL     FRMEVL                   ;BACK UP ONE CHARACTER AND READ THAT ONE
3783 
3784 
3785                                            ;AGAIN SO THE CONDITION CODES ARE RIGHT
3786                                            ;EVALUATE THE FORMULA
3787          DCX      H                        ;BACKUP FROM TERMINATOR
3788          PUSH     H                        ;SAVE TEXT POINTER
3789 IFN      STRING,< 
3790 IFE      LENGTH-2,<
3791          CALL     GETYPE                   ;SEE IF WE HAVE A STRING
3792 
3793 
3794          JZ       STRDON>                  ;IF SO, PRINT SPECIALY
3795 
3796 
3797 IFN      LENGTH-2,<
3798          LDA      VALTYP   
3799          ORA      A        
3800          JNZ      STRDON>>                 ;WAS IT A STRING FORMULA?
3801          CALL     FOUT                     ;MAKE A NUMBER INTO A STRING
3802 
3803 
3804 IFE      STRING,<CALL STROUT>              ;IF STRINGS OFF JUST OUTPUT IT
3805 IFN      STRING,< 
3806          CALL     STRLIT                   ;MAKE IT A STRING
3807 
3808 
3809          LHLD     FACLO                    ;GET THE POINTER
3810 
3811 
3812 IFN      LPTSW,<  
3813          LDA      PRTFLG   
3814          ORA      A        
3815          JZ       ISTTY                    ;LPT OR TTY?
3816          LDA      LPTPOS   
3817          ADD      M        
3818          CPI      LPTLEN                   ;WILL THIS NUMBER OVERLAP?
3819          JMP      LINCHK   
3820          ISTTY:>  
3821          LDA      TTYPOS                   ;SEE WHERE WE ARE
3822 
3823 
3824          ADD      M                        ;ADD THIS LENGTH
3825          CPI      LINLEN                   ;SEE IF GREATER THAN THE LINE LENGTH
3826 
3827          LINPT3==:.-1
3828 LINCHK:  CNC      CRDO                     ;IF SO CRLF
3829 
3830 
3831          CALL     STRPRT>                  ;PRINT THE NUMBER
3832 
3833 
3834          MVI      A," "                    ;ALWAYS END WITH A SPACE
3835 
3836          OUTCHR   
3837 IFN      STRING,< 
3838 IFE      LENGTH-21
3839          ORA      A                        ;TURN OFF THE ZERO FLAG
3840 STRDON:  CZ       STRPRT>  
3841 
3842 
3843 IFN      LENGTH-2,<
3844          XRA      A        
3845 STRDON:  CNZ      STRPRT>>                 ;JUST PRINT STRINGS
3846          POP      H        
3847          JMP      MORPR                    ;PRINT SOME MORE
3848 
3849 
3850 FININL:  MVI      M,0                      ;PUT A ZERO AT THE END OF BUF
3851 
3852          LXI      H,BUFMIN                 ;SETUP POINTER
3853 
3854 
3855 CRDO:    IFN      LPTSW,<  
3856          LDA      PRTFLG   
3857          ORA      A        
3858          JNZ      PRINTW>  
3859          MVI      A,13     
3860 
3861          STA      TTYPOS                   ;MAKE TTYPOS LESS THAN LINE LENGTH
3862 
3863 
3864                                            ;SO CRDO DOESN'T GET CALLED AGAIN
3865          OUTCHR   
3866          MVI      A,10     
3867 
3868          OUTCHR   
3869 CRFIN:   LDA      NULCNT                   ;GET NUMBER OF NULLS
3870 
3871 
3872 PRTNUL:  DCR      A        
3873          STA      TTYPOS                   ;EVENTUALLY SETUP TTYPOS=0
3874 
3875 
3876          RZ                                ;ALL NULLS DONE [A]=0
3877                                            ;SOME ROUTINES DEPEND ON CRDO
3878                                            ;AND CRFINS RETURN [A]=0 AND Z TRUE
3879          PUSH     PSW                      ;SAVE THE COUNT
3880          XRA      A                        ;[A]= A NULL
3881          OUTCHR                            ;SEND IT OUT
3882          POP      PSW                      ;RESTORE THE COUNT
3883          JMP      PRTNUL                   ;LOOP PRINTING NULLS
3884 
3885 
3886 IFE      STRING,< 
3887 STROUI:  INX      H        
3888 STROUT:  MOV      A,M      
3889          ORA      A                        ;CHECK FOR END OF LINE
3890          RZ                                ;LET IT END THAT WAY
3891          INX      H        
3892          CPI      34                       ;A TERMINATING QUOTE?
3893          RZ                                ;DONE IF SO
3894          OUTCHR                            ;PRINT THE CHARACTER IN [A]
3895          CPI      CR                       ;IF IT'S A CARRIAGE RETURN
3896          CZ       CRDO                     ;TYPE LINE-FEED AND SET [TTYPOS]=0
3897          JMP      STROUT>                  ;PRINT MORE CHARACTERS
3898 
3899 COMPRT:  IFN      LPTSW,<  
3900          LDA      PRTFLG                   ;OUTPUT TO THE LINE PRINTER?
3901          ORA      A                        ;NON-ZERO MEANS YES
3902          JZ       ISCTTY                   ;NO, DO TELETYPE COMMA
3903          LDA      LPTPOS                   ;GET LINE PRINTER POSITION
3904          NLPPOS==<<<LPTLEN/CLMWID>-1>*CLMWID> ;POSITION BEYOND WHICH THERE ARE
3905                                            ;NO MORE COMMA FIELDS, SO
3906          CPI      NLPPOS                   ;COMMA JUST DOES A "CRDO"
3907          JMP      CHKCOM                   ;USE TELETYPE CHECK
3908          ISCTTY:> 
3909          LDA      TTYPOS                   ;GET TELETYPE POSITION
3910 
3911 
3912          NUTPOS=<<<LINLEN/CLMWID>-1>*CLMWID> ;POSITION BEYOND WHICH THERE ARE
3913                                            ;NO MORE COMMA FIELDS
3914          CPI      NUTPOS                   ;SO ALL COMMA DOES IS A "CRDO"
3915 
3916          LINPT4==:.-1                      ;FIXED UP BY "TERMINAL WIDTH" QUESTION
3917 CHKCOM:  CNC      CRDO                     ;TYPE CRLF
3918 
3919 
3920          JNC      NOTABR                   ;AND QUIT IF BEYOND THE LAST COMMA FIELD
3921 
3922 
3923 MORCOM:  SUI      CLMWID                   ;GET [A] MODULUS CLMWID
3924 
3925          JNC      MORCOM   
3926 
3927 
3928          CMA                               ;WE WANT TO FILL
3929                                            ;THE PRINT POSITION OUT
3930                                            ;TO AN EVEN CLMWID, SO
3931                                            ;WE PRINT CLMWID-[A] MOD CLMWID SPACES
3932          JMP      ASPA2                    ;GO PRINT [A]+1 SPACES
3933 
3934 
3935 
3936 TABER:   
3937 IFN      LENGTH,<PUSH PSW>                 ;REMEMBER IF [A]=SPCTK OR TABTK
3938 IFE      LENGTH,< 
3939          CALL     INTIDX>                  ;INTEGERIZE A FORMULA INTO [D,E]
3940 IFN      LENGTH,< 
3941          CALL     GTBYTC>                  ;GET VALUE INTO [E]
3942 
3943 
3944          SYNCHK   ")"      
3945 
3946          DCX      H        
3947 IFN      LENGTH,< 
3948          POP      PSW                      ;GET BACK SPCTK OR TABTK
3949          CPI      SPCTK>                   ;WAS IT SPCTK?
3950 
3951          PUSH     H                        ;SAVE THE TEXT POINTER
3952 IFN      LENGTH,< 
3953          MOV      A,E                      ;FOR "SPC" PUT THE FORMULA
3954          JZ       ASPAC>                   ;VALUE IN [A]
3955 
3956 
3957 IFN      LPTSW,<  
3958          LDA      PRTFLG                   ;LINE PRINTER OR TTY?
3959          ORA      A                        ;NON-ZERO MEANS LPT
3960          JZ       TTYIST   
3961          LDA      LPTPOS                   ;GET LINE PRINTER POSITION
3962          JMP      DOSIZT>  
3963 TTYIST:  LDA      TTYPOS                   ;GET TELETYPE PRINT POSITION
3964 
3965 
3966 DOSIZT:  CMA                               ;PRINT [E]-[A] SPACES
3967          ADD      E        
3968          JNC      NOTABR                   ;IF NEGATIVE, DON'T PRINT ANY
3969 
3970 
3971                                            ;SPACES
3972 ASPA2:   INR      A        
3973 ASPAC:   MOV      B,A                      ;[B]=NUMBER OF SPACES TO PRINT
3974          MVI      A," "                    ;[A]=SPACE
3975 
3976 REPOUT:  OUTCHR                            ;PRINT [A]
3977          DCR      B                        ;DECREMENT THE COUNT
3978          JNZ      REPOUT   
3979 
3980 
3981 NOTABR:  POP      H                        ;PICK UP TEXT POINTER
3982          CHRGET                            ;AND THE NEXT CHARACTER
3983          JMP      PRINTC                   ;AND SINCE WE JUST PRINTED
3984 
3985 
3986                                            ;SPACES, DON'T CALL CRDO
3987                                            ;IF IT'S THE END OF THE LINE
3988 PAGE     
3989 SUBTTL   INPUT AND READ CODE
3990 IFN      LENGTH,< 
3991 TRYAGN:  DC"?REDO FROM START"
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 
4002 
4003 
4004 
4005 
4006 
4007 
4008          ACRLF    
4009 
4010          0        
4011 ; 
4012 ; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
4013 ; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
4014 ; FOR "DATA" WE GIVE A SYNTAX ERROR AT THE DATA LINE
4015 ; 
4016 TRMNOK:  LDA      FLGINP                   ;WAS IT READ OR INPUT?
4017 
4018 
4019          ORA      A                        ;ZERO=INPUT
4020          JNZ      DATSNE                   ;GIVE ERROR AT DATA LINE 0
4021 
4022 
4023          POP      B                        ;GET RID OF THE POINTER INTO THE VARIABLE LIST
4024 
4025          LXI      H,TRYAGN 
4026 
4027 
4028          CALL     STROUT                   ;PRINT "?REDO FROM START"
4029 
4030 
4031          LHLD     TEMP                     ;START ALL OVER BY GOING BACK
4032 
4033 
4034          RET>                              ;TO NEWSTT POINTING AT THE START OF
4035                                            ;OF THE "INPUT" STATEMENT
4036 INPUT:   
4037 IFN      LENGTH,< 
4038          CPI      34                       ;IS IT A QUOTE?
4039 
4040 IFN      CONTRW,< 
4041          MVI      A,0                      ;BE TALKATIVE
4042 
4043          STA      CNTWFL>                  ;FORCE OUTPUT
4044 
4045 
4046          JNZ      NOTQTI                   ;IF NOT NO MESSAGE
4047 
4048 
4049 IFN      STRING,< 
4050          CALL     STRLTI                   ;MAKE THE MESSAGE A STRING
4051 
4052 
4053          SYNCHK   59                       ;MUST END WITH SEMI-COLON
4054 
4055          PUSH     H                        ;REMEMBER WHERE IT ENDED
4056          CALL     STRPRT                   ;PRINT IT OUT
4057 
4058 
4059          POP      H>       
4060 IFE      STRING,< 
4061          CALL     STROUI   
4062          SYNCHK   59>>                     ;ENDS WITH SEMI-COLON
4063 NOTQTI:  PUSH     H        
4064 IFE      FUNCTS,< 
4065          LHLD     CURLIN                   ;IS IT DIRECT?
4066          MVI      E,ERRID                  ;IF SO "ILLEGAL DIRECT" ERROR
4067          INX      H                        ;DIRECT MEANS THAT
4068          MOV      A,L                      ;CURLIN=65535
4069          ORA      H                        ;ADDED ONE AND GOT 0?
4070          JZ       ERROR>                   ;IF SO, GO COMPLAIN
4071 IFN      FUNCTS,< 
4072          CALL     ERRDIR>                  ;USE COMMON ROUTINE SINCE DEF
4073 
4074 
4075                                            ;DIRECT IS ALSO ILLEGAL
4076 GETAGN:  CALL     QINLIN                   ;TYPE '?' AND INPUT A LINE OF TEXT
4077 
4078 
4079 IFN      LENGTH,<INX H                     ;IF NO INPUT WE QUIT
4080          MOV      A,M      
4081          ORA      A        
4082          DCX      H        
4083          POP      B                        ;TAKE OFF SINCE MAYBE LEAVING
4084          JZ       STPEND                   ;IF EMPTY LEAVE
4085 
4086 
4087          PUSH     B>                       ;PUT BACK SINCE DIDN'T LEAVE
4088          JMP      INPCON   
4089 
4090 
4091 READ:    PUSH     H                        ;SAVE THE TEXT POINTER
4092          LHLD     DATPTR                   ;GET LAST DATA LOCATION
4093 
4094 
4095          XWD      ^O1000,^O366             ;"ORI" TO SET [A] NON-ZERO
4096 INPCON:  XRA      A                        ;SET FLAG THAT THIS IS AN INPUT
4097          STA      FLGINP                   ;STORE THE FLAG
4098 
4099 
4100 ; 
4101 ; IN THE PROCESSING OF DATA AND READ STATEMENTS:
4102 ; ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
4103 ; AND ANOTHER POINTS TO THE LIST OF VARIABLES
4104 ; 
4105 ; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
4106 ; TERMINATOR -- A , : OR END-OF-LINE
4107 ; 
4108          XTHL                              ;[H,L]=VARIABLE LIST POINTER
4109                                            ;DATA POINTER GOES ON THE STACK
4110          XWD      ^O1000,1                 ;"LXI B," OVER THIS CHECK
4111 LOPDT2:  SYNCHK   44                       ;MAKE SURE THERE IS A ","
4112 
4113          CALL     PTRGET                   ;READ THE VARIABLE LIST
4114 
4115 
4116                                            ;AND GET THE POINTER TO A VARIABLE INTO [D,E]
4117          XTHL                              ;PUT THE VARIABLE LIST POINTER ONTO THE
4118                                            ;STACK AND TAKE THE
4119                                            ;DATA LIST POINTER OFF
4120 ; 
4121 ; NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
4122 ; AND SO WE MUST GET DATA OR COMPLAIN
4123 ; 
4124          PUSH     D                        ;SAVE THE POINTER TO THE VARIABLE WE
4125                                            ;ARE ABOUT TO SET UP WITH A VALUE
4126          MOV      A,M                      ;SINCE THE DATA LIST POINTER ALWAYS POINTS
4127                                            ;AT A TERMINATOR LETS READ THE
4128                                            ;TERMINATOR INTO [A] AND SEE WHAT
4129                                            ;IT IS
4130          CPI      44       
4131 
4132          JZ       DATBK                    ;A COMMA SO A VALUE MUST FOLLOW
4133 
4134 
4135 IFE      LENGTH,< 
4136          ORA      A                        ;IN THE 4K VERSION
4137          JNZ      SNERR>                   ;DATA MUST BE ALONE ON A LINE
4138          LDA      FLGINP                   ;SEE WHAT TYPE OF STATEMENT THIS WAS
4139 
4140 
4141          ORA      A        
4142 IFE      LENGTH,< 
4143          INX      H                        ;POINT AT POINTER TO NEXT LINE
4144          JNZ      DATFND>                  ;IF IT IS A READ GO
4145                                            ;SEARCH FOR ANOTHER DATA STATEMENT
4146 IFN      LENGTH,<JNZ DATLOP>  
4147 
4148 
4149          MVI      A,"?"    
4150 
4151          OUTCHR                            ;DOUBLE PROMPT WHEN WE NEED MORE INPUT
4152          CALL     QINLIN                   ;GET A WHOLE LINE AFTER TYPING "?"
4153 
4154 
4155                                            ;THE DATA NOW STARTS AT THE BEGINNING
4156                                            ;OF THE BUFFER
4157                                            ;AND QINLIN LEAVES [H,L]=BUF
4158 DATBK:   
4159 IFE      LENGTH,<POP D                     ;POP OFF POINTER TO THE VARIABLE
4160          INX      H                        ;FUDGE CHARACTER POINTER
4161          CALL     REDINP>                  ;READ A VALUE USING "LET" CODE
4162 IFN      LENGTH,< 
4163 IFN      STRING,< 
4164          LDA      VALTYP                   ;SEE IF ITS NUMERIC OR STRING
4165 
4166 
4167 IFE      LENGTH-2,<
4168          CPI      3                        ;IS IT A STRING ?
4169 
4170          PUSH     PSW                      ;SAVE THE TYPE INFORMATION
4171          JNZ      NUMINS>                  ;IF NUMERIC, USE FIN TO GET IT
4172 
4173 
4174 IFN      LENGTH-2,<
4175          ORA      A        
4176          JZ       NUMINS>                  ;INPUT A NUMBER IF NUMERIC
4177                                            ;ONLY THE VARAIBLE TYPE IS
4178                                            ;CHECKED SO AN UNQUOTED STRING
4179                                            ;CAN BE ALL DIGITS
4180          CHRGET   
4181          MOV      D,A                      ;ASSUME QUOTED STRING
4182          MOV      B,A                      ;SETUP TERMINATORS
4183          CPI      34                       ;QUOTE ?
4184 
4185          JZ       NOWGET                   ;TERMINATORS OK
4186 
4187 
4188          MVI      D,":"                    ;UNQUOTED STRING TERMINATORS
4189 
4190          MVI      B,44                     ;ARE COLON AND COMMA
4191 
4192          DCX      H                        ;BACKUP SINCE START CHARACTER MUST BE INCLUDED
4193 
4194                                            ;IN THE QUOTED STRING CASE WE DON'T WANT TO
4195                                            ;INCLUDE THE STARTING OR ENDING QUOTE
4196 NOWGET:  CALL     STRLT2                   ;MAKE A STRING DESCRIPTOR FOR THE VALUE
4197 
4198 
4199                                            ;AND COPY IF NECESSARY
4200 IFE      LENGTH-2,<
4201 DOASIG:  POP      PSW>                     ;POP OFF THE TYPE INFORMATION
4202          XCHG                              ;[D,E]=TEXT POINTER
4203          LXI      H,STRDN2                 ;RETURN LOC
4204 
4205 
4206          XTHL                              ;[H,L]=PLACE TO STORE VARIABLE VALUE
4207          PUSH     D                        ;TEXT POINTER GOES ON
4208          JMP      INPCOM>                  ;DO ASSIGNMENT
4209 
4210 
4211 NUMINS:  CHRGET   
4212          CALL     FIN      
4213 
4214 
4215 IFE      LENGTH-2,<
4216          JMP      DOASIG>                  ;ASSIGNMENT IS COMPLICATED
4217 
4218 
4219                                            ;EVEN FOR NUMERICS SO USE THE "LET" CODE
4220 IFN      LENGTH-2,<
4221          XTHL                              ;[H,L] GET POINTER AT VARIABLE
4222          CALL     MOVMF                    ;DO THE ASSIGNMENT
4223          POP      H>>                      ;GET BACK THE TEXT POINTER
4224 STRDN2:  
4225 IFN      LENGTH,< 
4226          DCX      H        
4227          CHRGET   
4228          JZ       TRMOK    
4229 
4230 
4231          CPI      44       
4232 
4233          JNZ      TRMNOK>                  ;ENDED PROPERLY?
4234 
4235 
4236 TRMOK:   XTHL     
4237          DCX      H                        ;LOOK AT TERMINATOR
4238          CHRGET                            ;AND SET UP CONDITION CODES
4239          JNZ      LOPDT2                   ;NOT ENDING, CHECK FOR COMMA
4240 
4241 
4242                                            ;AND GET ANOTHER VARIABLE
4243                                            ;TO FILL WITH DATA
4244 
4245          POP      D                        ;POP OFF THE POINTER INTO DATA
4246          LDA      FLGINP                   ;FETCH THE STATEMENT TYPE FLAG
4247 
4248 
4249          ORA      A        
4250 IFE      LENGTH,<RZ>                       ;DON'T UPDATE DATPTR IF IT WAS AN
4251                                            ;INPUT STATEMENT
4252          XCHG     
4253          JNZ      RESFIN                   ;UPDATE DATPTR
4254 
4255 
4256 IFN      LENGTH,< 
4257          ORA      M                        ;COULD HAVE ENDED WITH COMMA OR
4258                                            ;COLON, BUT SHOULD BE A ZERO
4259          LXI      H,EXIGNT                 ;TEXT FOR "EXTRA"
4260 
4261 
4262          PUSH     D                        ;SAVE THE TEXT POINTER
4263          CNZ      STROUT                   ;IF WASN'T REAL END SAY SOMETHING
4264 
4265 
4266          POP      H                        ;GET BACK THE TEXT POINTER
4267          RET      
4268 EXIGNT:  DC"?EXTRA IGNORED"
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283          ACRLF    
4284 
4285          0>       
4286 ; 
4287 ; SUBROUTINE TO FIND DATA
4288 ; IN THE 4K "DATA" MUST BE AT THE START OF THE LINE
4289 ; SO THE SEARCH IS MADE USING THE LINKS AT THE START OF EACH LINE.
4290 ; 
4291 ; IN THE 8K AND EXTENDED THE SEARCH IS MADE BY USING THE EXECUTION CODE
4292 ; FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
4293 ; IS COMPARED WITH DATATK. EACH NEW LINE NUMBER
4294 ; IS STORED IN OATLIN SO THAT IF AN ERROR OCCURS WHILE READING
4295 ; DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE
4296 ; ILL-FORMATTED DATA
4297 ; 
4298 DATLOP:  IFN      LENGTH,<CALL DATA>    
4299 
4300 
4301 IFE      LENGTH,<POP H>       
4302 DATFND:  IFN      LENGTH,< 
4303          ORA      A        
4304          JNZ      NOWLIN>  
4305 
4306 
4307 IFN      LENGTH,< 
4308          INX      H>       
4309          PUSHM                             ;SAVE POINTER TO THE NEXT STATEMENT
4310          MOV      A,C                      ;SEE IF WE ARE AT THE END
4311          ORA      B        
4312          MVI      E,ERROD                  ;NO DATA IS ERROR ERROD
4313 
4314          JZ       ERROR                    ;IF SO COMPLAIN
4315 
4316 
4317 IFE      LENGTH,<INX H>                    ;SKIP PAST LINE #
4318 IFN      LENGTH,<POP B        
4319          MOV      E,M                      ;GET DATA LINE #
4320          INX      H        
4321          MOV      D,M      
4322          XCHG     
4323          SHLD     DATLIN   
4324 
4325 
4326          XCHG>                             ;RESTORE TEXT POINTER
4327 NOWLIN:  CHRGET                            ;GET THE STATEMENT TYPE
4328          CPI      DATATK                   ;IS IS "DATA"?
4329 
4330          JNZ      DATLOP                   ;NOT DATA SO LOOK SOME MORE
4331 
4332 
4333 IFE      LENGTH,<POP B>       
4334          JMP      DATBK                    ;CONTINUE READING
4335 
4336 
4337 
4338 
4339 
4340 PAGE     
4341 SUBTTL   NEXT CODE
4342 ; 
4343 ; NOTE:
4344 ; 
4345 ; 
4346 ; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
4347 ; 
4348 ; 
4349 ; LOW ADDRESS
4350 ;       TOKEN (FORTK IN HIGH BYTE) 1 BYTES
4351 ;       A POINTER TO THE LOOP VARIABLE 2 BYTES
4352 ;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
4353 ;       THE STEP 4 BYTES
4354 ;       THE UPPER VALUE 4 BYTES
4355 ;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
4356 ;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
4357 ; HIGH ADDRESS
4358 ; 
4359 ; TOTAL 16 BYTES
4360 ; 
4361 NEXT:    
4362 IFN      LENGTH,<LXI D,$CODE>              ;FOR THE "NEXT"
4363 
4364 
4365                                            ;STATEMENT WITHOUT ANY ARGS
4366                                            ;WE CALL FNDFOR WITH [D,E]=0
4367 NEXTC:   
4368 IFE      LENGTH,< 
4369          CALL     PTRGET>                  ;MUST HAVE A VARIABLE
4370 IFN      LENGTH,< 
4371          CNZ      PTRGET>                  ;GET A POINTER TO THE
4372 
4373 
4374                                            ;LOOP VARIABLE INTO [D,E]
4375          SHLD     TEMP                     ;PUT THE TEXT POINTER
4376 
4377 
4378                                            ;IN A TEMP LOCATION
4379                                            ;IN CASE THE LOOP TERMINATES
4380          CALL     FNDFOR                   ;TRY TO FIND A FOR ENTRY
4381 
4382 
4383                                            ;ON THE STACK WHOSE VARIABLE NAME
4384                                            ;MATCHES THIS ONES
4385 IFN      LENGTH,< 
4386          JNZ      NFERR>                   ;"NEXT WITHOUT FOR"
4387 
4388 
4389          SPHL                              ;SETUP STACK POINTER BY CHOPPING
4390                                            ;AT THIS POINT
4391          PUSH     D                        ;PUT THE VARIABLE PTR BACK ON
4392          MOV      A,M                      ;STEP ONTO THE STACK
4393          INX      H        
4394          PUSH     PSW      
4395          PUSH     D                        ;PUT THE POINTER TO THE LOOP
4396                                            ;VARIABLE ONTO THE STACK
4397 IFE      LENGTH,< 
4398          MVI      E,ERRNF  
4399          JNZ      ERROR>   
4400          CALL     MOVFM                    ;STEP VALUE INTO THE FAC
4401 
4402 
4403          XTHL                              ;PUT THE POINTER INTO THE
4404                                            ;FOR ENTRY ONTO THE STACK
4405          PUSH     H                        ;PUT THE POINTER TO THE LOOP
4406                                            ;VARIABLE BACK ONTO THE STACK
4407          CALL     FADDS                    ;ADD THE STEP AND LOOP VARIABLE
4408 
4409 
4410          POP      H                        ;POP OFF THE POINTER TO
4411                                            ;THE LOOP VARIABLE
4412          CALL     MOVMF                    ;MOV FAC INTO LOOP VARIABLE
4413 
4414 
4415          POP      H                        ;GET THE ENTRY POINTER
4416          CALL     MOVRM                    ;GET THE FINAL INTO THE REGISTERS
4417 
4418 
4419          PUSH     H                        ;SAVE THE ENTRY POINTER
4420          CALL     FCOMP                    ;COMPARE THE NUMBERS
4421 
4422 
4423          POP      H                        ;STILL POINTING TO THE FINAL VALUE
4424          POP      B                        ;GET THE SIGN OF THE INCREMENT
4425          SUB      B                        ;SUBTRACT THE INCREMENTS SIGN FROM THAT
4426                                            ;OF (CURRENT VALUE-FINAL VALUE)
4427          CALL     MOVRM                    ;GET LINE # OF "FOR" INTO [D,E]
4428 
4429 
4430                                            ;GET TEXT POINTER OF "FOR" INTO [B,C]
4431          JZ       LOOPON                   ;IF SIGN(FINAL-CURRENT)+SIGN(STEP)=0
4432 
4433 
4434                                            ;THEN THE LOOP IS FINISHED
4435          XCHG     
4436          SHLD     CURLIN                   ;STORE THE LINE #
4437 
4438 
4439          MOV      L,C                      ;SETUP THE TEXT POINTER
4440          MOV      H,B      
4441          JMP      NXTCON   
4442 
4443 
4444 
4445 LOOPDN:  SPHL                              ;ELIMINATE THE FOR ENTRY
4446                                            ;SINCE [H,L] MOVED ALL
4447                                            ;THE WAY DOWN THE ENTRY
4448          LHLD     TEMP                     ;RESTORE THE TEXT POINTER
4449 
4450 
4451 IFE      LENGTH,<JMP NEWSTT>  
4452 IFN      LENGTH,< 
4453          MOV      A,M                      ;IS THERE A COMMA AT THE END
4454          CPI      44                       ;IF SO LOOK AT ANOTHER
4455 
4456          JNZ      NEWSTT                   ;VARIABLE NAME TO "NEXT"
4457 
4458 
4459          CHRGET                            ;READ FIRST CHARCTER
4460          CALL     NEXTC>                   ;DO NEXT, BUT DON'T ALLOW
4461 
4462 
4463                                            ;BLANK VARIABLE NAME [D,E]=STK PTR
4464                                            ;AND WILL NEVER MATCH ANY VARPTR
4465                                            ;USE CALL TO PUT DUMMY "NEWSTT" ENTRY ON
4466 
4467 PAGE     
4468 
4469 
4470 SUBTTL   FORMULA EVALUATION CODE
4471 
4472 IFN      LENGTH-2,<
4473 IFN      STRING,< 
4474 ; 
4475 ; THESE ROUTINES CHECK FOR A CERTAIN VALTYP
4476 ; [A] IS NOT PRESERVED
4477 ; 
4478 FRMNUM:  CALL     FRMEVL                   ;EVALUATE A FORMULA
4479 CHKNUM:  XWD      ^O1000,^O366             ;TURN CARRY OFF WITH ORI
4480 CHKSTR:  STC                               ;SET CARRY
4481 CHKVAL:  LDA      VALTYP                   ;0 MEANS NUMERIC 1 MEANS STRING
4482          ADC      A                        ;RESULT SHOULD BE 0 OR 3
4483                                            ;BAD RESULTS ARE 2 AND 1
4484          RPE                               ;RETURN IF CORRECT RESULT
4485 TMERR:   MVI      E,ERRTM                  ;"TYPE MISMATCH ERROR"
4486          JMP      ERROR    
4487 ; 
4488 ; THE FORMULA EVALUATOR STARTS WITH
4489 ; [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA,
4490 ; AT THE END [H,L] POINTS TO THE TERMINATOR.
4491 ; THE RESULT IS LEFT IN THE FAC.
4492 ; 
4493 ; THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
4494 ; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
4495 ; EACH OPERATOR.
4496 ; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
4497 ; 
4498 ; THE ADDRESS OF RETAOP -- THE PLACE TO RETURN ON COMPLETION
4499 ; OF OPERATOR APPLICATION
4500 ; 
4501 ; THE FLOATING POINT TEMPORARY RESULT
4502 ; 
4503 ; THE ADDRESS OF THE OPERATOR ROUNTINE
4504 ; 
4505 ; THE PRECEDENCE OF THE OPERATOR
4506 ; 
4507 ; TOTAL 10 BYTES
4508 ; 
4509 IFE      STRING,<FRMNUM:>
4510 FRMEVL:  DCX      H                        ;BACK UP CHARACTER POINTER
4511 FRMCHK:  MVI      D,0                      ;INITIAL DUMMY PRECEDENCE IS 0
4512 
4513 LPOPER:  PUSH     D                        ;SAVE PRECEDENCE
4514          CALL     GETSTK                   ;MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
4515 
4516 
4517          1        
4518          CALL     EVAL                     ;EVALUATE SOMETHING
4519 
4520 
4521          SHLD     TEMP2                    ;SAVE TEXT POINTER
4522 
4523 
4524 RETAOP:  LHLD     TEMP2                    ;RESTORE TEXT PTR
4525 
4526 
4527 TSTOP:   POP      B                        ;POP OFF THE PRECEDENCE OF OLDOP
4528 IFN      LENGTH-2,<
4529 IFN      STRING,< 
4530          MOV      A,B                      ;LOOK AT PRECEDENCE
4531          CPI      120                      ;IF ITS SOME ARITHMETIC
4532                                            ;TYPE THING WE SHOULDN'T
4533                                            ;SEE STRINGS
4534          CNC      CHKNUM>>                 ;TYPE MISMATCH ERROR IF NOT NUMERIC
4535 NOTSTV:  MOV      A,M                      ;GET NEXT CHARACTER
4536 IFN      LENGTH,< 
4537          MVI      D,0                      ;ASSUME NO RELATION OPS
4538 
4539 LOPREL:  SUI      GREATK                   ;IS THIS ONE RELATION?
4540 
4541          JC       ENDREL                   ;RELATIONS ALL THROUGH
4542 
4543 
4544          NMREL==LESSTK-GREATK+1
4545          CPI      NMREL                    ;IS IT REALLY RELATIONAL?
4546 
4547          JNC      ENDREL                   ;NO JUST BIG
4548 
4549 
4550          CPI      1                        ;SET UP BITS BY MAPPING
4551 
4552          RAL                               ;0 TO 1 1 TO 2 AND 2 TO 4
4553          XRA      D                        ;BRING IN THE OLD BITS
4554          CMP      D                        ;MAKE SURE RESULT IS BIGGER
4555          MOV      D,A                      ;SAVE THE MASK
4556          JC       SNERR                    ;DON'T ALLOW TWO OF THE SAME
4557 
4558 
4559          SHLD     TEMP3                    ;SAVE CHARACTER POINTER
4560 
4561 
4562          CHRGET                            ;GET THE NEXT CANDIDATE
4563          JMP      LOPREL   
4564 
4565 
4566 ENDREL:  MOV      A,D                      ;GET THE MASK
4567          ORA      A                        ;WERE THERE ANY?
4568          JNZ      FINREL                   ;IF SO, HANDLE AS SPECIAL OP
4569 
4570 
4571          MOV      A,M                      ;GET THE CHARACTER AGAIN
4572          SHLD     TEMP3>                   ;SAVE UPDATED CHARACTER POINTER
4573 
4574 
4575          SUI      PLUSTK                   ;AN OPERATOR?
4576 
4577          RC                                ;RETURN IF NOT
4578                                            ;THIS CAN RESULT IN OPERATOR
4579                                            ;APPLICATION OR ACTUAL RETURN
4580          CPI      LSTOPK                   ;HIGHER THAN THE LAST OP?
4581 
4582          RNC      
4583          MOV      E,A                      ;MUST MUTIPLY BY 3 SINCE
4584                                            ;OPTAB ENTRIES ARE 3 LONG
4585 IFN      STRING,< 
4586          LDA      VALTYP                   ;SEE IF LEFT PART IS STRING
4587 
4588 
4589 IFE      LENGTH-2,<
4590          CPI      3>                       ;SEE IF ITS A STRING
4591 
4592 IFN      LENGTH-2,<
4593          DCR      A>       
4594          ORA      E                        ;SET CONDITION CODES
4595 IFN      LENGTH-2,<
4596          MOV      A,E>                     ;REFETCH OP-VALUE
4597          JZ       CAT>                     ;MUST BE CAT
4598 
4599 
4600 IFN      LENGTH-2,<
4601          RLC                               ;A= ORIGINAL A*2
4602          ADD      E                        ;ADD IN ORIGINAL A
4603          MOV      E,A>                     ;CREATE TWO BYTE VALUE
4604 IFE      LENGTH,< 
4605          MVI      D,0>                     ;HIGH ORDER #0
4606          LXI      H,OPTAB                  ;CREATE INDEX INTO OPTAB
4607 
4608 
4609          DAD      D                        ;ADD IN CALCULATED OFFSET
4610          MOV      A,B                      ;[A] GETS OLD PRECEDENCE
4611          MOV      D,M                      ;REMEMBER NEW PRECEDENCE
4612          CMP      D                        ;OLD=NEW
4613          RNC                               ;MUST APPLY OLD OP
4614                                            ;IF HAS GREATER OR = PRECEDENCE
4615 IFN      LENGTH-2,<
4616          INX      H                        ;NOW POINTING AT ROUTINE ADDRESS
4617 IFN      STRING,<CALL CHKNUM>              ;CAN'T BE STRING HERE
4618                                            ;SINCE THE ONLY STRING OPERATOR
4619                                            ;IS PLUS AND RELATIONALS
4620                                            ;DON'T COME THROUGH HERE
4621 DOPREC:  PUSH     B                        ;SAVE OLD PRECEDENCE
4622          LXI      B,RETAOP                 ;OPERATOR RETURN ADDRESS
4623          PUSH     B                        ;FIRST PART OF "TEMP" ENTRY
4624 IFN      LENGTH,< 
4625          MOV      B,E>                     ;SAVE SECOND BYTE OF PRECEDENCE
4626                                            ;SINCE FOR RELATIONAL OPERATORS
4627                                            ;IT GIVES THE VALUE TYPE OF
4628                                            ;THE LEFT SIDE AND IT TELLS
4629                                            ;WHICH RELATIONAL-OPERATOR
4630                                            ;IT WAS
4631          MOV      C,D      
4632          CALL     PUSHF    
4633 IFN      LENGTH,< 
4634          MOV      E,B>                     ;GET SECOND BYTE OF PRECEDENCE AGAIN
4635          MOV      D,C                      ;[D] GETS PRECEDENCE
4636          PUSHM                             ;PUT ROUTINE ADDRESS ON THE STACK
4637 IFN      LENGTH,< 
4638          LHLD     TEMP3>   
4639 IFE      LENGTH,< 
4640          LHLD     TEMP2>                   ;IF WE DONT HAVE "LENGTH"
4641                                            ;ON OPERATORS CAN ONLY
4642                                            ;BE ONE CHARACTER SO TO "REREAD"
4643                                            ;AN OPERATOR THAT WE LOOKED
4644                                            ;AT BEFORE AND DECIDED NOT TO
4645                                            ;APPLY WE JUST "DCX H"
4646                                            ;IF LENGTH IS ON WE HAVE TO
4647                                            ;REMEMBER THE TEXT POINTER BEFORE
4648                                            ;THE OPERATOR AND AFTER SO WE CAN
4649                                            ;EITHER RESCAN THE OPERATOR
4650                                            ;LATER IF IT DOESN'T GET APPLIED
4651                                            ;OR GO BEYOND IT WHEN IT DOES
4652          JMP      LPOPER>                  ;PUT ON PRECEDENCE AND LOOK AT A
4653                                            ;NEW OPERATOR
4654 
4655 IFE      LENGTH-2,<
4656          PUSH     B                        ;SAVE THE OLD PRECEDENCE
4657          LXI      B,RETAOP                 ;PUT ON THE ADDRESS OF THE
4658 
4659 
4660          PUSH     B                        ;PLACE TO RETURN TO AFTER OPERATOR APPLICATION
4661 
4662          MOV      A,D                      ;SEE IF THE OPERATOR IS EXPONENTIATION
4663          CPI      127                      ;WHICH HAS PRECEDENCE 127
4664 
4665          JZ       EXPSTK                   ;IF SO, "FRCSNG" AND MAKE A SPECIAL STACK ENTRY
4666 
4667 
4668 
4669          CPI      81                       ;SEE IF THE OPERATOR IS "AND" OR "OR"
4670 
4671          JC       ANDORD                   ;AND IF SO "FRCINT" AND
4672 
4673 
4674                                            ;MAKE A SPECIAL STACK ENTRY
4675 ; 
4676 ; THIS CODE PUSHES THE CURRENT VALUE IN THE FAC
4677 ; ONTO THE STACK, EXCEPT IN THE CASE OF STRINGS IN WHICH IT CALLS
4678 ; TYPE MISMATCH ERROR. [D] AND [E] ARE PRESERVED.
4679 ; 
4680 NUMREL:  LDA      VALTYP                   ;GET THE VALUE TYPE
4681 
4682 
4683          CPI      3                        ;AND SET THE CONDITION CODES BASED ON IT
4684 
4685          JZ       TMERR                    ;BLOW UP ON STRINGS
4686 
4687 
4688          LXI      H,FACLO                  ;GET POINTER TO LO IN FAC
4689 
4690 
4691          MOV      C,M      
4692          INX      H        
4693          MOV      B,M      
4694          INX      H        
4695          PUSH     B                        ;PUSH FACLO+0,1 ON THE STACK
4696          JM       VPUSHD                   ;ALL DONE IF THE DATA WAS AN INTEGER
4697 
4698 
4699          MOV      C,M      
4700          INX      H        
4701          MOV      B,M      
4702          INX      H        
4703          PUSH     B                        ;PUSH FAC-1,0 ON THE STACK
4704          JPO      VPUSHD                   ;ALL DONE IF WE HAD A SNG
4705 
4706 
4707          LXI      H,DFACLO                 ;WE HAVE A DOUBLE PRECISON NUMBER
4708 
4709 
4710          PUSHM                             ;PUSH ITS 4 LO BYTES ON THE STACK
4711          PUSHM    
4712 VPUSHD:  MOV      C,E                      ;[C]=OPERATOR NUMBER
4713          MOV      B,A                      ;B=TYPE OF VALUE ON THE STACK
4714          PUSH     B                        ;SAVE THESE THINGS FOR APPLOP
4715          LXI      B,APPLOP                 ;GENERAL OPERATOR APPLICATION
4716 
4717 
4718                                            ;ROUTINE -- DOES TYPE CONVERSIONS
4719 FINTMP:  PUSH     B                        ;SAVE PLACE TO GO
4720          LHLD     TEMP3                    ;REGET THE TEXT POINTER
4721 
4722 
4723          JMP      LPOPER                   ;PUSH ON THE PRECEDENCE AND READ MORE
4724 
4725 ; 
4726 ; FORMULA
4727 ; 
4728 ; FOR EXPONENTIATION WE WANT TO FORCE THE CURRENT VALUE IN THE FAC
4729 ; TO BE SINGLE PRECISION. WHEN APPLICATION TIME COMES WE FORCE
4730 ; THE RIGHT HAND OPERAND TO SINGLE PRECISION AS WELL
4731 ; 
4732 EXPSTK:  CALL     FRCSNG                   ;COERCE LEFT HAND OPERAND
4733 
4734 
4735          CALL     PUSHF                    ;PUT IT ON THE STACK
4736 
4737 
4738          LXI      B,FPWRQ##                ;PLACE TO COERCE RIGHT HAND
4739 
4740 
4741                                            ;OPERAND AND DO EXPONENTIATION
4742          MVI      D,127                    ;RESTORE THE PRECEDENCE
4743 
4744          JMP      FINTMP                   ;FINISH ENTRY AND EVALUATE MORE FORMULA
4745 
4746 
4747 ; 
4748 ; FOR "AND" AND "OR" WE WANT TO FORCE THE CURRENT VALUE IN THE
4749 ; FAC TO BE AN INTEGER, AND AT APPLICATION TIME FORCE THE RIGHT
4750 ; HAND OPERAND TO BE AN INTEGER
4751 ; 
4752 ANDORD:  PUSH     D                        ;SAVE THE PRECEDENCE (70 OR 80)
4753          CALL     FRCINT   
4754 
4755 
4756          POP      D                        ;[D]=PRECEDENCE
4757          PUSH     H                        ;PUSH THE LEFT HAND OPERAND
4758          LXI      B,DANDOR                 ;"AND" AND "OR" DOER
4759 
4760 
4761          JMP      FINTMP                   ;PUSH ON THIS ADDRESS, PRECEDENCE
4762 
4763 ; 
4764 ; AND CONTINUE EVALUATION
4765 ; 
4766 ; HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
4767 ; STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
4768 ; FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
4769 ; BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
4770 ; BITS ARE STORED. STRINGS HAVE STRCMP, THE POINTER AT THE STRING DESCRIPTOR,
4771 ; DOCMP AND THE RELATIONAL BITS.
4772 ; 
4773 FINREL:  MOV      A,B                      ;[A]=OLD PRECEDENCE
4774          CPI      100                      ;RELATIONALS HAVE PRECEDENCE 100
4775 
4776          RNC                               ;APPLY EARLIER OPERATOR IF IT HAS
4777                                            ;HIGHER PRECEDENCE
4778          PUSH     B                        ;SAVE THE OLD PRECEDENCE
4779          PUSH     D                        ;SAVE [D]=RELATIONAL BITS
4780          LXI      D,$CODE+25604            ;[D]=PRECEDENCE=100
4781 
4782 
4783                                            ;[E]=DISPATCH OFFSET FOR
4784                                            ;COMPARES IN APPLOP=4
4785                                            ;IN CASE THIS IS A NUMERIC COMPARE
4786          LXI      H,DOCMP                  ;ROUTINE TO TAKE COMPARE ROUTINE RESULT
4787 
4788 
4789                                            ;AND RELATIONAL BITS AND RETURN THE ANSWER
4790          PUSH     H                        ;DOES A JMP TO RETAOP WHEN DONE
4791          CALL     GETYPE                   ;SEE IF WE HAVE A NUMERIC COMPARE
4792 
4793 
4794          JNZ      NUMREL                   ;YES, BUILD AN APPLOP ENTRY
4795 
4796 
4797          LHLD     FACLO                    ;GET THE POINTER AT THE STRING DESCRIPTOR
4798 
4799 
4800          PUSH     H                        ;SAVE IT FOR STRCMP
4801          LXI      B,STRCMP                 ;STRING COMPARE ROUTINE
4802 
4803 
4804          JMP      FINTMP                   ;PUSH THE ADDRESS, REGET THE TEXT POINTER
4805 
4806 
4807                                            ;SAVE THE PRECEDENCE AND SCAN
4808                                            ;MORE OF THE FORMULA
4809 ; 
4810 ; APPLOP IS RETURNED TO WHEN IT IS TIME TO APPLY AN ARITHMETIC
4811 ; OR NUMERIC COMPARISON OPERATION,
4812 ; THE STACK HAS A DOUBLE BYTE ENTRY WITH THE OPERATOR
4813 ; NUMBER AND THE VALTYP OF THE VALUE ON THE STACK.
4814 ; APPLOP DECIDES WHAT VALUE LEVEL THE OPERATION
4815 ; WILL OCCUR AT, AND CONVERTS THE ARGUMENTS, APPLOP
4816 ; USES DIFFERENT CALLING CONVENTIONS FOR EACH VALUE TYPE.
4817 ; INTEGERS: LEFT IN [D,E] RIGHT IN [H,L]
4818 ; SINGLES: LEFT IN [B,C,D,E] RIGHT IN THE FAC
4819 ; DOUBLES: LEFT IN FAC RIGHT IN ARG
4820 ; 
4821 APPLOP:  POP      B                        ;[B]=STACK OPERAND VALUE TYPE
4822                                            ;[C]=OPERATOR OFFSET
4823          MOV      A,C                      ;SAVE IN MEMORY SINCE THE STACK WILL BE BUSY
4824          STA      OPRTYP                   ;A RAM LOCATION
4825 
4826 
4827          MOV      A,B                      ;CHECK FOR DOUBLE
4828          CPI      8                        ;PRECISION ENTRY ON THE STACK
4829 
4830          JZ       STKDBL                   ;FORCE FAC TO DOUBLE
4831 
4832 
4833          LDA      VALTYP                   ;SEE IF THE FAC IS DOUBLE PRECISION
4834 
4835 
4836          CPI      8                        ;AND IF SO, CONVERT THE STACK OPERAND
4837 
4838          JZ       FACOBL                   ;TO DOUBLE PRECISION
4839 
4840 
4841          MOV      D,A                      ;SAVE THE VALUE TYPE OF THE FAC
4842          MOV      A,B                      ;SEE IF THE STACK ENTRY IS SINGLE
4843          CPI      4                        ;PRECISION AND IF SO, CONVERT
4844 
4845          JZ       STKSNG                   ;THE FAC TO SINGLE PRECISION
4846 
4847 
4848          MOV      A,D                      ;SEE IF THE FAC IS SINGLE PRECISION
4849          CPI      3                        ;AND IF SO CONVERT THE STACK TO SINGLE
4850 
4851          JNC      FACSNG                   ;PRECISION
4852 
4853 
4854                                            ;NOTE: THE STACK MUST BE INTEGER AT THIS POINT
4855          JZ       TMERR                    ;BLOW UP ON RIGHT HAND STRING OPERAND
4856 
4857 
4858          LXI      H,INTDSP                 ;INTEGER INTEGER CASE
4859 
4860 
4861          MVI      B,0                      ;SPECIAL DISPATCH FOR SPEED
4862 
4863          DAD      B                        ;[H,L] POINTS TO THE ADDRESS TO GO TO
4864          DAD      B        
4865          MOV      C,M                      ;[B,C]=ROUTINE ADDRESS
4866          INX      H        
4867          MOV      B,M      
4868          POP      D                        ;[D,E]=LEFT HAND OPERAND
4869          LHLD     FACLO                    ;[H,L]=RIGHT HAND OPERAND
4870 
4871 
4872          PUSH     B                        ;DISPATCH
4873          RET      
4874 ; 
4875 ; THE STACK OPERAND IS DOUBLE PRECISION, SO
4876 ; THE FAC MUST BE FORCED TO DOUBLE PRECISION, MOVED INTO ARG
4877 ; AND THE STACK VALUE POPED INTO THE FAC
4878 ; 
4879 STKDBL:  CALL     FRCOBL                   ;MAKE THE FAC DOUBLE PRECISION
4880 
4881 
4882          CALL     VMOVAF                   ;MOVE THE FAC INTO ARG
4883 
4884 
4885          POP      H                        ;POP OFF THE STACK OPERAND INTO THE FAC
4886          SHLD     DFACLO+2 
4887 
4888 
4889          POP      H        
4890          SHLD     DFACLO                   ;STORE LOW BYTES AWAY
4891 
4892 
4893 SNGDBL:  POPR                              ;POP OFF A FOUR BYTE VALUE
4894 
4895          CALL     MOVFR                    ;INTO THE FAC
4896 
4897 
4898 SETDBL:  CALL     FRCOBL                   ;MAKE SURE THE LEFT OPERAND IS
4899 
4900 
4901                                            ;DOUBLE PRECISION
4902          LXI      H,DBLDSP                 ;DISPATCH TO A DOUBLE PRECISION ROUTINE
4903 
4904 
4905 DODSP:   LDA      OPRTYP                   ;RECALL WHICH OPERAND IT WAS
4906 
4907 
4908          RLC                               ;CREATE A DISPATCH OFFSET, SINCE
4909                                            ;STABLE ADDRESSES ARE TWO BYTES
4910          PUSH     B                        ;SAVE [B,C] FOR SINGLE PRECISION
4911          MOV      C,A                      ;DOUBLE BYTE OFFSET
4912          MVI      B,0                      ;INTO [B,C]
4913 
4914          DAD      B                        ;CALCULATE LOCATION OF ROUTINE TO GO TO
4915          POP      B                        ;GET BACK [B,C] FOR SINGLE PRECISION
4916          MOV      A,M                      ;GET THE ADDRESS
4917          INX      H        
4918          MOV      H,M      
4919          MOV      L,A      
4920          PCHL                              ;AND PERFORM THE OPERATION, RETURNING
4921                                            ;TO RETAOP, EXCEPT FOR COMPARES WHICH
4922                                            ;RETURN TO DOCMP
4923 ; 
4924 ; THE FAC IS DOUBLE PRECISION AND THE STACK IS EITHER
4925 ; INTEGER OR SINGLE PRECISION AND MUST BE CONVERTED
4926 ; 
4927 FACOBL:  PUSH     B                        ;SAVE THE STACK VALUE TYPE
4928          CALL     VMOVAF                   ;MOVE THE FAC INTO ARG .
4929 
4930 
4931          POP      PSW                      ;POP THE STACK VALUE TYPE INTO [A]
4932          STA      VALTYP                   ;PUT IT IN VALTYP FOR THE FORCE
4933 
4934 
4935                                            ;ROUTINE
4936          CPI      4                        ;SEE IF ITS SINGLE, SO WE KNOW
4937 
4938                                            ;HOW TO POP THE VALUE OFF
4939          JZ       SNGDBL                   ;IT'S SINGLE PRECISION
4940 
4941 
4942                                            ;SO DO A POPR / CALL MOVFR
4943          POP      H                        ;POP OFF THE INTEGER VALUE
4944          SHLD     FACLO                    ;SAVE IT FOR CONVERSION
4945 
4946 
4947          JMP      SETDBL                   ;SET IT UP
4948 
4949 
4950 ; 
4951 ; THIS IS THE CASE WHERE THE STACK IS SINGLE PRECISION
4952 ; AND THE FAC IS EITHER SINGLE PRECISION OR INTEGER
4953 ; 
4954 STKSNG:  CALL     FRCSNG                   ;CONVERT THE FAC IF NECESSARY
4955 
4956 
4957          POPR                              ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
4958 
4959 SNGDO:   LXI      H,SNGDSP                 ;SETUP THE DISPATCH ADDRESS
4960 
4961 
4962                                            ;FOR THE SINGLE PRECISION OPERATOR ROUTINES
4963          JMP      DODSP                    ;DISPATCH
4964 
4965 
4966 ; 
4967 ; THIS IS THE CASE WHERE THE FAC IS SINGLE PRECISION AND THE STACK
4968 ; IS AN INTEGER.
4969 ; 
4970 FACSNG:  POP      H                        ;POP OFF THE INTEGER ON THE STACK
4971          CALL     PUSHF                    ;SAVE THE FAC ON THE STACK
4972 
4973 
4974          CALL     CONSIH                   ;CONVERT [H,L] TO A SINGLE PRECISION
4975 
4976 
4977                                            ;NUMBER IN THE FAC
4978          CALL     MOVRF                    ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
4979 
4980 
4981          POP      H                        ;RESTORE THE FAC
4982          SHLD     FAC-1                    ;FROM THE STACK
4983 
4984 
4985          POP      H        
4986          SHLD     FACLO    
4987 
4988 
4989          JMP      SNGDO>                   ;PERFORM THE OPERATION
4990 
4991 
4992 
4993 EVAL:    
4994 IFN      LENGTH-2,<
4995 IFN      STRING,< 
4996          XRA      A        
4997          STA      VALTYP>>                 ;ASSUME THE VALUE WILL BE NUMERIC
4998          CHRGET   
4999          JC       FIN                      ;IF NUMERIC, INTERPRET CONSTANT
5000 
5001 
5002          CALL     ISLET                    ;VARIABLE NAME?
5003 
5004 
5005          JNC      ISVAR                    ;AN ALPHABETIC CHARACTER MEANS YES
5006 
5007 
5008          CPI      PLUSTK                   ;IGNORE "+"
5009 
5010          JZ       EVAL     
5011 
5012 
5013          CPI      "."                      ;"." AS LEADING CHARACTER OF A
5014 
5015                                            ;CONSTANT?
5016          JZ       FIN      
5017 
5018 
5019          CPI      MINUTK                   ;NEGATION?
5020 
5021          JZ       DOMIN    
5022 
5023 
5024 IFN      STRING,< 
5025          CPI      34                       ;STRING CONSTANT?
5026 
5027          JZ       STRLTI>                  ;IF SO BUILD A DESCRIPTOR IN A TEMPORARY
5028 
5029 
5030                                            ;DESCRIPTOR LOCATION AND PUT A POINTER TO THE
5031                                            ;DESCRIPTOR IN FACLO.
5032 IFN      LENGTH,< 
5033          CPI      NOTTK                    ;CHECK FOR "NOT" OPERATOR
5034 
5035          JZ       NOTER>   
5036 
5037 
5038 IFN      FUNCTS,< 
5039          CPI      FNTK                     ;USER-DEFINED FUNCTION?
5040 
5041          JZ       FNDOER>  
5042 
5043 
5044          SUI      ONEFUN                   ;IS IT A FUNCTION NAME?
5045 
5046          JNC      ISFUN                    ;FUNCTIONS ARE THE HIGHEST
5047 
5048 
5049                                            ;NUMBERED CHARACTERS ALLOWED
5050                                            ;SO THERE IS NO NEED TO CHECK
5051                                            ;THE UPPER BOUND
5052 PARCHK:  SYNCHK   "("                      ;ONLY POSSIBILITY LEFT
5053 
5054                                            ;IS A FORMULA IN PARENTHESES
5055          CALL     FRMEVL                   ;RECURSIVELY EVALUATE THE FORMULA
5056 
5057 
5058          SYNCHK   ")"      
5059 
5060          RET      
5061 DOMIN:   
5062 IFE      EXTFNC,< 
5063          CALL     EVAL>                    ;NO ^ OPERATOR IN THIS CASE
5064 IFN      EXTFNC,< 
5065          MVI      D,125                    ;A PRECEDENCE BELOW ^
5066 
5067                                            ;BUT ABOVE ALL ELSE
5068          CALL     LPOPER                   ;SO ^ GREATER THAN UNARY MINUS
5069 
5070 
5071          LHLD     TEMP2>                   ;GET TEXT POINTER
5072 
5073 
5074          PUSH     H        
5075 IFE      LENGTH-2,<
5076          CALL     VNEG>    
5077 
5078 
5079 IFN      LENGTH-2,<
5080          CALL     NEG>                     ;NEGATE THE FAC.
5081 LABBCK:                                    ;FUNCTIONS THAT DON'T RETURN
5082                                            ;STRING VALUES COME BACK HERE
5083 IFN      LENGTH-2,<
5084 IFN      STRING,< 
5085          CALL     CHKNUM>> 
5086          POP      H        
5087          RET      
5088 ISVAR:   CALL     PTRGET                   ;GET A POINTER TO THE
5089 
5090 
5091                                            ;VARIABLE IN [D,E]
5092          PUSH     H                        ;SAVE THE TEXT POINTER
5093 IFE      STRING,< 
5094          XCHG                              ;TRANSFER THE POINTER AT THE VALUE
5095          INTO     [H,L]    
5096          CALL     MOVFM>                   ;SETUP FAC WITH VARIABLE VALUE
5097 IFN      STRING,< 
5098          XCHG                              ;PUT THE POINTER TO THE VARIABLE VALUE
5099                                            ;INTO [H,L]. IN THE CASE OF A STRING
5100                                            ;THIS IS A POINTER TO A DESCRIPTOR AND NOT
5101                                            ;AN ACTUAL VALUE
5102          SHLD     FACLO                    ;IN CASE IT'S STRING STORE THE POINTER
5103 
5104 
5105                                            ;TO THE DESCRIPTOR IN FACLO.
5106 IFE      LENGTH-2,<
5107          CALL     GETYPE                   ;FOR STRINGS WE JUST LEAVE
5108 
5109 
5110          CNZ      VMOVFM>                  ;A POINTER IN THE FAC
5111 
5112 
5113 IFN      LENGTH-2,<
5114          LDA      VALTYP   
5115          ORA      A        
5116          CZ       MOVFM>>                  ;IF NOT, ACTUALLY TRANSFER THE VALUE INTO
5117                                            ;THE FAC USING [H,L] AS THE POINTER.
5118          POP      H                        ;RESTORE THE TEXT POINTER
5119          RET      
5120 ISFUN:   MVI      B,0      
5121 
5122          RLC                               ;MULTIPLY BY 2
5123          MOV      C,A      
5124          PUSH     B                        ;SAVE THE FUNCTION # ON THE STACK
5125          CHRGET   
5126 IFN      STRING,< 
5127          MOV      A,C                      ;LOOK AT FUNCTION #
5128          NUMGFN==2*LASNUM-2*ONEFUN+1
5129          CPI      NUMGFN                   ;IS IT PAST LASNUM?
5130 
5131          JC       OKNORM                   ;NO, MUST BE NORMAL FUNCTION
5132 
5133 
5134 ; 
5135 ; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
5136 ; THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
5137 ; THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
5138 ; THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
5139 ; MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
5140 ; TEXT POINTER AND THEN RETURN TO FRMEVL. .
5141 ; 
5142 ; THE 30 CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
5143 ; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH .
5144 ; MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
5145 ; PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
5146 ; CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
5147 ; THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
5148 ; TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
5149 ; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
5150 ; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
5151 ; ARGUMENT (2 BYTES)
5152 ; 
5153          SYNCHK   "("                      ;FIRST ARGUMENT ALWAYS
5154 
5155                                            ;STRING -- SECOND INTEGER
5156          CALL     FRMEVL                   ;EAT OPEN PAREN AND FIRST ARG
5157 
5158 
5159          SYNCHK   44                       ;TWO ARGS SO COMMA MUST DELIMIT
5160 
5161          CALL     CHKSTR                   ;MAKE SURE THE FIRST ONE WAS STRING
5162 
5163 
5164          XCHG     1                        ;[D,E] #TXTPTR
5165          LHLD     FACLO                    ;GET PTR AT STRING DESCRIPTOR
5166 
5167 
5168          XTHL                              ;GET FUNCTION #
5169                                            ;SAVE THE STRING PTR
5170          PUSH     H                        ;PUT THE FUNCTION # ON
5171          XCHG                              ;[H,L]=TXTPTR
5172          CALL     GETBYT                   ;[E]=VALUE OF FORMULA
5173 
5174 
5175          XCHG                              ;TEXT POINTER INTO [D,E]
5176                                            ;[H,L]=INT VALUE OF SECOND ARGUMENT
5177          XTHL                              ;SAVE INT VALUE OF SECOND ARG
5178                                            ;[H,L]=FFUNCTION NUMBER
5179          JMP      FINGO>                   ;DISPATCH TO FUNCTION
5180 
5181 
5182 OKNORM:  CALL     PARCHK                   ;MAKE SURE ITS THERE.
5183 
5184 
5185                                            ;READ THE FORMULA INSIDE
5186                                            ;AND MAKE SURE ITS FOLLOWED BY ")"
5187          XTHL                              ;[H,L]=FUNCTION # AND SAVE TEXT POINTER
5188 IFE      LENGTH-2,<
5189 ; 
5190 ; CHECK IF SPECIAL COERCION MUST BE DONE FOR ONE OF THE TRANSCENDENTAL
5191 ; FUNCTIONS (RND, SQR, COS, SIN, TAN, ATN, LOG, AND EXP)
5192 ; 
5193          MOV      A,L                      ;[A]=FUNCTION NUMBER
5194          BOTCON==<SQRTK-ONEFUN>*2
5195          CPI      BOTCON                   ;LESS THAN SQUARE ROOT?
5196 
5197          JC       NOTFRF                   ;DON*T FORCE THE ARGUMENT
5198 
5199 
5200          TOPCON=<ATNTK-ONEFUN>*2+1
5201          CPI      TOPCON                   ;BIGGER THAN ARC-TANGENT?
5202 
5203          PUSH     H                        ;SAVE THE FUNCTION NUMBER
5204          CC       FRCSNG                   ;IF NOT, FORCE FAC TO SINGLE-PRECISION
5205 
5206 
5207          POP      H                        ;RESTORE THE FUNCTION NUMBER
5208 NOTFRF:  >        
5209          LXI      D,LABBCK                 ;RETURN ADDRESS
5210 
5211 
5212          PUSH     D                        ;MAKE THEM REALLY COME BACK
5213 FINGO:   LXI      B,FUNDSP                 ;FUNCTION DISPATCH TABLE
5214 
5215 
5216          DAD      B                        ;ADD ON THE OFFSET
5217 IFE      LENGTH,< 
5218          PUSHM    
5219          RET>                              ;GO TO THE ADDRESS POINTED TO BY [H,L]
5220 IFN      LENGTH,< 
5221          MOV      C,M                      ;FASTER THAN PUSHM
5222          INX      H        
5223          MOV      H,M      
5224          MOV      L,C      
5225          PCHL>                             ;GO PERFORM THE FUNCTION
5226          IF       LENGTH-2,<
5227 ; 
5228 ; GET THE VALTYP AND SET CONDITION CODES AS FOLLOWS:
5229 ; CONDITION CODE        TRUE SET        FALSE SET
5230 ; 
5231 ; SIGN                  INT=2           STR,SNG,OBL
5232 ; ZERO                  STR=3           INT,SNG,DBL
5233 ; ODD PARITY            SNG=4           INT,STR,DBL
5234 ; NO CARRY              DBL=10          INT,STR,SNG
5235 ; 
5236 GETYPE:  LDA      VALTYP                   ;GET THE VALTYP
5237 
5238 
5239          CPI      8                        ;SET CARRY CORRECTLY
5240 
5241          DCR      A                        ;SET THE OTHER CONDITION CODES CORRECTLY
5242          DCR      A                        ;WITHOUT AFFECTING CARRY
5243          DCR      A        
5244          RET>     
5245 
5246 IFN      LENGTH-2,<
5247 IFN      LENGTH,< 
5248 OR:      XWD      ^O1000,^O366             ;"ORI" , FLAG AS "OR"
5249                                            ;AND USE COMMON "AND" CODE
5250 AND:     XRA      A                        ;FLAG AS "AND"
5251 ANDCON:  
5252          PUSH     PSW      
5253 IFN      STRING,<CALL CHKNUM>  
5254          CALL     DEINT                    ;GET [D,E]=INT VALUE AND CHECK SIZE
5255          POP      PSW      
5256          XCHG                              ;[H,L]=INT VALUE
5257          POP      B                        ;GET HIGH ORDER OFF
5258          XTHL                              ;PUT INT VALUE ON
5259                                            ;GET LOW OF SECOND ARG OFF
5260          XCHG                              ;LOW OF SECOND ARG
5261          CALL     MOVFR    
5262          PUSH     PSW      
5263          CALL     DEINT                    ;GET [D,E]=INT VALUE
5264          POP      PSW      
5265                                            ;OF FIRST ARG AND CHECK SIZE
5266          POP      B                        ;[B,C]=INT VALUE OF SECOND ARG
5267          MOV      A,C                      ;[A]=LOW OF SECOND ARG
5268          LXI      H,GIVACF                 ;SETUP JUMP ADDRESS
5269          JNZ      ORFIN                    ;IT WAS "OR" SO FINISH UP
5270          ANA      E                        ;AND TWO LOW ORDERS
5271          MOV      C,A                      ;SAVE ANSWER IN [C]
5272          MOV      A,B                      ;[A]=HIGH ORDER SECOND ARG
5273          ANA      D                        ;[A]=HIGH ORDER OF ANSWER
5274          PCHL                              ;FLOAT [A,C] AS ANSWER
5275 ORFIN:   ORA      E                        ;OR TWO LOW ORDERS
5276          MOV      C,A                      ;SAVE ANSWER LOW ORDER IN [C]
5277          MOV      A,B                      ;[A]=HIGH ORDER SECOND ARG
5278          ORA      D                        ;OR TWO HIGH ORDERS
5279                                            ;[A]=HIGH ORDER OF ANSWER
5280          PCHL                              ;FLOAT [A,C] AS ANSWER
5281 FINREL:  LXI      H,PTDORL                 ;MAKE [H,L] POINT AT OPERATOR ADDRESS
5282 IFN      STRING,< 
5283          LDA      VALTYP                   ;STORE VALUE TYPE AS LOW
5284          RAR                               ;ORDER BIT OF [E]
5285          MOV      A,D                      ;GET RELATIONAL MEMORIES IN [A]
5286          RAL                               ;MOVE CARRY BIT IN
5287          MOV      E,A>                     ;KEEP THIS BYTE IN [E]
5288 IFE      STRING,<MOV E,D>     
5289          MVI      D,100                    ;PRECEDENCE OF ALL RELATIONAL
5290                                            ;OPERATORS IS 100
5291          MOV      A,B                      ;[A]=PRECEDENCE OF OLD OPERATOR
5292          CMP      D                        ;SEE WHETHER TO APPLY OLD OPERATOR
5293          RNC                               ;IF OLD OPERATOR HAS EQUAL OR GREATER
5294                                            ;PRECEDENCE THAN IT MUST BE APPLIED
5295          JMP      DOPREC                   ;SEE IF TIME TO APPLY
5296                                            ;AND IF NOT SAVE INFO ON THE STACK
5297 
5298 PTDORL:  ADR(DOREL)                        ;ADDRESS OF RELATIONAL
5299                                            ;OPERATOR APPLICATION
5300                                            ;ROUTINE
5301 ; 
5302 ; TIME TO PERFORM A RELATIONAL OPERATOR
5303 ; [C] CONTAINS THE BITS AS TO WHICH RELATIONAL
5304 ; OPERATOR IT WAS (IF STRINGS ON
5305 ; LOW ORDER BIT SAYS WHETHER IT WAS STRING OR NOT)
5306 ; 
5307 DOREL:   MOV      A,C                      ;GET MEMORIES INTO [A]
5308 IFN      STRING,< 
5309          ORA      A        
5310          RAR>                              ;CARRY=WHETHER WAS STRING OR NOT
5311          POPR                              ;POP OFF LEFT RESULT
5312          PUSH     PSW                      ;SAVE WHICH OPERATOR IT WAS
5313 IFE      STRING,< 
5314          CALL     FCOMP>                   ;DO A NUMERIC COMPARE
5315 IFN      STRING,< 
5316          CALL     CHKVAL                   ;SEE IF VALTYP MATCHES
5317                                            ;CARRY AND SET ZERO IN THE
5318                                            ;NUMERIC CASE
5319          LXI      H,DOCMP                  ;COME BACK TO COMPARE
5320          PUSH     H        
5321          JZ       FCOMP                    ;DO NUMERIC COMPARE
5322          XRA      A                        ;SET VALUE TYPE AS NUMERIC
5323          STA      VALTYP>>>
5324 IFN      STRING,< 
5325 ; 
5326 ; THE FOLLOWING ROUTINE COMPARES TWO STRINGS
5327 ; ONE WITH DESC IN [D,E] OTHER WITH DESC, IN (FACLO, FACLO+1)
5328 ; A=0 IF STRINGS EQUAL
5329 ; A=377 IF B,C,D,E POINTER FACLO
5330 ; A=1 IF B,C,D,E .LT. FACLO
5331 ; 
5332 IFN      LENGTH-2,<
5333 STRCMP:  PUSH     D                        ;SAVE DESC, POINTER TO FIRST STR.
5334          CALL     FREFAC                   ;FREE THE FACLO STR
5335          POP      D                        ;RESTORE 1ST DESC. POINTER
5336          PUSHM                             ;SAVE LENGTH
5337          PUSHM                             ;SAVE POINTER
5338          CALL     FRETMP                   ;FREES IST DESC. POINTER
5339          CALL     MOVRM                    ;[B,C] POINT AT FIRST CHAR
5340                                            ;[E] HAS THE LENGTH
5341          POP      H                        ;GET 2ND CHARACTER POINTER IN H
5342          XTHL                              ;GET 2ND CHARACTER COUNTER IN L
5343          MOV      D,L>                     ;SAVE IN D
5344 IFE      LENGTH-2,<
5345 STRCMP:  CALL     FRESTR                   ;FREE UP THE FAC STRING, AND GET THE
5346 
5347 
5348                                            ;POINTER TO THE FAC DESCRIPTOR IN [H,L]
5349          MOV      A,M                      ;SAVE THE LENGTH OF THE FAC STRING IN [A]
5350          INX      H        
5351          MOV      C,M                      ;SAVE THE POINTER AT THE FAC STRING
5352                                            ;DATA IN [B,C]
5353          INX      H        
5354          MOV      B,M      
5355          POP      D                        ;GET THE STACK STRING POINTER
5356          PUSH     B                        ;SAVE THE POINTER AT THE FAC STRING DATA
5357          PUSH     PSW                      ;SAVE THE FAC STRING LENGTH
5358          CALL     FRETMP                   ;FREE UP THE STACK STRING AND RETURN
5359 
5360 
5361                                            ;THE POINTER TO THE STACK STRING DESCRIPTOR
5362                                            ;IN [H,L]
5363          POP      D                        ;[D]=LENGTH OF FAC STRING
5364          MOV      E,M                      ;[E]=LENGTH OF STACK STRING
5365          INX      H        
5366          MOV      C,M                      ;[B,C]=POINTER AT STACK STRING
5367          INX      H        
5368          MOV      B,M>     
5369          POP      H                        ;GET BACK 2ND CHARACTER POINTER
5370 CSLOOP:  MOV      A,E                      ;BOTH STRINGS ENDED
5371          ORA      D                        ;TEST BY OR'ING THE LENGTHS TOGETHER
5372          RZ                                ;IF SO, RETURN WITH A ZERO
5373          MOV      A,D                      ;GET FACLO STRING LENGTH
5374          ORA      A                        ;IF IT ENDED, OTHER MUST NOT HAVE
5375          CMA                               ;MAKE -1
5376          RZ                                ;TEST
5377          XRA      A                        ;MUST NOT HAVE BEEN ZERO, TEST CASE
5378          CMP      E                        ;OF B,C,D,E STRING HAVING ENDED FIRST
5379          INR      A                        ;RETURN WITH A=1
5380          RNC                               ;TEST THE CONDITION
5381                                            ;HERE WHEN NEITHER STRING ENDED
5382          DCR      D                        ;DECREMENT BOTH CHARACTER COUNTS
5383          DCR      E        
5384          LOAX     B                        ;GET CHARACTER FROM B,C,D,E STRING
5385          CMP      M                        ;COMPARE WITH FACLO STRING
5386          INX      H                        ;BUMP POINTERS (INX DOESNT CLOBBER CC'S)
5387          INX      B        
5388          JZ       CSLOOP                   ;IF BOTH THE SAME, MUST BE MORE TO STRINGS
5389 
5390 
5391          CMC                               ;HERE WHEN STRINGS DIFFER
5392          JMP      SIGNS>                   ;SET [A] ACCORDING TO CARRY
5393 
5394 
5395 IFN      LENGTH,< 
5396 DOCMP:   INR      A                        ;SETUP BITS
5397          ADC      A                        ;4=LESS 2=EQUAL 1 GREATER
5398          POP      B                        ;WHAT DID HE WANT?
5399          ANA      B                        ;ANY BITS MATCH?
5400          ADI      255                      ;MAP 0 TO 0
5401 
5402          SBB      A                        ;AND ALL OTHERS TO 377
5403 IFE      LENGTH-2,<
5404          CALL     CONIA##                  ;CONVERT [A] TO AN INTEGER SIGNED
5405 
5406 
5407          JMP      RETAOP>                  ;RETURN FROM OPERATOR APPLICATION
5408 
5409 
5410 IFN      LENGTH-2,<
5411          JMP      FLOAT                    ;MAKE FAC= SIGNED
5412                                            ;COULD FALL INTO FLOAT BUT MESSY (SAVES
5413                                            ;TWO BYTES)
5414 
5415 NOTER:   MVI      D,90                     ;"NOT" HAS PRECEDENCE 90
5416          CALL     LPOPER                   ;GO PERFORM
5417 IFN      STRING,<CALL CHKNUM>              ;MAKE SURE ITS INT
5418          CALL     DEINT                    ;GET VALUE IN [D,E]
5419          MOV      A,E      
5420          CMA                               ;COMPLEMENT
5421          MOV      C,A                      ;[C] LOW ORDER OF ANSWER
5422          MOV      A,D      
5423          CMA                               ;COMPLEMENT HIGH ORDER 100
5424          CALL     GIVACF                   ;FLOAT [A,C] AS RESULT
5425          POP      B                        ;TAKE RETURN ADDRESS OF FRMEVL
5426          JMP      RETAOP>>                 ;OFF AND RETURN TO THE RIGHT
5427                                            ;PLACE SO THE TEXT POINTER
5428                                            ;WILL GET SET UP TO WHAT IT WAS
5429                                            ;WHEN LPOPER RETURNED.
5430 IFE      LENGTH-2,<
5431 NOTER:   MVI      D,90                     ;"NOT" HAS PRECEDENCE 90, SO
5432 
5433          CALL     LPOPER                   ;FORMULA EVALUATION IS ENTERED WITH A DUMMY
5434 
5435 
5436                                            ;ENTRY OF 90 ON THE STACK
5437          CALL     FRCINT                   ;COERCE THE ARGUMENT TO INTEGER
5438 
5439 
5440          MOV      A,L                      ;COMPLEMENT [H,L]
5441          CMA      
5442          MOV      L,A      
5443          MOV      A,H      
5444          CMA      
5445          MOV      H,A      
5446          SHLD     FACLO                    ;UPDATE THE FAC
5447 
5448 
5449          POP      B                        ;FRMEVL, AFTER SEEING THE PRECEDENCE
5450                                            ;OF 90 THINKS IT IS APPLYING AN OPERATOR
5451                                            ;SO IT HAS THE TEXT POINTER IN TEMP2 SO
5452 
5453          JMP      RETAOP                   ;RETURN TO REFETCH IT
5454 
5455 
5456 ; 
5457 ; DANDOR APPLIES THE "AND" AND "OR" OPERATORS
5458 ; AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
5459 ; WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN [B].
5460 ; THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
5461 ; THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
5462 ; THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
5463 ; 
5464 DANDOR:  PUSH     B                        ;SAVE THE PRECEDENCE "OR"=70
5465          CALL     FRCINT                   ;COERCE RIGHT HAND ARGUMENT TO INTEGER
5466 
5467 
5468          POP      PSW                      ;GET BACK THE PRECEDENCE TO DISTINGUISH
5469                                            ;"AND" AND "OR"
5470          POP      D                        ;POP OFF THE LEFT HAND ARGUMENT
5471          CPI      70                       ;SET ZERO FOR "OR"
5472 
5473          MOV      A,E                      ;SETUP LOW IN [A]
5474          JZ       ORFIN                    ;DO "OR" IF PRECEDENCE WAS 70
5475 
5476 
5477          ANA      
5478          MOV      L,A      
5479          MOV      A,H      
5480          ANA      D        
5481          MOV      H,A      
5482          JMP      MAKINT                   ;RETURN THE INTEGER [H,L]
5483 
5484 
5485                                            ;AS THE "AND"ED RESULT
5486 ORFIN:   ORA      
5487          MOV      L,A      
5488          MOV      A,H      
5489          ORA      D        
5490          MOV      H,A      
5491          JMP      MAKINT>                  ;RETURN THE INTEGER [H,L]
5492 
5493 
5494                                            ;AS THE "OR"ED RESULT
5495 PAGE     
5496 SUBTTL   DIMENSION & VARIABLE SEARCHING
5497 DIMCON:  DCX      H                        ;SEE IF COMMA ENDED THIS VARIABLE
5498          CHRGET   
5499          RZ                                ;IF TERMINATOR, GOOD BYE
5500          SYNCHK   44                       ;MUST BE COMMA
5501 
5502 ; 
5503 ; THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
5504 ; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
5505 ; DIMFLG AT THREE DIFFERENT POINTS:
5506 ; 
5507 ;       1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
5508 ;               A "DOUBLY DIMENSIONED" VARIABLE
5509 ;       2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
5510 ;               INDICATES THE INDICES SHOULD BE USED FOR
5511 ;               THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
5512 ;               OF TEN IS USED.
5513 ;       3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
5514 ;               OFF WILL INDEXING BE DONE
5515 ; 
5516 DIM:     LXI      B,DIMCON                 ;PLACE TO COME BACK TO
5517 
5518 
5519          PUSH     B        
5520          XWD      ^O1000,^O366             ;"ORI" NON ZERO THING
5521 ; 
5522 ; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
5523 ; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
5524 ; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME. .
5525 ; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
5526 ; VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
5527 ; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
5528 ; 
5529 PTRGET:  XRA      A                        ;MAKE [A]
5530          STA      DIMFLG                   ;FLAG IT AS SUCH
5531 
5532 
5533          MOV      B,M                      ;GET FIRST CHARACTER IN [B]
5534 PTRGT2:  CALL     ISLET                    ;CHECK FOR LETTER
5535 
5536 
5537          JC       SNERR                    ;MUST HAVE A LETTER
5538 
5539 
5540          XRA      
5541          MOV      C,A                      ;ASSUME NO SECOND CHARACTER
5542 IFN      LENGTH-2,<
5543 IFN      STRING,< 
5544          STA      VALTYP>>                 ;DEFAULT IS ZERO (NUMERIC)
5545          CHRGET                            ;GET THE FOLLOWING CHARACTER
5546 IFE      LENGTH,< 
5547          JNC      NOSEC>                   ;ONLY NUMBERS ALLOWED
5548 IFN      LENGTH,< 
5549          JC       ISSEC                    ;CARRY SET BY CHRGET IF CHARACTER IS
5550 
5551 
5552                                            ;NUMERIC
5553          CALL     ISLET                    ;SET CARRY IF NOT ALPHABETIC
5554 
5555 
5556          JC       NOSEC>                   ;ALLOW ALPHABETICS
5557 
5558 
5559 ISSEC:   MOV      C,A                      ;IT IS A NUMBER--SAVE IN C
5560 EATEM:   CHRGET                            ;LOOK AT NEXT CHARACTER
5561 IFN      LENGTH,< 
5562          JC       EATEM                    ;SKIP NUMERICS
5563 
5564 
5565          CALL     ISLET    
5566 
5567 
5568          JNC      EATEM>                   ;SKIP ALPHABETICS
5569 
5570 
5571 NOSEC:   
5572 IFE      LENGTH-2,<
5573          LXI      D,HAVTYP                 ;SAVE JUMPS BY USING RETURN ADDRESS
5574 
5575 
5576          PUSH     D        
5577          MVI      D,8                      ;ASSUME ITS DOUBLE PRECISION
5578 
5579          CPI      "#"                      ;CHECK THE CHARACTER
5580 
5581          RZ                                ;WHEN WE MATCH, SETUP VALTYP
5582          MVI      D,2                      ;CHECK FOR INTEGER
5583 
5584          CPI      "%"      
5585 
5586          RZ       
5587          INR      D                        ;CHECK FOR STRING
5588          CPI      "$"      
5589 
5590          RZ       
5591          INR      D                        ;SINGLE PRECISION IS THE DEFAULT
5592          DCX      H                        ;NO MARKING CHARACTER
5593          RET                               ;GET RID OF RETURN ADDRESS
5594 HAVTYP:  MOV      A,D                      ;SETUP VALTYP
5595          STA      VALTYP   
5596 
5597 
5598          CHRGET                            ;READ PAST TYPE MARKER
5599 IFN      LENGTH-2,<
5600 IFN      STRING,< 
5601          SUI      "$"                      ;IS IT A STRING?
5602          JNZ      NOTSTR                   ;IF NOT VALTYP ALREADY=0
5603          INR      A                        ;[A]=1
5604          STA      VALTYP                   ;FLAG THIS AS A STRING
5605          RRC                               ;MAKE [A]=128
5606          ADD      C                        ;MAKE [A]=SECOND CHARACTER
5607          MOV      C,A                      ;BACK INTO [C] WITH STRING BIT ON
5608          CHRGET                            ;GET CHARACTER AFTER "S"
5609 NOTSTR:  >>       
5610 IFN      LENGTH,< 
5611          LDA      SUBFLG                   ;GET FLAG WHETHER TO ALLOW ARRAYS
5612 
5613 
5614          ADD      M>                       ;ADD ONTO CHARACTER
5615          CPI      "("                      ;ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)
5616 
5617 
5618          JZ       ISARY                    ;IT IS!
5619 
5620 
5621 IFN      LENGTH,< 
5622          XRA      A                        ;ALLOW PARENS AGAIN
5623          STA      SUBFLG>                  ;SAVE IN FLAG LOCATION
5624 
5625 
5626          PUSH     H                        ;SAVE THE TEXT POINTER
5627 IFE      LENGTH-2,<
5628          MOV      A,D                      ;VALUE TYPE INTO [A]
5629          LHLD     VARTAB                   ;[H,L]=PLACE TO START THE SEARCH
5630 
5631 
5632 LOPEND:  PUSH     PSW                      ;SAVE THE VALUE TYPE
5633          XCHG                              ;[D,E]=POINTER INTO SIMPLE VARIABLES
5634          LHLD     ARYTAB                   ;[H,L]=END OF SIMPLE VARIABLES
5635 
5636 
5637          COMPAR                            ;SEE IF THE END HAS BEEN REACHED
5638          POP      H                        ;[H]=VALTYP
5639          JZ       NOTENS                   ;COULDN'T FIND IT, SO MAKE A NEW ENTRY
5640 
5641 
5642          LDAX     D                        ;GET THE VALTYP OF THIS SIMPLE VARIABLE
5643          MOV      L,A                      ;SAVE SO WE KNOW HOW MUCH TO SKIP
5644          CMP      H                        ;COMPARE WITH OUR VALTYP
5645          INX      0        
5646          JNZ      NOTIT1                   ;NOT RIGHT KIND -- SKIP IT
5647 
5648 
5649          LOAX     D                        ;[A]=FFIRST CHARACTER OF THIS VARIABLE
5650          CMP      C                        ;SEE IF OUR VARIABLE MATCHES
5651          JNZ      NOTIT1   
5652 
5653 
5654          INX      D        
5655          LDAX     D                        ;SEE IF SECOND CHACRACTER MATCHES
5656          CMP      B        
5657          JZ       FINPTR                   ;THAT WAS IT, ALL DONE
5658 
5659 
5660          XWD      ^O1000,^O76              ;"MVI A," AROUND THIS INX SINCE THE POINTER
5661                                            ;HIS ALREADY INCREMENTED
5662 NOTIT1:  INX      D        
5663          INX      D        
5664          MOV      A,H                      ;SKIP OVER THE
5665                                            ;CURRENT VARIABLE SINCE WE DIDN'T MATCH
5666                                            ;SAVE THE VALTYP IN [A]
5667          MVI      H,0                      ;[H,L]=NUMBER OF BYTES TO SKIP
5668 
5669          DAD      D                        ;ADD ON THE POINTER
5670          JMP      LOPEND                   ;AND SEARCH SOME MORE
5671 
5672 
5673 NOTENS:  PUSH     B                        ;SAVE THE LOOKS
5674          MOV      C,H                      ;[B,C]=LENGTH OF THIS VARIABLE
5675          MOV      B,A                      ;[B]=0
5676          PUSH     B                        ;SAVE THE VALTYP ON THE STACK
5677          INX      B                        ;MAKE THE LENGTH INCLUDE
5678                                            ;THE LOOKS TOO
5679          INX      B        
5680          INX      B>       
5681 IFN      LENGTH-2,<
5682          LHLD     ARYTAB                   ;PLACE TO STOP SEARCHING
5683          XCHG     
5684          LHLD     VARTAB                   ;GET THE PLACE TO START
5685 LOPFND:  COMPAR                            ;SEE IF WE ARE THERE
5686          JZ       NOTENS                   ;COULDN'T FIND THIS VARIABLE
5687                                            ;SO MAKE ROOM FOR IT
5688          MOV      A,C      
5689          SUB      M                        ;IS THIS VARIABLE THE ONE?
5690          INX      H        
5691          JNZ      NOTIT                    ;NOPE
5692          MOV      A,B      
5693          SUB      M                        ;TRY SECOND CHARACTER MATCHING
5694 NOTIT:   INX      H        
5695          JZ       FINPTR                   ;THAT WAS ITI
5696          INX      H                        ;SKIP OVER THAT ONE--NOT IT
5697          INX      H        
5698          INX      H        
5699          INX      H        
5700          JMP      LOPFND                   ;TRY AGAIN
5701 NOTENS:  PUSH     B                        ;REMEMBER WHAT THIS
5702                                            ;AVARIABLE LOOKS LIKE
5703          LXI      B,6+$CODE>               ;THE AMOUNT TO SHOVE
5704                                            ;EVERYTHING UP BY
5705          LHLD     STREND                   ;THE CURRENT END OF STORAGE
5706 
5707 
5708          PUSH     H                        ;SAVE THIS #
5709          DAD      B                        ;ADD ON THE AMOUNT OF SPACE
5710                                            ;EXTRA NOW BEING USED
5711          POP      B                        ;POP OFF HIGH ADDRESS TO MOVE
5712          PUSH     H                        ;SAVE NEW CANDIDATE FOR STREND
5713          CALL     BLTU                     ;BLOCK TRANSFER AND MAKE SURE
5714 
5715 
5716                                            ;WE ARE NOT OVERFLOWING THE
5717                                            ;STACK SPACE
5718          POP      H                        ;[H,L]=NEW STREND
5719          SHLD     STREND                   ;STORE SINCE WAS OK
5720 
5721 
5722                                            ;THERE WAS ROOM, AND BLOCK TRANSFER
5723                                            ;WAS DONE, SO UPDATE POINTERS
5724          MOV      H,B                      ;GET BACK [H,L] POINTING AT THE END
5725          MOV      L,C                      ;OF THE NEW VARIABLE
5726          SHLD     ARYTAB                   ;UPDATE THE ARRAY TABLE POINTER
5727 
5728 
5729 ZEROER:  DCX      H                        ;[H,L] IS RETURNED POINTING TO THE
5730          MVI      M,0                      ;END OF THE VARIABLE SO WE
5731 
5732          COMPAR                            ;ZERO BACKWARDS TO ID, WHICH
5733          JNZ      ZEROER                   ;POINTS TO THE START OF THE VARIABLE
5734 
5735 
5736 IFE      LENGTH-2,<
5737          POP      D                        ;[E]=VALTYP
5738          MOV      M,E                      ;STORE AS PART OF THE LOOKS
5739          INX      H>       
5740          POP      D        
5741          MOV      M,E                      ;PUT DESCRIPTION
5742          INX      H        
5743          MOV      M,D                      ;OF THIS VARIABLE
5744                                            ;INTO MEMORY
5745 IFE      LENGTH-2,<
5746          XCHG                              ;POINTER AT VARIABLE INTO [D,E]
5747 FINPTR:  INX      D>                       ;POINT AT THE VALUE
5748 IFN      LENGTH-2,<
5749          INX      H        
5750 FINPTR:  XCHG>                             ;VARIABLE POINTER INTO [D,E]
5751          POP      H                        ;RESTORE THE TEXT POINTER
5752          RET      
5753 
5754 IFE      MULDIM,< 
5755 ISARY:   PUSH     B                        ;REMEMBER WHAT VARIABLE LOOKS
5756                                            ;LIKE
5757 IFN      STRING,< 
5758          PUSH     H                        ;SAVE THE TXTPTR
5759          LHLD     DIMFLG                   ;[L]=DIMFLG [H]=VALTYP
5760          XTHL>                             ;PUT VALTYP AND DIMFLG ON THE STACK
5761                                            ;AND RESTORE THE TEXT POINTER
5762 IFE      STRING,< 
5763          LDA      DIMFLG                   ;SINCE THIS CALL IS RECURSIVE
5764          PUSH     PSW>                     ;DIMFLG MUST BE SAVED ON THE STACK
5765          CALL     INTIDX                   ;EVALUATE THE INDEX INTO [D,E]
5766          SYNCHK   ")"                      ;MAKE SURE HE CLOSED IT
5767 IFN      STRING,< 
5768          XTHL                              ;[L]=DIMFLG [H]=VALTYP
5769                                            ;TEXT POINTER ONTO THE STACK
5770          SHLD     DIMFLG                   ;SAVE BOTH VALUES BACK
5771          POP      H>                       ;RESTORE THE TEXT POINTER
5772 IFE      STRING,< 
5773          POP      PSW                      ;GET DIMFLG OFF THE STACK
5774          STA      DIMFLG>                  ;RESTORE IT
5775          XTHL                              ;[H,L] GET VARIABLE DESCRIPTOR
5776                                            ;TEXT POINTER IS PUT ONTO
5777                                            ;THE STACK
5778          XCHG                              ;[D,E]=DESCRIPTOR
5779                                            ;[H,L]=INDEX
5780          DAD      H                        ;MULTIPLY BY 4 TO GET
5781          DAD      H                        ;BYTE OFFSET
5782          PUSH     H                        ;SAVE THE INDEX
5783          LALD     ARYTAB                   ;PLACE TO START SEARCH
5784          XWD      ^O1000,1                 ;"LXI B," OVER THE NEXT 2
5785 LOPFD2:  POP      B                        ;OF LAST VARIABLE
5786          DAD      B                        ;SKIP OVER LAST VARIABLE BY ADDING ITS
5787                                            ;LENGTH ONTO [H,L]
5788          XCHG                              ;[D,E] GET CURRENT SEARCH POINT
5789          PUSH     H                        ;SAVE THE VARIABLE LOOK
5790          LHLD     STREND                   ;GET PLACE TO STOP
5791          COMPAR                            ;SEE IF WE ARE THERE
5792          XCHG                              ;[H,L] GETS SEARCH POINT
5793          POP      D                        ;POP OFF VARIABLE LOOKS
5794          JZ       NOTFDD                   ;COULDN'T FIND IT
5795          PUSHM                             ;PUT ON LOOKS OF VARIABLE
5796                                            ;WE ARE EXAMINING
5797          XTHL                              ;PUT [H,L] ON THE STACK AND
5798                                            ;LOOKS OF VARIABLE WE ARE
5799                                            ;EXAMINING INTO [H,L]
5800          COMPAR                            ;IS THIS THE VARIABLE
5801          POP      H                        ;POP OFF SEARCH POINTER
5802          PUSHM                             ;PUSH LENGTH OF VARIABLE
5803                                            ;BEING EXAMINED ONTO THE STACK
5804          JNZ      LOPFD2                   ;IF NO MATCH, GO LOOK SOMEMORE
5805          LDA      DIMFLG                   ;IS THIS VARIABLE TRYING TO BE
5806                                            ;DIMENSIONED AND ALREADY
5807          ORA      A                        ;EXISTS?
5808          MVI      E,ERRDD                  ;THATS ERROR ERRDD
5809          JNZ      ERROR    
5810 MAKDFN:  POP      D                        ;POP OFF LENGTH OF THIS VARIABLE
5811          DCX      D                        ;DECREMENT LENGTH SO WE CAN
5812                                            ;JUST LOOK AT 'CARRY' AFTER
5813                                            ;CALLING COMPAR
5814          XTHL                              ;TRADE POINTER AT VARIABLE WITH
5815                                            ;INDEX INTO THE VARIABLE
5816          COMPAR                            ;SEE IF INDEX IS TOO BIG
5817          MVI      E,ERRBS                  ;THATS ERROR ERRBS
5818          JNC      ERROR                    ;SINCE LENGTH REALLY HAS AN
5819                                            ;EXTRA ONE ADDED TO IT
5820                                            ;IF INDEX-LENGTH DOESN'T CARRY
5821                                            ;THE IS IN TROUBLE
5822          POP      D                        ;POP OFF POINTER AT VARIABLE
5823          DAD      D                        ;ADD IT TO THE INDEX
5824          POP      D                        ;POP OFF TEXT POINTER
5825          XCHG                              ;TEXT POINTER INTO [H,L]
5826          RET                               ;VARIABLE POINTER INTO [D,E]
5827 
5828 NOTFDD:  MOV      M,E                      ;PUT LOOKS DOWN
5829          INX      H        
5830          MOV      M,D      
5831          INX      H        
5832          LXI      D,$CODE+44               ;DEFAULT SIZE IS 10
5833          LDA      DIMFLG                   ;ARE WE DIMENSIONING
5834          ORA      A        
5835          JZ       NOTDIM   
5836          POP      D                        ;POP OFF INDEX
5837          PUSH     D                        ;PUT INDEX BACK ON
5838          INX      D        
5839          INX      D        
5840          INX      D        
5841          INX      D        
5842 NOTDIM:  PUSH     D        
5843          MOV      M,E                      ;PUT LENGTH DOWN
5844          INX      H        
5845          MOV      M,D      
5846          INX      H        
5847          PUSH     H        
5848          DAD      D        
5849          CALL     REASON                   ;MAKE SURE WE'RE NOT RUNNING
5850                                            ;INTO THE STACK
5851          SHLD     STREND                   ;SETUP NEW STORAGE END
5852          POP      D        
5853 ZERIT2:  DCX      H        
5854          MVI      M,0      
5855          COMPAR   
5856          JNZ      ZERIT2   
5857          JMP      MAKDFN>                  ;FINISH UP
5858 
5859 PAGE     
5860 SUBTTL   MULTIPLE DIMENSION CODE
5861 
5862 IFN      MULDIM,< 
5863 ; 
5864 ; FORMAT OF ARRAYS IN CORE
5865 ; 
5866 ; DESCRIPTOR
5867 ;       LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
5868 ;       HIGH BYTE = FIRST CHARACTER
5869 ; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
5870 ; NUMBER OF DIMENSIONS 1 BYTE
5871 ; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
5872 ; (2 BYTES EACH) OF THE MAX INDICE+1
5873 ; THE VALUES
5874 ; 
5875 ISARY:   PUSH     H                        ;SAVE DIMFLG AND VALTYP FOR RECURSION
5876          LHLD     DIMFLG   
5877 
5878 
5879          XTHL                              ;TEXT POINTER BACK INTO [H,L]
5880          MVI      D,0                      ;SET # DIMENSIONS =0
5881 
5882 INDLOP:  PUSH     D                        ;SAVE NUMBER OF DIMENSIONS
5883          PUSH     B                        ;SAVE LOOKS
5884          CALL     INTIDX                   ;EVALUATE INDICE INTO [D,E]
5885 
5886 
5887          POP      B                        ;POP OFF THE LOOKS
5888          POP      PSW                      ;[A]=NUMBER OF DIMENSIONS SO FAR
5889          XCHG                              ;[D,E]=TEXT POINTER
5890                                            ;[H,L]=INDICE
5891          XTHL                              ;PUT THE INDICE ON THE STACK
5892                                            ;[H,L]=VALTYP & DIMFLG
5893          PUSH     H                        ;RESAVE VALTYP AND DIMFLG
5894          XCHG                              ;[H,L]=TEXT POINTER
5895          INR      A                        ;INCREMENT # OF DIMENSIONS
5896          MOV      D,A                      ;[D]=NUMBER OF DIMENSIONS
5897          MOV      A,M                      ;GET TERMINATING CHARACTER
5898          CPI      44                       ;A COMMA SO MORE INDICES FOLLOW?
5899 
5900          JZ       INDLOP                   ;IF SO, READ MORE
5901 
5902 
5903          SYNCHK   ")"                      ;MAKE SURE IT ENDED PROPERLY
5904 
5905          SHLD     TEMP2                    ;SAVE THE TEXT POINTER
5906 
5907 
5908          POP      H                        ;[H,L]=VALTYP & DIMFLG
5909          SHLD     DIMFLG                   ;SAVE VALTYP AND DIMFLG
5910 
5911 
5912          PUSH     D                        ;SAVE NUMBER OF DIMENSIONS
5913 ; 
5914 ; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
5915 ; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
5916 ; 
5917          LHLD     ARYTAB                   ;[H,L]=PLACE TO START THE SEARCH
5918 
5919 
5920          XWD      ^O1000,^O76              ;"MVI A," AROUND THE NEXT BYTE
5921 LOPFDA:  DAD      D                        ;SKIP OVER THIS ARRAY SINCE IT'S
5922                                            ;NOT THE ONE
5923          XCHG                              ;[D,E]=CURRENT SEARCH POINT
5924          LHLD     STREND                   ;GET THE PLACE TO STOP INTO [H,L]
5925 
5926 
5927          XCHG     CH                       ;[H,L]=SEARCH POINT
5928          COMPAR                            ;STOPPING TIME?
5929 IFE      LENGTH-2,<
5930          LDA      VALTYP>  
5931 
5932 
5933          JZ       NOTFDD                   ;YES, COULDN'T FIND THIS ARRAY
5934 
5935 
5936 IFE      LENGTH-2,<
5937          CMP      M                        ;SEE IF THE VALTYPS ARE THE SAME
5938          INX      H        
5939          JNZ      NMARY2>  
5940 
5941 
5942          MOV      A,M                      ;GET FIRST CHARACTER
5943          CMP      C                        ;SEE IF IT MATCHES
5944          INX      H        
5945          JNZ      NMARY1                   ;NOT THIS ONE
5946 
5947 
5948          MOV      A,M                      ;GET SECOND CHARACTER
5949          CMP      B                        ;ANOTHER MATCH?
5950 IFE      LENGTH-2,<
5951          XWD      ^O1000,^O76              ;SKIP THIS INCREMENT WITH "MVI A,"
5952 NMARY2:  INX      H>       
5953 NMARY1:  INX      H                        ;POINT TO SIZE ENTRY
5954          MOV      E,M                      ;[D,E]=LENGTH
5955          INX      H                        ;OF THE ARRAY BEING LOOKED AT
5956          MOV      D,M      
5957          INX      H        
5958          JNZ      LOPFDA                   ;IF NO MATCH, SKIP THIS ONE
5959 
5960 
5961                                            ;AND TRY AGAIN
5962          LDA      DIMFLG                   ;SEE IF CALLED BY "DIM"
5963 
5964 
5965          ORA      A                        ;ZERO MEANS NO
5966          MVI      E,ERRDD                  ;"DOUBLY DIMENSIONED" ERROR
5967 
5968          JNZ      ERROR    
5969 
5970 
5971 ; 
5972 ; TEMP2=THE TEXT POINTER
5973 ; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
5974 ; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
5975 ; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
5976 ; 
5977          POP      PSW                      ;[A]=NUMBER OF DIMENSIONS
5978          CMP      M                        ;MAKE SURE THE NUMBER GIVEN NOW AND
5979                                            ;AND WHEN THE ARRAY WAS SET UP ARE THE
5980                                            ;SAME
5981          JZ       GETDEF                   ;JUMP OFF AND READ
5982 
5983 
5984                                            ;THE INDICES ...
5985 BSERR:   MVI      E,ERRBS                  ;"SUBSCRIPT OUT OF RANGE"
5986 
5987          JMP      ERROR    
5988 
5989 
5990 ; 
5991 ; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
5992 ; 
5993 ; BUILDING AN ENTRY:
5994 ; 
5995 ;       PUT DOWN THE DESCRIPTOR
5996 ;       SETUP NUMER OF DIMENSIONS
5997 ;       MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
5998 ;       REMEMBER VARPTR
5999 ;       TALLY=4 (VALTYP FOR THE EXTENDED)
6000 ;       SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
6001 ; LOOP: GET AN INDICE
6002 ;       PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
6003 ;       TALLY=TALLY * NUMBER+1
6004 ;       DECREMENT NUMBER-DIMS
6005 ;       JNZ LOOP
6006 ;       CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
6007 ;       UPDATE STREND
6008 ;       ZERO BACKWARDS
6009 ;       MAKE TALLY INCLUDE MAXDIMS
6010 ;       PUT DOWN TALLY
6011 ;       IF CALLED BY DIMENSION, RETURN
6012 ;       OTHERWISE INDEX INTO THE VARIABLE AS IF IT
6013 ;       WERE FOUND ON THE INITIAL SEARCH
6014 ; 
6015 NOTFDD:  
6016 IFE      LENGTH-2,<
6017          MOV      M,A                      ;PUT DOWN THE VARIABLE TYPE
6018          INX      H        
6019          MOV      E,A      
6020          MVI      E,A                      ;[D,E]=SIZE OF ONE VALUE (VALTYP)
6021 
6022 IFN      LENGTH-2,<
6023          LXI      D,$CODE+4>               ;INITIALIZE TALLY TO FOUR
6024          MOV      M,C                      ;PUT DOWN THE DESCRIPTOR
6025          INX      H        
6026          MOV      M,B      
6027          INX      H        
6028          POP      PSW                      ;[A]=NUMBER OF DIMENSIONS
6029          STA      TEMP6                    ;SETUP GETSTK CALL
6030 
6031 
6032          CALL     GETSTK                   ;GET SPACE FOR DIMENSION ENTRIES
6033 
6034 
6035 TEMP6:   PCHL                              ;PLACE TO STORE NUMBER OF DIMENSIONS
6036                                            ;FOR GETSTK AND LATER RECALL
6037                                            ;!!IMPURE!! PCHL TO CONFUSE DISASSEMBLY
6038          SHLD     TEMP3                    ;SAVE THE LOCATION TO PUT THE SIZE
6039 
6040 
6041                                            ;IN
6042          INX      H                        ;SKIP OVER THE SIZE LOCATIONS
6043          INX      H        
6044          MOV      B,C                      ;[B]=NUMBER OF DIMENSIONS
6045                                            ;THIS DEPENDS ON THE FACT THAT GETSTK
6046                                            ;RETURNS ITS ARGUMENT IN [C]
6047          MOV      M,B                      ;STORE THE NUMBER OF DIMENSIONS
6048          INX      H        
6049 LOPPTA:  LDA      DIMFLG                   ;CALLED BY DIMENSION?
6050 
6051 
6052          ORA      A        
6053          MOV      A,B                      ;[A]=NUMBER OF DIMENSIONS
6054          LXI      B,$CODE+11               ;ASSUME ITS NOT "DIM"
6055 
6056 
6057          JZ       NOTDIM                   ;DEFAULT DIMENSIONS TO TEN
6058 
6059 
6060          POP      B                        ;POP OFF AN INDICE INTO [B,C]
6061          INX      B                        ;ADD ONE TO IT FOR THE ZERO ENTRY
6062 NOTDIM:  MOV      M,C                      ;PUT THE MAXIMUM DOWN
6063          INX      H        
6064          MOV      M,B      
6065          INX      H        
6066          PUSH     PSW                      ;SAVE THE NUMBER OF DIMENSIONS
6067          PUSH     H                        ;SAVE THE POINTER INTO THE NEW ENTRY
6068          CALL     UMULT                    ;MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
6069 
6070 
6071          XCHG                              ;[D,E]=NEW CURTOL
6072          POP      H                        ;GET THE POINTER INTO THE ENTRY BACK
6073          POP      B                        ;GET THE NUMBER OF DIMENSIONS BACK
6074          DCR      B                        ;DECREMENT THE NUMBER OF DIMENSIONS LEFT
6075          JNZ      LOPPTA                   ;HANDLE THE OTHER INDICES
6076 
6077 
6078          MOV      B,D                      ;[B,C]=SIZE
6079          MOV      C,E      
6080          XCHG                              ;[D,E]=START OF VALUES
6081          DAD      D                        ;[H,L]=END OF VALUES
6082          JC       BSERR                    ;OUT OF MEMORY POINTER BEING GENERATED?
6083 
6084 
6085          CALL     REASON                   ;SEE IF THERE IS ROOM FOR THE VALUES
6086 
6087 
6088          SHLD     STREND                   ;UPDATE THE END OF STORAGE
6089 
6090 
6091 ZERITA:  DCX      H                        ;ZERO THE NEW ARRAY
6092          MVI      M,0      
6093 
6094          COMPAR                            ;BACK AT THE BEGINNING?
6095          JNZ      ZERITA                   ;NO, ZERO MORE
6096 
6097 
6098          INX      B                        ;ADD ONE TO THE SIZE TO INCLUDE
6099                                            ;THE BYTE FOR THE NUMBER OF DIMENSIONS
6100          MOV      H,A                      ;[H]=ZERO
6101          LDA      DIMFLG   
6102 
6103 
6104          ORA      A                        ;ARE WE DIMENSIONING ?
6105          LDA      TEMP6                    ;GET THE NUMBER OF DIMENSIONS
6106 
6107 
6108          MOV      L,A                      ;[L]=NUMBER OF DIMENSIONS
6109          DAD      H                        ;[H,L]=NUMBER OF DIMENSIONS TIMES TWO
6110          DAD      B                        ;ADD ON THE SIZE
6111                                            ;TO GET THE TOTAL NUMBER OF BYTES USED
6112          XCHG                              ;[D,E]=TOTAL SIZE
6113          LHLD     TEMP3                    ;PLACE TO STORE SIZE
6114 
6115 
6116          MOV      M,E                      ;PUT DOWN THE SIZE
6117          INX      H        
6118          MOV      M,D      
6119          INX      H        
6120          JNZ      FINNOW   
6121 
6122 
6123 ; 
6124 ; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
6125 ; STRATEGY:
6126 ;       NUMDIM=NUMBER OF DIMENSIONS
6127 ;       CURTOL=0
6128 ; INLPNM:GET A NEW INDICE
6129 ;       POP NEW MAX INTO CURMAX
6130 ;       MAKE SURE INDICE IS NOT TOO BIG
6131 ;       MUTLIPLY CURTOL BY CURMAX
6132 ;       ADD INDICE TO CURTOL
6133 ;       NUMDIM=NUMDIM-1
6134 ;       JNZ INLPNM
6135 ;       USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
6136 ; 
6137 GETDEF:  INX      H                        ;POINT PAST THE NUMBER OF DIMENSIONS
6138          LXI      B,$CODE                  ;CURTOL=ZERO
6139 
6140 
6141          XWD      ^O1000,^O26              ;"MVI D," AROUND THE NEXT BYTE
6142 INLPNM:  POP      H                        ;[H,L]=POINTER INTO VARIABLE ENTRY
6143          MOV      E,M                      ;[D,E]=MAXIMUM FOR THE CURRENT INDICE
6144          INX      H        
6145          MOV      D,M      
6146          INX      H        
6147          XTHL                              ;[H,L]=CURRENT INDICE
6148                                            ;POINTER INTO THE VARIABLE GOES ON THE STACK
6149          PUSH     PSW                      ;SAVE THE NUMBER OF DIMENSIONS
6150          COMPAR                            ;SEE IF THE CURRENT INDICE IS TOO BIG
6151          JNC      BSERR                    ;IF SO "BAD SUBSCRIPT" ERROR
6152 
6153 
6154          PUSH     H                        ;SAVE THE CURRENT INDICE
6155          CALL     UMULT                    ;CURTOL=CURTOL*CURRENT MAXIMUM
6156 
6157 
6158          POP      D                        ;INDICE INTO [D,E]
6159          DAD      D                        ;ADD THE INDICETO CURTOL
6160          POP      PSW                      ;GET THE NUMBER OF DIMENSIONS IN [A]
6161          DCR      A                        ;SEE IF ALL THE INDICES HAVE BEEN PROCESSED
6162          MOV      B,H                      ;[B,C]=CURTOL IN CASE WE LOOP BACK
6163          MOV      C,L      
6164          JNZ      INLPNM                   ;PROCESS THE REST OF THE INDICES
6165 
6166 
6167 IFE      LENGTH-2,<
6168          LDA      VALTYP                   ;SEE HOW BIG THE VALUES ARE
6169 
6170 
6171                                            ;AND MULTIPLY BY THAT SIZE
6172          MOV      B,H                      ;SAVE THE ORIGINAL VALUE FOR MULTIPLYING
6173          MOV      C,L                      ;BY THREE
6174          DAD      H                        ;MULTIPLY BY TWO AT LEAST
6175          SUI      4                        ;FOR INTEGERS AND STRINGS
6176 
6177                                            ;NO MORE MULTIPLYING BY TWO
6178          JC       SMLVAL   
6179 
6180 
6181          DAD      H                        ;NOW MULTIPLIED BY FOUR
6182          JZ       DONMUL                   ;IF SINGLE ALL DONE
6183 
6184 
6185          DAD      H                        ;BY EIGHT FOR DOUBLES
6186 SMLVAL:  JPO      DONMUL                   ;FOR STRINGS
6187 
6188 
6189          DAD      B                        ;ADD IN THE ORIGINAL
6190          DONMUL:> 
6191 IFN      LENGTH-2,<
6192          DAD      H                        ;MULTIPLY CURTOL BY FOUR
6193          DAD      H>       
6194          POP      B                        ;POP OFF THE ADDRESS OF WHERE THE VALUES
6195                                            ;BEGIN
6196          DAD      B                        ;ADD IT ONTO CURTOL TO GET THE
6197                                            ;PLACE THE VALUE IS STORED
6198          XCHG                              ;RETURN THE POINTER IN [D,E]
6199 FINNOW:  LHLD     TEMP2                    ;REGET THE TEXT POINTER
6200 
6201 
6202          DCX      H                        ;REREAD THE TERMINATING CHARACTER
6203          CHRGET   
6204          RET>     
6205 
6206 PAGE     
6207 SUBTTL   FRE FUNCTION AND INTEGER TO FLOATING ROUTINES
6208 IFN      LENGTH,< 
6209 FRE:     LHLD     STREND                   ;GET END OF VARIABLE AND TEXT SPACE
6210 
6211 
6212          XCHG                              ;PUT IT IN [D,E] FOR SUBTRACTION
6213          LXI      H,$CODE                  ;ZERO [H,L]
6214 
6215 
6216          DAD      SP                       ;PUT THE STACK POINTER IN [H,L]
6217 IFN      STRING,< 
6218 IFE      LENGTH-2,<
6219          CALL     GETYPE   
6220 
6221 
6222          JNZ      GIVDBL>  
6223 
6224 
6225 IFN      LENGTH-2,<
6226          LDA      VALTYP                   ;WAS THE ARGUMENT A STRING?
6227          ORA      A        
6228          JZ       GIVDBL>                  ;NO, GIVE FREE VARIABLE SPACE
6229          CALL     FREFAC                   ;FREE UP ARGUMENT AND SETUP
6230 
6231 
6232                                            ;TO GIVE FREE STRING SPACE
6233          CALL     GARBA2                   ;DO GARBAGE COLLECTION
6234 
6235 
6236          LHLD     STKTOP                   ;BOTTOM OF FREE AREA
6237 
6238 
6239          XCHG     
6240          LHLD     FRETOP>>                 ;TOP OF FREE AREA
6241 
6242 
6243 ; 
6244 ; THIS ROUTINE SUBTRACTS [D,E] FROM [H,L]
6245 ; AND FLOATS THE RESULT LEAVING IT IN FAC.
6246 ; 
6247 IFE      LENGTH-1,<
6248 GIVDBL:  MOV      A,L                      ;DO THE SUBTRACTION
6249          SUB      E        
6250          MOV      C,A      
6251          MOV      A,H      
6252          SBB      D        
6253 GIVACF:  MOV      B,C      
6254 IFN      LENGTH-2,<
6255 GIVABF:  MOV      D,B      
6256          MVI      E,0                      ;GET ZERO IN LOW
6257 IFN      STRING,< 
6258          LXI      H,VALTYP                 ;FLAG VALUE TYPE AS NUMERIC
6259          MOV      M,E>     
6260          MVI      B,144                    ;SETUP TO FLOAT [B,C]
6261          JMP      FLOATR>  
6262 IFE      LENGTH-2,<
6263 GIVDBL:  MOV      A,L                      ;[H,L]=[H,L]-[D,E]
6264          SUB      E        
6265          MOV      L,A      
6266          MOV      A,H      
6267          SBB      D        
6268          XWD      ^O1000,^O21              ;SKIP THE NEXT TWO BYTES WITH "LXI D,"
6269 SNGFLT:  MOV      L,A                      ;MAKE [A] AN UNSIGNED INTEGER
6270          XRA      A        
6271 GIVINT:  MOV      H,A      
6272          JMP      MAKINT>  
6273 
6274 
6275 IFN      LENGTH,< 
6276 IFN      LPTSW,<  
6277 LPOS:    LDA      LPTPOS   
6278          JMP      SNGFLT>  
6279 POS:     LDA      TTYPOS                   ;GET TELETYPE POSITION
6280 
6281 
6282 IFN      LENGTH-2,<
6283 SNGFLT:  MOV      B,A                      ;RETURN FLOATING 1 BYTE
6284          XRA      A                        ;UNSIGNED FROM A
6285          JMP      GIVABF>>                 ;GIVING 0-255
6286 
6287 PAGE     
6288 SUBTTL   SIMPLE-USER-DEFINED-FUNCTION CODE
6289 IFN      FUNCTS,< 
6290 ; 
6291 ; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
6292 ; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
6293 ; DEF A(X)=X^2+X-2
6294 ; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
6295 
6296 ; IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
6297 ; WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
6298 ; HAS THE 200 BIT SET.
6299 ; THE VALUE WILL BE:
6300 ; 
6301 ;       A TXTPTR TO THE FORMULA
6302 ;       A PTR TO THE ARGUMENT VARIABLE
6303 ; 
6304 ; FUNCTION NAMES CAN BE LIKE "FNA4"
6305 ; 
6306 
6307 DEF:     CALL     GETFNM                   ;GET A POINTER TO THE
6308 
6309 
6310                                            ;FUNCTION VARAIBLE
6311          LXI      B,DATA                   ;EVENTUALLY RETURN TO "DATA"
6312 
6313 
6314          PUSH     B                        ;AND SKIP THE FORMULA
6315          PUSH     D                        ;SAVE A POINTER TO IT
6316          CALL     ERRDIR                   ;DEF IS "ILLEGAL DIRECT"
6317 
6318 
6319          SYNCHK   "("                      ;MUST HAVE "("
6320 
6321                                            ;SINCE WE STORE A TEXT POINTER
6322          CALL     PTRGET                   ;GET POINTER TO ARGUMENT
6323 
6324 
6325 IFN      LENGTH-2,<
6326 IFN      STRING,<CALL CHKNUM>>             ;STRINGS ILLEGAL
6327          SYNCHK   ")"                      ;MUST CLOSE IT WITH ")"
6328 
6329          SYNCHK   EQULTK                   ;MUST HAVE EQUAL
6330 
6331          MOV      B,H      
6332          MOV      C,L      
6333          XTHL                              ;PUT THE TXTPTR ON THE STACK
6334                                            ;[H,L]=PTR TO FUNCTION VARIABLE
6335                                            ;[B,C]=TXTPTR
6336          JMP      DEFFIN                   ;PUT DOWN THE TEXT-POINTER
6337 
6338 
6339                                            ;AND ARGUMENT POINTER IN
6340                                            ;MEMORY, RESTORE THE TXTPTR
6341                                            ;AND GO TO "DATA" SKIPPING THE
6342                                            ;REST OF THE FORMULA
6343 
6344 FNDOER:  CALL     GETFNM                   ;GET A POINTER TO
6345 
6346 
6347                                            ;THE FUNCTON DEFINITION IN [D,E]
6348          PUSH     D                        ;SAVE THE POINTER
6349          CALL     PARCHK                   ;EVALUATE THE VALUE TO BE PASSED
6350 
6351 
6352 IFN      LENGTH-21
6353 IFN      STRING,<CALL CHKNUM>>             ;ARG CANNOT BE STRING
6354          XTHL                              ;[H,L]=POINTER TO FUNCTION DEF
6355                                            ;TEXT POINTER GOES ON THE STACK
6356          PUSHM                             ;PUSH THE POINTER AT THE FORMULA
6357                                            ;ONTO THE STACK
6358          POP      D                        ;[D,E]=PTR TO FORMULA
6359          PUSHM                             ;PUT A POINTER TO THE
6360                                            ;ARGUMENT ON THE STACK
6361          POP      H                        ;[H,L]=POINTER TO ARG
6362          PUSHEM                            ;SAVE ARGS OLD VALUE ON THE STACK
6363 
6364          DCX      H        
6365          DCX      H        
6366          DCX      H                        ;POINT TO FRONT OF ARG AGAIN
6367          DCX      H        
6368          PUSH     H                        ;SAVE IT
6369          COMPAR                            ;SHOULDN'T BE EQUAL UNLESS
6370                                            ;FUNCTION WAS NEVER DEFINED
6371          PUSH     D                        ;SAVE FORMULA TEXT POINTER
6372          MVI      E,ERRUF                  ;NOW [D,E] FREE SO CHECK IF (ZERO) SET
6373 
6374          JZ       ERROR    
6375 
6376 
6377          CALL     MOVMF                    ;PUT CURRENT FAC INTO OUR ARG VARIABLE
6378 
6379 
6380                                            ;OUT OF FAC INTO [H,L] LOCATION
6381          POP      H                        ;POP OFF FORMULA TXTPTR
6382 IFN      LENGTH-2,<
6383          CALL     FRMNUM>                  ;EVALUATE IT AND MUST SURE ITS NUMERIC
6384 IFE      LENGTH-2,<
6385          CALL     FRMEVL   
6386 
6387 
6388          PUSH     H        
6389          CALL     FRCSNG   
6390 
6391 
6392          POP      H>       
6393          DCX      H        
6394          CHRGET                            ;SEE IF TERMINATED
6395          JNZ      SNERR                    ;IF NOT SYNTAX ERROR
6396 
6397 
6398                                            ;TO BE NICE SHOULD HAVE NEW CURLIN
6399                                            ;BUT VERY MESSY
6400          POP      H                        ;POP OFF POINTER AT ARG VARIABLE
6401          POP      D        
6402          POP      B>                       ;POP OFF OLD VALUE
6403 IFN      MULDIM!STRING!FUNCTS,<
6404 DEFFIN:  MOV      M,C      
6405          INX      H                        ;STORE THE OLD VALUE
6406          MOV      M,B      
6407 PUTDEI:  INX      H        
6408          MOV      M,E      
6409          INX      H        
6410          MOV      M,D      
6411          POP      H                        ;POP OFF OLD TXTPTR
6412          RET>                              ;VALUE IS IN FAC -- ALL DONE
6413 IFN      FUNCTS,< 
6414 ; 
6415 ; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND
6416 ; COMPLAIN IF SO
6417 ; 
6418 ERRDIR:  PUSH     H                        ;SAVE THEIR [H,L]
6419          LHLD     CURLIN                   ;SEE WHAT THE CURRENT LINE IS
6420 
6421 
6422          INX      H                        ;DIRECT IS 65535 SO NOW 0
6423          MOV      A,H      
6424          ORA      L                        ;IS IT ZERO NOW?
6425          POP      H        
6426          RNZ                               ;RETURN IF NOT
6427          MVI      E,ERRID                  ;"ILLEGAL DIRECT" ERROR
6428 
6429          JMP      ERROR    
6430 
6431 
6432 ; 
6433 ; SUBROUTINE TO GET A POINTER TO A FUNCTION NAME
6434 ; 
6435 GETFNM:  SYNCHK   FNTK                     ;MUST START WITH "FN"
6436 
6437          MVI      A,128                    ;DONT ALLOW AN ARRAY
6438 
6439          STA      SUBFLG                   ;DON'T RECOGNIZE THE "(" AS
6440 
6441 
6442                                            ;THE START OF AN ARRAY REFEREENCE
6443          ORA      M                        ;PUT FUNCTION BIT ON
6444          MOV      B,A                      ;GET FIRST CHARACTER INTO [B]
6445 IFN      LENGTH-2,<
6446 IFN      STRING,<CALL PTRGT2               ;REALLY GET THE POINTER
6447          JMP      CHKNUM>>                 ;MAKE SURE ITS NOT A STRING NAME
6448 IFE      STRING&<LENGTH-2>,<JMP     PTRGT2>> 
6449 
6450 
6451 PAGE     
6452 SUBTTL   STRING FUNCTIONS
6453 IFN      STRING,                           ;STRING HANDLING SUBROUTINES
6454 ; 
6455 ; THE STR$ FUNCTION TAKES A NUMBER AND GIVES
6456 ; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
6457 ; WOULD HAVE GIVEN
6458 ; 
6459 STR$:    
6460 IFN      LENGTH-2,<
6461          CALL     CHKNUM>                  ;MAKE SURE THE ARGUMENT
6462                                            ;IS A NUMERIC
6463          CALL     FOUT                     ;DO ITS OUTPUT
6464 
6465 
6466          CALL     STRLIT                   ;SCAN IT AND TURN IT INTO A STRING
6467 
6468 
6469          CALL     FREFAC                   ;FREE UP THE TEMP
6470 
6471 
6472          LXI      B,FINBCK 
6473 
6474 
6475          PUSH     B                        ;SET UP ANSWER IN NEW TEMP
6476 ; 
6477 ; STRCPY CREATES A COPY OF THE STRING
6478 ; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
6479 ; ON RETURN [D,E] POINTS TO DSCIMP
6480 ; WHICH HAS THE STRING INFO (LENGTH, WHERE COPIED TO)
6481 ; 
6482 STRCPY:  MOV      A,M                      ;GET LENGTH
6483          INX      H                        ;MOVE UP TO THE POINTER
6484 IFN      LENGTH-2,<
6485          INX      H>       
6486          PUSH     H                        ;GET POINTER TO POINTER OF ARG
6487          CALL     GETSPA                   ;GET THE SPACE
6488 
6489 
6490          POP      H                        ;FIND OUT WHERE STRING TO COPY
6491          PUSHM                             ;REALLY IS IN [B,C]
6492          POP      B        
6493          CALL     STRAD2                   ;SETUP DSCTMP
6494 
6495 
6496          PUSH     H                        ;SAVE POINTER TO DSCTMP
6497          MOV      L,A                      ;GET CHARACTER COUNT INTO [L]
6498          CALL     MOVSTR                   ;MOVE THE CHARS IN
6499 
6500 
6501          POP      D                        ;RESTORE POINTER TO OSCTMP
6502          RET      RETURN   
6503 
6504 STRINI:  CALL     GETSPA                   ;GET SOME STRING SPACE ([A] CHARS)
6505 
6506 
6507 STRAD2:  LXI      H,DSCTMP                 ;GET DESC. TEMP
6508 
6509 
6510 STRAD1:  PUSH     H                        ;SAVE DESC. POINTER
6511          MOV      M,A                      ;SAVE CHARACTER COUNT
6512 IFN      LENGTH-2,<
6513          INX      H>                       ;MOVE TO ADDRESS FIELD
6514          JMP      PUTDEI                   ;USE COMMON CODE TO
6515 
6516 
6517                                            ;STORE [D,E]=POINTER TO FREE SPACE
6518                                            ;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
6519 ; 
6520 ; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
6521 ; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
6522 ; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
6523 ; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
6524 ; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
6525 ; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN (B)
6526 ; AND [D] IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
6527 ; OVER, LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
6528 ; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
6529 ; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
6530 ; NOT SET UP.
6531 ; 
6532 STRLIT:  DCX      H        
6533 STRLTI:  MVI      B,34                     ;ASSUME STR ENDS ON QUOTE
6534 
6535 STRLT3:  MOV      D,B      
6536 STRLT2:  PUSH     H                        ;SAVE POINTER TO START OF LITERAL
6537          MVI      C,255                    ;INITIALIZE CHARACTER COUNT
6538 
6539 STRGET:  INX      H        
6540          MDV      A,M                      ;GET CHAR
6541          INR      C                        ;BUMP CHARACTER COUNT
6542          ORA      A                        ;IF 0, (END OF LINE) DONE
6543          JZ       STRFIN                   ;TEST
6544 
6545 
6546          CMP      D        
6547          JZ       STRFIN   
6548 
6549 
6550          CMP      B                        ;CLOSING QUOTE
6551          JNZ      STRGET                   ;NO, GO BACK FOR MORE
6552 
6553 
6554 STRFIN:  CPI      34                       ;IF QUOTE TERMINATES THE STRING
6555 
6556          CZ       CHRGTR                   ;SKIP OVER THE QUOTE
6557 
6558 
6559          XTHL     
6560          INX      H        
6561          XCHG                              ;GET POINTER TO TEMP
6562          MOV      A,C                      ;GET CHARACTER COUNT IN A
6563          CALL     STRAD2                   ;SAVE STR INFO
6564 
6565 
6566                                            ;COMPARE DESC. POINTER & STR POINTER
6567          COMPAR                            ;TO SEE IF STR IN BUF
6568          CNC      STRCPY                   ;IF IN BUF, MUST COPY IT.
6569 
6570 
6571                                            ;OTHERWISE STR IN PROGRAM.
6572 ; 
6573 ; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
6574 ; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
6575 ; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
6576 ; RESULT AS TYPE STRING
6577 ; 
6578 PUTNEW:  LXI      D,DSCTMP                 ;[D,E] POINT AT RESULT DESCRIPTOR
6579 
6580 
6581          LHLD     TEMPPT                   ;[H,L]=POINTER TO FIRST FREE TEMP
6582 
6583 
6584          SHLD     FACLO                    ;POINTER AT WHERE RESULT DESCRIPTOR WILL BE
6585 
6586 
6587 IFE      LENGTH-2,<
6588          MVI      A,3      
6589 
6590          STA      VALTYP                   ;FLAG THIS AS A STRING
6591 
6592 
6593          CALL     VMOVE>                   ;AND MOVE THE VALUE INTO A TEMPORARY
6594 
6595 
6596 IFN      LENGTH-2,<
6597          MVI      A,1                      ;FLAG RESULT AS STRING
6598          STA      VALTYP                   ;STORE IN "VALUE-TYPE" LOCATION
6599          CALL     MOVE>                    ;TRANSFER THE DESCRIPTOR IN
6600          COMPAR                            ;DSCTMP IS JUST BEYOND THE TEMPS
6601                                            ;AND IF TEMPPT POINTS AT IT THERE
6602                                            ;ARE NO FREE TEMPS
6603          MVI      E,ERRST                  ;"STRING TEMPORARY" ERROR
6604 
6605          JZ       ERROR                    ;GO TELL HIM
6606 
6607 
6608          SHLD     TEMPPT                   ;SAVE NEW TEMPORARY POINTER
6609 
6610 
6611          POP      H                        ;GET THE TEXT POINTER
6612          MOV      A,M                      ;GET CURRENT CHARACTER INTO [A]
6613          RET      
6614 ; 
6615 ; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
6616 ; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
6617 ; 
6618 STROUI:  INX      H                        ;POINT AT NEXT CHARACTER
6619 STROUT:  CALL     STRLIT                   ;GET A STRING LITERAL
6620 
6621 
6622 ; 
6623 ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
6624 ; 
6625 STRPRT:  CALL     FREFAC                   ;RETURN TEMP POINTER BY FACLO
6626 
6627 
6628 IFE      LENGTH-2,<
6629          CALL     GETBCD                   ;[D]=LENGTH [B,C]=POINTER AT DATA
6630 
6631 
6632          INR      D                        ;INCREMENT AND DECREMENT EARLY
6633                                            ;TO CHECK FOR NULL STRING
6634 STRPR2:  DCR      D>                       ;DECREMENT THE LENGTH
6635 IFN      LENGTH-2,<
6636          CALL     MOVRM                    ;GET LENGTH IN [E]
6637          INR      E                        ;AND POINTER TO CHARACTERS IN [B,C]
6638 STRPR2:  DCR      E>       
6639          RZ                                ;ALL DONE
6640          LDAX     B                        ;GET CHARACTER TO PRINT
6641          OUTCHR   
6642          CPI      CR       
6643 
6644          CZ       CRFIN    
6645 
6646 
6647          INX      B                        ;POINT TO THE NEXT CHARACTER
6648          JMP      STRPR2                   ;AND PRINT IT
6649 
6650 
6651 ; 
6652 ; GETSPA - GET SPACE FOR CHARACTER STRING
6653 ; MAY FORCE GARBAGE COLLECTION.
6654 ; 
6655 ; # OF CHARS (BYTES) IN [A]
6656 ; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
6657 ; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
6658 ; 
6659 GETSPA:  ORA      A                        ;MUST BE NON ZERO. SIGNAL NO GARBAG YET
6660          XWD      ^O1000,^O16              ;"MVI C," AROUND THE NEXT
6661 TRYGI2:  POP      PSW                      ;IN CASE COLLECTED WHAT WAS LENGTH?
6662          PUSH     PSW                      ;SAVE IT BACK
6663          LHLD     STKTOP                   ;GET BOTTOM OF STRING SPACE
6664 
6665 
6666          XCHG                              ;IN [D,E]
6667          LHLD     FRETOP                   ;GET TOP OF FREE SPACE IN [H,L]
6668 
6669 
6670          CMA      1                        ;-# OF CHARS
6671          MOV      C,A                      ;IN [B,C]
6672          MVI      B,255    
6673 
6674          DAD      B                        ;SUBTRACT FROM TOP OF FREE
6675          INX      H        
6676          COMPAR                            ;COMPARE THE TWO
6677          JC       GARBAG                   ;NOT ENOUGH ROOM FOR STRING, OFFAL TIME
6678 
6679 
6680          SHLD     FRETOP                   ;SAVE NEW BOTTOM OF MEMORY
6681 
6682 
6683          INX      H                        ;MOVE BACK TO POINT TO STRING
6684          XCHG                              ;RETURN WITH POINTER IN [D,E]
6685 PPSWRT:  POP      PSW                      ;GET CHARACTER COUNT
6686          RET                               ;RETURN FROM GETSPA
6687 
6688 GARBAG:  POP      PSW                      ;HAVE WE COLLECTED BEFORE?
6689          MVI      E,ERRSO                  ;GET READY FOR OUT OF STRING SPACE ERROR
6690 
6691          JZ       ERROR                    ;GO TELL USER HE LOST
6692 
6693 
6694          CMP      A                        ;SET ZERO FLAG TO SAY WEVE GARBAGED
6695          PUSH     PSW                      ;SAVE FLAG BACK ON STACK
6696          LXI      B,TRYGI2                 ;PLACE FOR GARBAG TO RETURN TO.
6697 
6698 
6699          PUSH     B                        ;SAVE ON STACK
6700 GARBA2:  LHLD     MEMSIZ                   ;START FROM TOP DOWN
6701 
6702 
6703 IFE      REALIO,< 
6704          MVI      A,7                      ;RING THE BELL ON GARBAGE COLLECTION
6705          OUTCHR>  
6706 FNDVAR:  SHLD     FRETOP                   ;LIKE SO
6707 
6708 
6709          LXI      H,$CODE                  ;GET DOUBLE ZERO
6710 
6711 
6712          PUSH     H                        ;SAY DIDNT SEE VARS THIS PASS
6713          LHLD     STKTOP                   ;FORCE DVARS TO IGNORE STRINGS
6714 
6715 
6716                                            ;IN THE PROGRAM TEXT (LITERALS, DATA)
6717          PUSH     H                        ;FORCE FIND HIGH ADDRESS
6718          LXI      H,TEMPST                 ;GET START OF STRING TEMPS
6719 
6720 
6721 TVAR:    XCHG                              ;SAVE IN [D,E]
6722          LHLD     TEMPPT                   ;SEE IF DONE
6723 
6724 
6725          XCHG                              ;FLIP
6726          COMPAR                            ;TEST
6727          LXI      B,TVAR                   ;FORCE JUMP TO TVAR
6728 
6729 
6730          JNZ      DVAR2                    ;DO TEMP VAR GARBAGE COLLECT
6731 
6732 
6733 
6734 SVARS:   LHLD     VARTAB                   ;GET START OF SIMPLE VARIABLES
6735 
6736 
6737 SVAR:    XCHG                              ;GET IN [D,E]
6738          LHLD     ARYTAB                   ;GET END OF SIMPS
6739 
6740 
6741          XCHG                              ;FLIP
6742          COMPAR                            ;SEE IF AT END OF SIMPS
6743          JZ       ARYVAR                   ;IF YES, DO ARRAY TYPE STRINGS
6744 
6745 
6746          MOV      A,M                      ;GET 2ND CHARACTER OF VARIABLE
6747          INX      H                        ;BUMP POINTER TWICE
6748          INX      H        
6749 IFE      LENGTH-2,<
6750          INX      H                        ;POINT AT THE VALUE
6751          CPI      3                        ;SEE IF ITS A STRING
6752 
6753          JNZ      SKPVAR                   ;IF NOT, JUST SKIP AROUND IT
6754 
6755 
6756          CALL     DVARS                    ;COLLECT IT
6757 
6758 
6759          XRA      A                        ;AND DON'T SKIP ANYTHING MORE
6760 SKPVAR:  MOV      E,A      
6761          MVI      D,0                      ;[D,E]=AMOUNT TO SKIP
6762 
6763          DAD      D>       
6764 IFN      LENGTH-2,<
6765          ORA      A                        ;SET CC'S
6766          CALL     DVARS>                   ;CALL THE VARIABLE GARB ROUT.
6767          JMP      SVAR                     ;GET NEXT ONE
6768 
6769 
6770 
6771 ARYVA2:  POP      B                        ;GET RID OF STACK GARBAGE
6772 ARYVAR:  XCHG                              ;SAVE ARYVAR IN [D,E]
6773          LHLD     STREND                   ;GET END OF ARRAYS
6774 
6775 
6776          XCHG                              ;FLIP BACK
6777          COMPAR                            ;SEE IF DONE WITH ARRAYS
6778          JZ       GRBPAS                   ;YES, SEE IF DONE COLLECTING
6779 
6780 
6781 IFE      LENGTH-2,<
6782          MOV      A,M                      ;GET THE VALUE TYPE INTO [A]
6783          INX      H>       
6784          CALL     MOVRM                    ;GET LENGTH OF ARRAY IN [B,C]
6785 
6786 
6787 IFN      LENGTH-2,<
6788          MOV      A,E>                     ;GET 2ND CHAR OF VAR NAME IN A
6789          PUSH     H                        ;SAVE POINTER TO DIMS
6790          DAD      B                        ;ADD TO CURRENT POINTER POSITION
6791 IFE      LENGTH-2,<
6792          CPI      3                        ;SEE IF ITS A STRING
6793 
6794          JNZ      ARYVA2>                  ;IF NOT JUST SKIP IT
6795 
6796 
6797 IFN      LENGTH-2,<
6798          ORA      A                        ;SEE IF STRING VAR
6799          JP       ARYVA2>                  ;NO, KEEP ON TRUCKIN
6800          SHLD     TEMP3                    ;SAVE END OF ARRAY
6801 
6802 
6803          POP      H                        ;GET BACK CURRENT POSITION
6804          MOV      C,M                      ;PICK UP NUMBER OF DIMS
6805          MVI      B,0                      ;MAKE DOUBLE WITH HIGH ZERO
6806 
6807          DAD      B                        ;GO PAST DIMS
6808          DAD      B                        ;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
6809          INX      H                        ;ONE MORE TO ACCOUNT FOR #DIMS.
6810 ARYSTR:  XCHG                              ;SAVE CURRENT POSIT IN [D,E]
6811          LHLD     TEMP3                    ;GET END OF ARRAY
6812 
6813 
6814          XCHG                              ;FIX [H,L] BACK TO CURRENT
6815          COMPAR                            ;SEE IF AT END OF ARRAY
6816          JZ       ARYVAR                   ;END OF ARRAY, TRY NEXT ARRAY
6817 
6818 
6819          LXI      B,ARYSTR                 ;ADDR OF WHERE TO RETURN TO
6820 
6821 
6822 DVAR2:   PUSH     B                        ;GOES ON STACK
6823 IFE      LENGTH-2,<
6824 DVAR:    
6825 DVARS:   XRA      A        
6826          ORA      M                        ;SEE IF ITS THE NULL STRING
6827          INX      H        
6828          MOV      E,M      
6829          INX      H        
6830          MOV      D,M      
6831          INX      H>                       ;[D,E]=POINTER AT THE VALUE
6832 IFN      LENGTH-2,<
6833 DVAR:    ORI      128                      ;FORCE DVAR TO CALL GRBVAR
6834 DVARS:   PUSHM                             ;SAVE LENGTH
6835          PUSHM                             ;SKIP NEXT TWO BYTES
6836          POP      D                        ;GET POINTER IN [D,E]
6837          POP      B                        ;POP OF STRING LENGTH
6838          RP                                ;IF WASNT A STR, RETURN
6839          MOV      A,C                      ;GET LENGTH OF STRING
6840          ORA      A>                       ;SET CONDITION CODES
6841          RZ                                ;NULL STRING, RETURN
6842          MOV      B,H                      ;MOVE [H,L] TO [B,C]
6843          MOV      C,L      
6844          LHLD     FRETOP                   ;GET POINTER TO TOP OF STRING FREE SPACE
6845 
6846 
6847          COMPAR                            ;IS THIS STRINGS POINTER .LT. FRETOP
6848          MOV      H,B                      ;MOVE [B,C] BACK TO [H,L]
6849          MOV      L,C      
6850          RC                                ;IF NOT, NO NEED TO MESS WITH IT FURTHUR
6851          POP      H                        ;GET RETURN ADDRESS OFF STACK
6852          XTHL                              ;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
6853          COMPAR                            ;LETS SEE
6854          XTHL                              ;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
6855          PUSH     H                        ;SAVE RETURN ADDRESS BACK
6856          MOV      H,B                      ;MOVE [B,C] BACK TO [H,L]
6857          MOV      L,C      
6858          RNC                               ;IF NOT, LETS LOOK AT NEXT VAR
6859          POP      B                        ;GET RETURN ADDR OFF STACK
6860          POP      PSW                      ;POP OFF MAX SEEN
6861          POP      PSW                      ;AND VARIABLE POINTER
6862          PUSH     H                        ;SAVE NEW VARIABLE POINTER
6863          PUSH     D                        ;AND NEW MAX POINTER
6864          PUSH     B                        ;SAVE RETURN ADDRESS BACK
6865          RET                               ;AND RETURN
6866 ; 
6867 ; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
6868 ; 
6869 GRBPAS:  POP      D                        ;POP OFF MAX POINTER
6870          POP      H                        ;AND GET VARIABLE POINTER
6871          MOV      A,L                      ;GET LOW IN
6872          ORA      H                        ;SEE IF ZERO POINTER
6873          RZ                                ;IF END OF COLLECTION,
6874                                            ;THEN MAYBE RETURN TO GETSPA
6875          DCX      H                        ;CURRENTLY JUST PAST THE DESCRIPTOR
6876          MOV      B,M                      ;[B,C]=HIGH BYTE OF DATA POINTER
6877          DCX      H        
6878          MOV      C,M                      ;[B,C]=POINTER AT STRING DATA
6879          PUSH     H                        ;SAVE THIS LOCATION SO THE POINTER
6880                                            ;CAN BE UPDATED AFTER THE STRING IS
6881                                            ;MOVED
6882          DCX      H        
6883 IFN      LENGTH-2,<
6884          DCX      H>       
6885          MOV      L,M                      ;[L]=STRING LENGTH
6886          MVI      H,0                      ;[H,L] GET CHARACTER COUNT
6887 
6888          DAD      B                        ;[H,L]=POINTER BEYOND STRING
6889          MOV      D,B      
6890          MOV      E,C                      ;[D,E]=ORIGINAL POINTER
6891          DCX      H                        ;DON'T MOVE ONE BEYOND STRING
6892          MOV      B,H                      ;GET TOP OF STRING IN [B,C]
6893          MOV      C,L      
6894          LHLD     FRETOP                   ;GET TOP OF FREE SPACE
6895 
6896 
6897          CALL     BLTUC                    ;MOVE STRING
6898 
6899 
6900          POP      H                        ;GET BACK POINTER TO DESC.
6901          MOV      M,C                      ;SAVE FIXED ADDR
6902          INX      H                        ;MOVE POINTER
6903          MOV      M,B                      ;HIGH PART
6904          MOV      L,C      
6905          MOV      H,B                      ;[H,L]=NEW POINTER
6906          DCX      H                        ;FIX UP FRETOP
6907          JMP      FNDVAR                   ;AND TRY TO FIND HIGH AGAIN
6908 
6909 
6910 
6911 ; 
6912 ; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
6913 ; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
6914 ; [H,L] POINTS BEYOND THE SIGN AFTER IT
6915 ; 
6916 CAT:     PUSH     B                        ;PUT OLD PRECEDENCE BACK ON
6917          PUSH     H                        ;SAVE TEXT POINTER
6918          LHLD     FACLO                    ;GET POINTER TO STRING DESC.
6919 
6920 
6921          XTHL                              ;SAVE ON STACK & GET TEXT POINTER BACK
6922          CALL     EVAL                     ;EVALUATE REST OF FORMULA
6923 
6924 
6925          XTHL                              ;SAVE TEXT POINTER, GET BACK DESC.
6926          CALL     CHKSTR   
6927 
6928 
6929          MOV      A,M      
6930          PUSH     H                        ;SAVE DESC. POINTER.
6931          LHLD     FACLO                    ;GET POINTER TO 2ND DESC.
6932 
6933 
6934          PUSH     H                        ;SAVE IT
6935          ADD      M                        ;ADD TWO LENGTHS TOGETHER
6936          MVI      E,ERRLS                  ;SEE IF RESULT .LT. 256
6937 
6938          JC       ERROR                    ;ERROR "LONG STRING"
6939 
6940 
6941          CALL     STRINI                   ;GET INITIAL STRING
6942 
6943 
6944          POP      D                        ;GET 2ND DESC.
6945          CALL     FRETMP   
6946 
6947 
6948          XTHL                              ;SAVE POINTER TO IT
6949          CALL     FRETM2                   ;FREE UP 1ST TEMP
6950 
6951 
6952          PUSH     H                        ;SAVE DESC. POINTER (FIRST)
6953          LHLD     DSCTMP+2                 ;GET POINTER TO FIRST
6954 
6955 
6956          XCHG                              ;IN [D,E]
6957          CALL     MOVINS                   ;MOVE IN THE FIRST STRING
6958 
6959 
6960          CALL     MOVINS                   ;AND THE SECOND
6961 
6962 
6963          LXI      H,TSTOP                  ;CAT REENTERS FORMULA EVALUATION AT TSTOP
6964 
6965 
6966          XTHL     
6967          PUSH     H                        ;TEXT POINTER OFF FIRST
6968          JMP      PUTNEW                   ;THEN RETURN ADDRESS OF TSTOP
6969 
6970 
6971 
6972 
6973 MOVINS:  POP      H                        ;GET RETURN ADDR
6974          XTHL                              ;PUT BACK, BUT GET DESC.
6975 IFE      LENGTH-21
6976          MOV      A,M                      ;[A]=STRING LENGTH
6977          INX      H        
6978          MOV      C,M                      ;[B,C]=POINTER AT STRING DATA
6979          INX      H        
6980          MOV      B,M      
6981          MOV      L,A>                     ;[L]=STRING LENGTH
6982 IFN      LENGTH-2,<
6983          PUSHM                             ;GET LENGTH ON STACK
6984          PUSHM                             ;AND POINTER
6985          POP      B                        ;TEXT POINTER HERE
6986          POP      H>                       ;CHARACTER COUNT HERE
6987 MOVSTR:  INR      L        
6988 MOVLP:   DCR      L                        ;SET CC'S
6989          RZ                                ;0, NO BYTE TO MOVE
6990          LDAX     B                        ;GET CHAR
6991          STAX     D                        ;SAVE IT
6992          INX      B                        ;MOVE POINTERS
6993          INX      D        
6994          JMP      MOVLP                    ;KEEP DOING IT
6995 
6996 
6997 ; 
6998 ; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
6999 ; THIS VALUE IS RETURNED IN [H,L], ALL THE OTHER REGISTERS ARE MODIFIED.
7000 ; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
7001 ; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
7002 ; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
7003 ; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
7004 ; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
7005 ; THE LOWEST PART OF STRING SPACE IN USE.
7006 ; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
7007 ; LONGER IS USE. THIS CAUSES DIFFICULTY FOR ASSIGNMENT ("LET") BECAUSE
7008 ; THOUGH A TEMPORARY IS BEING FREED UP, NAMELY THE VALUE TO THE RIGHT
7009 ; OF THE EQUAL SIGN IN THE "LET", THE ACTUAL DATA
7010 ; IS STILL ACTIVE DATA SINCE A VARIABLE IS BEING SET UP TO POINT
7011 ; AT IT. "LET" FOOLS FRETMP BY SETTING THE LENGTH OF THE
7012 ; TEMPORARY TO ZERO TEMPORARILY.
7013 ; 
7014 FRESTR:  CALL     CHKSTR                   ;MAKE SURE ITS A STRING
7015 
7016 
7017 FREFAC:  LHLD     FACLO    
7018 
7019 
7020 FRETM2:  XCHG                              ;FREE UP THE TEMP IN THE FACLO
7021 FRETMP:  LHLD     TEMPPT                   ;GET TEMP POINTER
7022 
7023 
7024          DCX      H                        ;LOOK AT WHAT IS IN THE LAST TEMP
7025          MOV      B,M                      ;[B,C]=POINTER AT STRING
7026          DCX      H                        ;DECREMENT TEMPPT BY STRSIZ
7027          MOV      C,M      
7028          OCX      H        
7029 IFN      LENGTH-2,<
7030          DCX      H>       
7031          COMPAR                            ;SEE IF [D,E] POINT AT THE LAST
7032          XCHG                              ;RETURN WITH [H,L]
7033                                            ;POINTING AT CURRENT DESCRIPTOR
7034          RNZ                               ;RETURN NOW IF NOW FREEING DONE
7035          SHLD     TEMPPT                   ;UPDATE THE TEMP POINTER SINCE
7036 
7037 
7038                                            ;ITS BEEN DECREMENTED BY 4
7039          PUSH     D                        ;SAVE [D,E] TO RETURN IN [H,L]
7040          MOV      D,B                      ;[D,E]=POINTER AT STRING
7041          MOV      E,C      
7042          DCX      D                        ;SUBTRACT ONE
7043          MOV      C,M                      ;[C]=LENGTH OF THE STRING FREED UP
7044          LHLD     FRETOP                   ;SEE IF ITS THE FIRST
7045 
7046 
7047                                            ;ONE IN STRING SPACE
7048          COMPAR   
7049          JNZ      NOTLST                   ;NO SO DON'T ADD
7050 
7051 
7052          MOV      B,A                      ;MAKE [B]=0
7053          DAD      B                        ;ADD
7054          SHLD     FRETOP                   ;AND UPDATE FRETOP
7055 
7056 
7057 NOTLST:  POP      H                        ;GET POINTER AT CURRENT DESCRIPTOR
7058          RET      
7059 ; 
7060 ; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE
7061 ; STRING PASSED AS AN ARGUMENT
7062 ; 
7063 LEN:     LXI      B,SNGFLT                 ;CALL SNGFLT WHEN DONE
7064 
7065 
7066          PUSH     B                        ;LIKE SO
7067 LEN1:    CALL     FRESTR                   ;FREE UP TEMP POINTED TO BY FACLO
7068 
7069 
7070          XRA      A                        ;FORCE NUMERIC FLAG
7071          MOV      D,A                      ;SET HIGH OF [D,E] TO ZERO FOR VAL
7072 IFN      LENGTH-2,<
7073          STA      VALTYP>  
7074          MOV      A,M      
7075          ORA      A                        ;SET CONDITION CODES ON LENGTH
7076          RET      RETURN   
7077 ; 
7078 ; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER
7079 ; WHICH IS THE DECIMAL ASCII EQUIVALENT
7080 ; 
7081 ASC:     CALL     LEN1                     ;SET UP ORIGINAL STR
7082 
7083 
7084          JZ       FCERR                    ;NULL STR, BAD ARG.
7085 
7086 
7087          INX      H                        ;BUMP POINTER
7088 IFN      LENGTH-2,<
7089          INX      H>                       ;BUMP POINTER
7090          PUSHM                             ;GET ADDRESS
7091          POP      H                        ;GET ADDR IN [H,L]
7092          MOV      A,M                      ;GET FIRST CHAR
7093          JMP      SNGFLT                   ;SNGFLT IT
7094 
7095 
7096 ; 
7097 ; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
7098 ; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
7099 ; WHICH MUST BE .LT. 255.
7100 ; 
7101 CHR$:    MVI      A,1                      ;ONE CHARACTER STR
7102 
7103          CALL     STRINI                   ;GET STRING IN DSCTMP
7104 
7105 
7106          CALL     CONINT                   ;GET INTEGER IN RANGE
7107 
7108 
7109          LHLD     DSCTMP+2                 ;GET ADDR OF STR
7110 
7111 
7112          MOV      M,E                      ;SAVE ASCII BYTE
7113 FINBCK:  POP      B                        ;RETURN TO HIGHER LEVEL &
7114                                            ;SKIP THE CHKNUM CALL.
7115          JMP      PUTNEW                   ;DO CALL PUTNEW
7116 
7117 
7118 ; 
7119 ; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
7120 ; IT TAKES THE LEFTMOST # CHARS OF THE STR.
7121 ; IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
7122 ; 
7123 LEFT$:   CALL     PREAM                    ;TEST THE PARAMETERS
7124 
7125 
7126          XRA      A                        ;LEFT NEVER CHANGES STRING POINTER
7127 LEFT3:   XTHL                              ;SAVE TEXT POINTER
7128          MOV      C,A                      ;OFFSET NOW IN [C]
7129 LEFT2:   PUSH     H                        ;SAVE DESC. FOR FRETMP
7130          MOV      A,M                      ;GET STRING LENGTH
7131          CMP      B                        ;ENTIRE STRING WANTED?
7132          JC       ALLSTR                   ;IF #CHARS ASKED FOR.GE.LENGTH, YES
7133 
7134 
7135          MOV      A,B                      ;GET TRUNCATED LENGTH OF STRING
7136          XWD      ^O1000,^O21              ;SKIP OVER MVI USING "LXI D,"
7137 ALLSTR:  MVI      C,0                      ;MAKE OFFSET ZERO
7138 
7139          PUSH     B                        ;SAVE OFFSET ON STACK
7140          CALL     GETSPA                   ;GET SPACE FOR NEW STRING
7141 
7142 
7143          POP      B                        ;GET BACK OFFSET
7144          POP      H                        ;GET BACK DESC POINTER.
7145          PUSH     H                        ;BUT KEEP ON STACK
7146          INX      H                        ;MOVE TO STRING POINTER FIELD
7147 IFN      LENGTH-2,<
7148          INX      H>       
7149          MOV      B,M                      ;GET POINTER LOW
7150          INX      H        
7151          MOV      H,M                      ;POINTER HIGH
7152          MOV      L,B                      ;GET LOW IN L
7153          MVI      B,0                      ;GET READY TO ADD OFFSET TO POINTER
7154 
7155          DAD      B                        ;ADD IT
7156          MOV      B,H                      ;GET OFFSET POINTER IN [B,C]
7157          MOV      C,L      
7158          CALL     STRAD2                   ;SAVE INFO IN DSCTMP
7159 
7160 
7161          MOV      L,A                      ;GET # OF CHARS TO MOVE IN L
7162          CALL     MOVSTR                   ;MOVE THEM IN
7163 
7164 
7165          POP      D                        ;GET BACK DESC. POINTER
7166          CALL     FRETMP                   ;FREE IT UP.
7167 
7168 
7169          JMP      PUTNEW                   ;PUT TEMP IN TEMP LIST
7170 
7171 
7172 
7173 RIGHT$:  CALL     PREAM                    ;CHECK ARG
7174 
7175 
7176          POP      D                        ;GET DESC. POINTER
7177          PUSH     D                        ;SAVE BACK FOR LEFT
7178          LDAX     D                        ;GET PRESENT LEN OF STR
7179          SUB      B                        ;SUBTRACT 2ND PARM
7180          JMP      LEFT3                    ;CONTINUE WITH LEFT CODE
7181 
7182 
7183 ; 
7184 ; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION
7185 ; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING,
7186 ; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
7187 ; FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
7188 ; AS MUCH AS POSSIBLE.
7189 ; 
7190 MID$:    XCHG                              ;PUT THE TEXT POINTER IN [H,L]
7191          MOV      A,M                      ;GET THE FIRST CHARACTER
7192          CALL     PREAM2                   ;GET OFFSET OFF STACK AND MAKE
7193 
7194 
7195                                            ;SURE DOES NOT = 0.
7196          PUSH     B                        ;PUT OFFSET ON TO THE STACK
7197          MVI      E,255                    ;IF TWO ARG GUY, TRUNCATE.
7198 
7199          CPI      ")"      
7200 
7201          JZ       MID2                     ;[E] SAYS USE ALL CHARS
7202 
7203 
7204                                            ;IF ONE ARGUMENT THIS IS CORRECT
7205          SYNCHK   44                       ;COMMA? MUST DELINEATE 3RD ARG.
7206 
7207          CALL     GETBYT                   ;GET ARGUMENT IN [E]
7208 
7209 
7210 MID2:    SYNCHK   ")"                      ;MUST BE FOLLOWED BY ")"
7211 
7212          POP      PSW                      ;GET OFFSET BACK IN A
7213          XTHL                              ;SAVE TEXT POINTER, GET DESC.
7214          LXI      B,LEFT2                  ;WHERE TO RETURN TO.
7215 
7216 
7217          PUSH     B                        ;GOES ON STACK
7218          DCR      A                        ;SUB ONE FROM OFFSET
7219          CMP      M                        ;POINTER PAST END OF STR?
7220          MVI      B,0                      ;ASSUME NULL LENGTH STR
7221 
7222          RNC                               ;YES, JUST USE NULL STR
7223          MOV      C,A                      ;SAVE OFFSET OF CHARACTER POINTER
7224          MOV      A,M                      ;GET PRESENT LEN OF STR
7225          SUB      C                        ;SUBTRACT INDEX (2ND ARG)
7226          CMP      E                        ;IS IT TRUNCATION
7227          MOV      B,A                      ;GET CALCED LENGTH IN B
7228          RC                                ;IF NOT USE PARTIAL STR
7229          MOV      B,E                      ;USE TRUNCATED LENGTH
7230          RET>                              ;RETURN TO LEFT2
7231 IFN      LENGTH,< 
7232 ; 
7233 ; THE FOLLOWING FUNCTIONS ALLOW THE
7234 ; USER FULL ACCESS TO THE ALTAIR I/O PORTS
7235 ; INP (CHANNEL#) RETURNS AN INTEGER WHICH IS THE STATUS
7236 ; OF THE CHANNEL. OUT CHANNEL#, VALUE PUTS OUT THE INTEGER
7237 ; VALUE ON CHANNEL #. IT IS A STATEMENT, NOT A FUNCTION.
7238 ; 
7239 FNINP:   CALL     CONINT                   ;GET INTEGER CHANNEL #
7240 
7241 
7242          STA      INPWRD+1                 ;GEN INP INSTR
7243 
7244 
7245 INPWRD:  IN       0                        ;THE INP INSTR
7246 
7247          JMP      SNGFLT                   ;SNGFLT RESULT
7248 
7249 
7250 
7251 FNOUT:   CALL     SETIO                    ;GET READY
7252 
7253 
7254 OUTWRD:  OUT      0                        ;DO IT
7255 
7256          RET                               ;AND THATS ALL
7257 ; 
7258 ; THE WAIT CHANNEL# MASK MASK2 WAITS UNTIL THE STATUS
7259 ; RETURNED BY CHANNEL# IS NON ZERO WHEN XORED WITH MASK2
7260 ; AND THEN ANDED WITH MASK, IF MASK2 IS NOT PRESENT IT IS ASSUMED
7261 ; TO BE ZERO.
7262 ; 
7263 FNWAIT:  CALL     SETIO                    ;SET UP FOR WAIT
7264 
7265 
7266          PUSH     PSW                      ;SAVE THE MASK
7267          MVI      E,0                      ;DEFAULT MASK2 TO ZERO
7268 
7269          DCX      H        
7270          CHRGET                            ;SEE IF THE STATEMENT ENDED
7271          JZ       NOTTHR                   ;IF NO THIRD ARGUMENT SKIP THIS
7272 
7273 
7274          SYNCHK   44                       ;MAKE SURE THERE IS A ","
7275 
7276          CALL     GETBYT   
7277 
7278 
7279 NOTTHR:  POP      B                        ;REGET THE "AND" MASK
7280 STAINP:  IN       0                        ;THE INPUT INSTR
7281 
7282          XRA      E                        ;XOR WITH MASK2
7283          ANA      B                        ;AND WITH MASK
7284          JZ       STAINP                   ;LOOP UNTIL RESULT IS NON-ZERO
7285 
7286 
7287                                            ;NOTE: THIS LOOP CANNOT BE CONTROL-C*ED
7288                                            ;UNLESS THE WAIT IS BEING DONE ON CHANNEL
7289                                            ;ZERO. HOWEVER A RESTART AT 0 IS OK.
7290          RET>     
7291 IFN      STRING,< 
7292                                            ;USED BY RIGHTS AND LEFTS FOR PARAMETER CHECKING AND SETUP
7293 PREAM:   XCHG                              ;PUT THE TEXT POINTER IN [H,L]
7294          SYNCHK   ")"                      ;PARAM LIST SHOULD END
7295 
7296                                            ;USED BY MID$ FOR PARAMETER CHECKING AND SETUP
7297 PREAM2:  POP      B                        ;GET RETURN ADDR OFF STACK
7298          POP      D                        ;GET LENGTH OF ARG OFF STACK
7299          PUSH     B                        ;SAVE RETURN ADDR BACK ON
7300          MOV      B,E                      ;SAVE INIT LENGTH
7301          INR      B        
7302          DCR      B                        ;SEE IF EQUAL TO ZERO
7303 IFE      LENGTH-2,<
7304          RNZ      
7305 ILLFUN:  
7306 FCERR:   MVI      E,ERRFC  
7307 
7308          JMP      ERROR>   
7309 
7310 
7311 IFN      LENGTH-2,<
7312          JZ       FCERR                    ;IT MUST NOT BE 0
7313          RET>     
7314 IFN      LENGTH,< 
7315 SETIO:   CALL     GETBYT                   ;GET INTEGER CHANNEL NUMBER IN [A]
7316 
7317 
7318          STA      STAINP+1                 ;SETUP "WAIT"
7319 
7320 
7321          STA      OUTWRD+1                 ;SETUP "OUT"
7322 
7323 
7324          SYNCHK   44                       ;MAKE SURE THERE IS A COMMA
7325 
7326          XWD      ^O1000,6>                ;"MVI B," AROUND THE CHRGET
7327 IFN      STRING!LENGTH,<
7328 GTBYTC:  CHRGET   
7329 IFE      LENGTH-2,<
7330 GETBYT:  CALL     FRMEVL   
7331 
7332 
7333 CONINT:  PUSH     H        
7334          CALL     FRCINT   
7335 
7336 
7337          XCHG     
7338          POP      H>       
7339 IFN      LENGTH-2,<
7340 GETBYT:  CALL     FRMNUM                   ;READ FORMULA INTO THE FAC.
7341 CONINT:  CALL     POSINT>                  ;CONVERT THE FAC TO A SINGLE BYTE INTEGER
7342          MOV      A,D                      ;SHOULD BE .LT. 255
7343          ORA      A                        ;SET CC'S
7344          JNZ      FCERR                    ;WASN'T ERROR
7345 
7346 
7347          DCX      H                        ;ACTUALLY FUNCTIONS CAN GET HERE
7348                                            ;WITH BAD [H,L] BUT NOT SERIOUS
7349                                            ;SET CONDITION CODES ON TERMINATOR
7350          CHRGET   
7351          MOV      A,E                      ;RETURN THE RESULT IN [A] AND [E]
7352          RET>     
7353 
7354 IFN      STRING,< 
7355 ; 
7356 ; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO
7357 ; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC.
7358 ; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
7359 ; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
7360 ; IS MERELY A CALL TO FLOATING INPUT (FIN).
7361 ; 
7362 VAL:     CALL     LEN1                     ;DO SETUP, SET RESULT=REAL
7363 
7364 
7365          JZ       ZERO                     ;RETURN ZERO IF NULL
7366 
7367 
7368          MOV      E,A                      ;GET LENGTH OF STR
7369 IFN      LENGTH-2,<
7370          INX      H>                       ;THIS IS ALL A KLUDGE
7371          INX      H                        ;TO HANDLE THE FACT THE IF
7372          PUSHM                             ;TWO STRINGS "1" AND "2"
7373          MOV      H,B                      ;ARE STORED NEXT TO EACH OTHER
7374          MOV      L,C                      ;AND FIN IS CALLED POINTING TO
7375          DAD      D                        ;THE FIRST TWELVE WILL BE RETURNED
7376          MOV      B,M                      ;THE IDEA IS TO STORE 0 IN THE
7377          MOV      M,D                      ;STRING BEYOND THE ONE VAL
7378          XTHL                              ;IS BEING CALLED ON
7379          PUSH     B                        ;THE FIRST CHARACTER OF THE NEXT STRING
7380          MOV      A,M                      ;GET FIRST CHARACTER OF ARGUMENT
7381          CALL     FIN                      ;TURN IT INTO A NUMBER IN THE FAC
7382 
7383 
7384          POP      B                        ;GET THE MODIFIED CHARACTER OF THE NEXT
7385                                            ;STRING INTO [B]
7386          POP      H                        ;GET THE POINTER TO THE MODIFIED CHARACTER
7387          MOV      M,B                      ;RESTORE THE CHARACTER
7388                                            ;IF STRING IS HIGHEST IN STRING SPACE
7389                                            ;WE ARE MODIFYING [MEMSIZ] AND
7390                                            ;THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE
7391                                            ;STRING DATA BECAUSE WHAT IF THE
7392                                            ;USER TOOK VAL OFF THAT HIGH STRING
7393          RET>     
7394 
7395 PAGE     
7396 SUBTTL   FANCY LIST, DELETE, EDIT, LLIST
7397 IFE      LENGTH-2,<
7398 IFN      LPTSW,<  
7399 LLIST:   MVI      A,1                      ;GET NON ZERO VALUE
7400          STA      PRTFLG>                  ;SAVE IN I/O FLAG
7401 LIST:    POP      B                        ;GET RID OF NEWSTT RETURN ADDR
7402          CALL     SCNLIN                   ;SCAN LINE RANGE
7403 
7404 
7405          PUSH     B                        ;SAVE POINTER TO 1ST LINE
7406 LIST4:   POP      H                        ;GET POINTER TO LINE
7407          POP      D                        ;GET MAX LINE # OFF STACK
7408          PUSHM                             ;PUSH LINK
7409          MOV      A,B                      ;SEE IF END OF CHAIN
7410          ORA      C        
7411          POP      B                        ;GET LINK OFF STACK FOR ISCNTC
7412          JZ       READY                    ;LAST LINE, STOP.
7413 
7414 
7415 IFN      LISTEN,< 
7416          CALL     ISCNTC>                  ;CHECK FOR CONTROL-C
7417 
7418 
7419          PUSH     B                        ;SAVE LINK BACK ON
7420          PUSHM                             ;PUSH LINE
7421          XTHL                              ;GET LINE # INTO [H,L]
7422          XCHG                              ;GET MAX LINE IN [H,L]
7423          COMPAR                            ;PAST LAST LINE IN RANGE?
7424          POP      B                        ;TEXT POINTER TO [B,C]
7425          JC       STPRDY                   ;IF PAST, THEN DONE LISTING.
7426 
7427 
7428          XTHL                              ;SAVE MAX ON BOTTOM OF STACK
7429          PUSH     H                        ;SAVE LINK ON TOP
7430          PUSH     B                        ;SAVE TEXT POINTER BACK
7431          XCHG                              ;GET LINE # IN [H,L]
7432          CALL     CRDO                     ;DO CRLF TO START OUT
7433 
7434 
7435                                            ;AND WE WANT [H,L] ON THE STACK
7436          CALL     LINPRT                   ;PRINT AS INT WITHOUT LEADING SPACE
7437 
7438 
7439          MVI      A," "    
7440 
7441          POP      H        
7442          OUTCHR                            ;PRINT A SPACE AFTER THE LINE #
7443          CALL     BUFLIN                   ;UNPACK THE LINE INTO BUF
7444 
7445 
7446          LXI      H,BUF-1                  ;POINT AT THE START OF THE UNPACKED CHARACTERS
7447 
7448 
7449          MVI      B,0                      ;STOP ON ZERO ONLY
7450 
7451          CALL     STRLT3                   ;LITERALIZE THE LINE STRING
7452 
7453 
7454          CALL     STRPRT                   ;PRINT OUT THE CHARACTERS
7455 
7456 
7457          JMP      LIST4                    ;PRINT ANOTHER LINE
7458 
7459 
7460 BUFLIN:  LXI      B,BUF-1  
7461 
7462 
7463          XWD      ^O1000,^O26              ;"MVI D," AROUND THE NEXT BYTE
7464 PRIT4:   POP      H                        ;RESTORE POINTER TO START OF TEXT
7465 PLOOP:   MOV      A,M                      ;GET A CHARACTER FROM LINE.
7466          INX      B                        ;ADVANCE STUFF COUNT
7467          ORA      A                        ;IS IT A RESERVED WORD
7468          INX      H                        ;INCREMENT POINTER INTO TEXT
7469          STAX     B                        ;STORE A ZERO IF THE END
7470          RZ                                ;ZERO, END OF LINE.
7471          JP       PLOOP                    ;REGULAR CHAR, JUST PRINT IT
7472 
7473 
7474          CPI      ELSETK                   ;IF ITS "ELSE" DON'T PRINT THE COLON
7475 
7476                                            ;IN FRONT OF IT
7477          CZ       DCXBRT##                 ;BACKUP STUFF COUNT TO ELIMINATE
7478 
7479 
7480          SUI      127                      ;GET RID OF SIGN BIT AND ADD ONE
7481 
7482          PUSH     H                        ;SAVE CURRRENT POSIT
7483          LXI      D,RESLST                 ;GET RESLST POINTER.
7484 
7485 
7486 RESRCH:  PUSH     D        
7487          PUSH     PSW                      ;SAVE THE RESERVED WORD NUMBER
7488 RESCR1:  LDAX     D                        ;GET CHARACTER FROM RESLST
7489          INX      D                        ;BUMP RESLST POINTER
7490          ORA      A                        ;TEST BITS
7491          JP       RESCR1                   ;NOT AT END OF RESERVED WORD YET
7492 
7493 
7494          POP      PSW      
7495          DCR      A                        ;DECREMENT CHAR
7496          POP      H                        ;POP START POINTER HERE
7497          JNZ      RESRCH                   ;NOT AT END OF RESLST YET.
7498 
7499 
7500 ; HERE WHEN FOUND RIGHT RESERVED WORD
7501 PRIT3:   MOV      A,M                      ;GET A CHARACTER FROM RESERVED WORD
7502          ORA      A                        ;SET CONDITION CODES
7503          STAX     B        
7504          JM       PRIT4    
7505 
7506 
7507          INX      B        
7508          INX      H                        ;BUMP RESLST POINTER
7509          JMP      PRIT3                    ;PRINT THE REST
7510 
7511 
7512 ; 
7513 ; THE FOLLOWING CODE IS FOR THE DELETE RANGE
7514 ; COMMAND. BEFORE THE LINES ARE DELETED, 'OK'
7515 ; IS TYPED.
7516 ; 
7517 DELETE:  CALL     SCNLIN                   ;SCAN LINE RANGE
7518 
7519 
7520          POP      D                        ;POP MAX LINE OFF STACK
7521          PUSH     B                        ;SAVE POINTER TO START OF 1ST LINE
7522          CALL     FNDLIN                   ;FIND THE LAST LINE
7523 
7524 
7525          POP      B                        ;GET POINTER TO FIRST IN [B,C]
7526          PUSH     H                        ;SAVE THE POINTER TO THE NEXT LINE
7527          LXI      H,REDDY                  ;PRINT "OK" PREMATURELY
7528 
7529 
7530          CALL     STROUT   
7531 
7532 
7533          LXI      H,FINI                   ;GO BACK TO FINI WHEN DONE
7534 
7535 
7536          XTHL                              ;[H,L]=POINTER TO THE NEXT LINE
7537 DEL:     XCHG                              ;[D,E] NOW HAVE THE POINTER TO THE LINE
7538                                            ;BEYOND THIS ONE
7539          LHLD     VARTAB                   ;COMPACTIFYING TO VARTAB
7540 
7541 
7542 MLOOP:   LDAX     D        
7543          STAX     B                        ;SHOVING DOWN TO ELIMINATE A LINE
7544          INX      B        
7545          INX      D        
7546          COMPAR   
7547          JNC      MLOOP                    ;DONE COMPACTIFYING?
7548 
7549 
7550          MOV      H,B      
7551          MOV      L,C      
7552          INX      H                        ;NEW VARTAB
7553          SHLD     VARTAB   
7554 
7555 
7556          RET>     
7557 PAGE     
7558 SUBTTL   DISK CODE
7559 IFN      DSKFUN,< 
7560 ; 
7561 ; THE STATEMENT DSKO$ STRING, SECTOR WRITES
7562 ; THE STRING (UP TO 132 DECIMAL CHARS)
7563 ; ON THE SECTOR SPECIFIED
7564 ; OSKIS (SECTOR) IS A STRING FUNCTION THAT
7565 ; RETURNS THE 133 BYTE STRING STORED ON SECTOR.
7566 ; 
7567 DSKO$:   CALL     FRMEVL                   ;EVALUATE FORMULA
7568          SYNCHK   44                       ;FOLLOWED BY COMMA
7569          PUSH     H                        ;SAVE TEXT POINTER
7570          CALL     FRESTR                   ;FREE UP THE FACLO
7571          XTHL                              ;[H,L]=TXTPTR SAVE POINTER AT
7572                                            ;STRING DESCRIPTOR ON THE STACK
7573          CALL     GETBYT                   ;EVALUATE 2ND (SECTOR) IN [E]
7574          XTHL                              ;SAVE TEXT POINTER, GET DESC.
7575          PUSHM                             ;[C]=LENGTH [H,L]=POINTER
7576          PUSHM    
7577          POP      H                        ;[H,L] GET STRING POINTER
7578          POP      B        
7579          MOV      B,A                      ;SECTOR NUMBER INTO [B]
7580          MVI      A,^D137  
7581          SUB      C        
7582          JC       FCERR                    ;STRING TOO LONG
7583          INR      A        
7584          MOV      E,A                      ;NUMBER OF ZEROS+1
7585          MVI      D,64                     ;SETUP A MASK
7586          INR      C        
7587          MVI      A,4                      ;LOAD THE HEAD
7588          OUT      9                        ;TO DISK STATUS
7589 SECLP:   IN       ^O11                     ;GET SECTOR STATUS
7590          RAR                               ;TEST FOR START OF SECTOR
7591          JNC      SECLP                    ;KEEP WAITING
7592          ANI      63                       ;START OF SECTOR, RIGHT ONE
7593          CMP      B                        ;COMPARE TO FIND OUT
7594          JNZ      SECLP                    ;IF NOT
7595          MVI      A,128                    ;WRITE ENABLE DISK
7596          OUT      9        
7597          MVI      B,255                    ;ALL ONE'S ALWAYS WRITTEN FIRST
7598 WRITOK:  IN       8                        ;GET STATUS
7599          ANA      D                        ;WRITE OK
7600          JZ       WRITOK                   ;NO, MORE LOOPING.
7601          MOV      A,B                      ;GET CHARACTER TO WRITE
7602          OUT      10                       ;SEND IT OUT
7603          DCR      C                        ;TEST FOR NULL
7604          JZ       ZRLOP    
7605 NOTYTD:  IN       8                        ;POLL
7606          ANA      D                        ;MASK TEST
7607          JZ       NOTYTD                   ;WAITING
7608          MOV      A,M                      ;GET CHARACTER
7609          OUT      10       
7610          DCR      C                        ;DECREMENT CHARACTER COUNT
7611          INX      H        
7612          JNZ      NOTYTD   
7613 ZRLOP:   IN       8        
7614          ANA      D        
7615          JZ       ZRLOP    
7616          XRA      A                        ;PUT OUT A ZERO
7617          OUT      10       
7618          DCR      E        
7619          JNZ      ZRLOP    
7620 TRUFIN:  MVI      A,8                      ;UNLOAD THE HEAD
7621          OUT      9        
7622          POP      H        
7623          RET                               ;DONE
7624 
7625 DSKI$:   MVI      A,137                    ;A LOT OF CHARACTERS ARE COMING
7626          CALL     STRINI                   ;MAKE ROOM!
7627          CALL     CONINT                   ;WHERE ARE THEY?
7628                                            ;SECTOR NOW IN [E]
7629          LHLD     DSCTMP+2                 ;PLACE TO STORE THEM
7630          MVI      A,4                      ;LOAD THE HEAD
7631          OUT      9        
7632 SECLP2:  IN       9                        ;GET SECTOR INFO
7633          ORA      A                        ;SEE IF BEGINNING OF SECTOR(READ)
7634          JP       SECLP2                   ;IF NOT, KEEP WAITING
7635          RAR                               ;FIX UP SECTOR #
7636          ANI      63                       ;GET SECTOR #
7637          CMP      E                        ;IS IT THE ONE WE WANTED
7638          JNZ      SECLP2                   ;TRY TO FIND IT
7639          MVI      C,137                    ;GET # OF CHARS TO READ
7640 READOK:  IN       8                        ;GET DISK STATUS
7641          ORA      A                        ;READY TO READ BYTE
7642          JP       READOK   
7643          IN       10                       ;READ THE STUFF
7644          MOV      M,A                      ;SAVE IN STR
7645          INX      H                        ;BUMP DEST POINTER
7646          DCR      C                        ;LESS CHARS
7647          JNZ      READOK   
7648          MVI      A,8                      ;UNLOAD HEAD
7649          OUT      9        
7650          JMP      FINBCK                   ;USE CHRS TO FINISH UP
7651 
7652 PATCH:   BLOCK    20>      
7653 PAGE     
7654 SUBTTL   CLOAD, CSAVE, CONSOLE
7655 ; 
7656 ; THE CONSOLE COMMAND ALLOWS THE USER TO CHANGE THE I/O CHANNEL
7657 ; THAT THE USER TERMINAL IS ON. BY GIVING THE COMMAND CONSOLE X
7658 ; WHERE X IS SOME INTEGER THE TERMINAL DEVICE WILL BE POLLED FROM
7659 ; CHANNELS X AND X+1. RESTARTING AT LOCATION ZERO FORCES THE TERMINAL
7660 ; TO BE ON CHANNEL ZERO AGAIN.
7661 ; 
7662 IFN      CONSSW,< 
7663 INTERNAL CONSDO   
7664 CONSDO:  XRA      A                        ;FORCE A CHANNEL ZERO CONSOLE
7665          CALL     CONS2                    ;ON RESTART AT ZERO
7666          JMP      READY                    ;TYPE "OK" AND ACCEPT INPUT
7667 CONSOL:  CALL     GETBYT                   ;FETCH AN INTEGER INTO [A]
7668          RNZ                               ;CHECK FOR A TERMINATOR
7669 CONS2:   
7670 IFN      REALIO,< 
7671          STA      CNLCA1                   ;CHANGE ALL THE FLAG INPUT CHANNEL REFERENCES
7672          STA      CNLCA2   
7673          STA      CNLCA3>  
7674 IFN      LENGTH,< 
7675          STA      CNLCA4>  
7676          INR      A                        ;[A]=DATA INPUT CHANNEL
7677          STA      CNLCB1                   ;CHANGE ALL THE DATA INPUT CHANNEL REFERENCES
7678          STA      CNLCB2   
7679          RET>     
7680 IFN      CASSW,<  
7681 ; 
7682 ; CASIN READS A CHARACTER FROM THE CASSETTE
7683 ; INTO [A] WITHOUT MODIFYING ANYTHING BUT [A] AND THE CONDITION
7684 ; CODES
7685 ; 
7686 CASIN:   IN       6                        ;ROUTINE TO READ A CHARACTER
7687          ANI      IDONE                    ;FROM THE CASSETTE INTO [A]
7688          JNZ      CASIN    
7689          IN       7                        ;READ THE DATA
7690          RET      
7691 ; 
7692 ; CASOUT OUTPUTS THE CHARACTER IN [A] TO THE CASSETTE
7693 ; WITHOUT MODIFYING ANYTHING
7694 ; 
7695 TWOCSO:  CALL     CASOUT                   ;DOUBLE OUT OF [A]
7696 CASOUT:  PUSH     PSW                      ;ROUTINE TO WRITE A CHARACTER IN [A]
7697 CASLK:   IN       6                        ;ONTO THE CASSETTE
7698          ANI      ODONE    
7699          JNZ      CASLK                    ;WAIT TILL CASSETTE IS READY
7700          POP      PSW                      ;GET THE CHARACTER BACK
7701          OUT      7                        ;OUTPUT THE CHARACTER
7702          RET      
7703 ; 
7704 ; THE CSAVE COMMAND WRITES A PROGRAM ONTO CASSETTE BY DUMPING
7705 ; BASICS CORE. THE HEADER IS THREE 211'S FOLLOWED BY A ONE
7706 ; CHARACTER FILE NAME. THE END IS THREE ZEROS IN A ROW.
7707 ; 
7708 CSAVE:   PUSH     H        
7709          MVI      A,211    
7710          CALL     CASOUT                   ;PUT OUT THE START BYTES
7711          CALL     TWOCSO                   ;TWO MORE TIMES
7712          MOV      A,M                      ;GET FILENAME
7713          CALL     CASOUT                   ;STORE AFTER 211'S
7714          LHLD     TXTTAB                   ;START OF PROGRAM
7715          XCHG     
7716          LHLD     VARTAB                   ;END OF PROGRAM
7717 LOPCSO:  LDAX     D                        ;GET A BYTE FROM THE PROGRAM
7718          INX      D        
7719          CALL     CASOUT                   ;SEND IT OUT TO THE CASSETTE
7720          COMPAR                            ;THE END?
7721          JNZ      LOPCSO                   ;IF NOT,OUTPUT MORE
7722          CALL     TWOCSO                   ;TWO MORE 0'S TO MARK THE END
7723          POP      H                        ;RESTORE THE TEXT POINTER
7724          CHRGET                            ;GO PAST THE FILE NAME
7725          RET      
7726 ; 
7727 ; THE CLOAD COMMAND CLEARS CORE AND THEN READS A PROGRAM
7728 ; FROM CASSETTE, SINCE THE LINKS OF THE FILE ON CASSETTE
7729 ; WILL BE WRONG IF THE FILE WAS SAVED WITH A DIFFERENT VERSION OF
7730 ; 
7731 ; AT 0 WON'T LEAVE THINGS IN A GARBAGE STATE.
7732 ; 
7733 CLOAD:   STA      FACLO                    ;SAVE THE FILENAME
7734          CALL     SCRTCH                   ;RESET EVERYTHING
7735 LOPCLK:  MVI      B,3                      ;NUMBER OF START CHARACTERS
7736 LOPCL2:  CALL     CASIN                    ;GET A CHARACTER
7737          CPI      211                      ;START CHARACTER?
7738          JNZ      LOPCLK                   ;NO, RESET COUNT AND LOOK SOME MORE
7739          DCR      B                        ;DECREMENT THE COUNT
7740          JNZ      LOPCL2                   ;SEEN THREE YET?
7741          LXI      H,FACLO                  ;POINT AT THE FILENAME
7742          CALL     CASIN                    ;READ THIS FILENAME
7743          CMP      M                        ;THE RIGHT FILE?
7744          JNZ      LOPCLK                   ;IF NOT, START COMPLETELY OVER
7745          LALD     TXTTAB                   ;PLACE TO STORE THE PROGRAM
7746 DOCRS:   MVI      B,4                      ;NUMBER OF ZEROS TO GET
7747                                            ;BEFORE STOPPING
7748 DOCSMR:  CALL     CASIN                    ;GET A CHARACTER
7749          MOV      M,A                      ;STORE IT
7750          CALL     REASON                   ;MAKE SURE THERE IS ROOM
7751          MOV      A,M                      ;REGET THE CHARACTER
7752          ORA      A                        ;A ZERO?
7753          INX      H        
7754          JNZ      DOCRS                    ;RESET # OF ZEROS SEEN
7755          DCR      B                        ;DECREMENT NUMBER OF ZEROS
7756          JNZ      DOCSMR                   ;SEEN FOUR?
7757          SHLD     VARTAB                   ;SETUP END OF PROGRAM
7758          LXI      H,REDDY                  ;TYPE "OK" PREMATURELY
7759          CALL     STROUT   
7760          JMP      FINI>                    ;FIX UP THE LINKS AND GO BACK TO MAIN
7761 PAGE     
7762 SUBTTL   PEEK AND POKE
7763 IFN      LENGTH,< 
7764 IFE      LENGTH-2,<
7765 PEEK:    CALL     FRCINT                   ;GET AN INTEGER IN [H,L]
7766 
7767 
7768          MOV      A,M>                     ;GET THE VALUE TO RETURN
7769 IFN      LENGTH-2,<
7770 PEEK:    CALL     POSINT                   ;GET THE VALUE OF FACLO INTO [D,E]
7771          LDAX     D>                       ;READ THE VALUE
7772          JMP      SNGFLT                   ;AND FLOAT IT
7773 
7774 
7775 IFE      LENGTH-2,<
7776 POKE:    CALL     FRMEVL   
7777 
7778 
7779          PUSH     H                        ;SAVE THE TEXT POINTER
7780          CALL     FRCINT                   ;GET INTEGER VALUE OF FAC IN [H,L]
7781 
7782 
7783          XTHL>                             ;GET BACK THE TEXT POINTER
7784 IFN      LENGTH-2,<
7785 POKE:    CALL     INTID2                   ;READ LOCATION TO POKE
7786          PUSH     D>                       ;SAVE THE LOCATION
7787          SYNCHK   44                       ;CHECK FOR A COMMA
7788 
7789          CALL     GETBYT   
7790 
7791 
7792          POP      D                        ;GET THE ADDRESS BACK
7793          STAX     D                        ;STORE IT AWAY
7794          RET>                              ;SCANNED EVERYTHING
7795 ; 
7796 ; NOTE: IN THE 8K PEEK ONLY ACCEPTS POSITIVE NUMBERS UP TO 32767
7797 ; POKE WILL ONLY TAKE AN ADDRESS UP TO 32767 , NO
7798 ; FUDGING ALLOWED. THE VALUE IS UNSIGNED.
7799 ; 
7800          .C1=.P   
7801          END      
